
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>rune-test: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rzbill/rune/cmd/rune-test/main.go (0.0%)</option>
				
				<option value="file1">github.com/rzbill/rune/cmd/rune/main.go (0.0%)</option>
				
				<option value="file2">github.com/rzbill/rune/cmd/runed/main.go (0.0%)</option>
				
				<option value="file3">github.com/rzbill/rune/examples/exec-client/main.go (0.0%)</option>
				
				<option value="file4">github.com/rzbill/rune/examples/exec-client/register-container/main.go (0.0%)</option>
				
				<option value="file5">github.com/rzbill/rune/examples/logging/main.go (0.0%)</option>
				
				<option value="file6">github.com/rzbill/rune/examples/process-runner/main.go (0.0%)</option>
				
				<option value="file7">github.com/rzbill/rune/examples/runner/docker-runner/main.go (0.0%)</option>
				
				<option value="file8">github.com/rzbill/rune/examples/runner/process-runner/complete/main.go (0.0%)</option>
				
				<option value="file9">github.com/rzbill/rune/examples/runner/process-runner/long-running/main.go (0.0%)</option>
				
				<option value="file10">github.com/rzbill/rune/examples/runner/process-runner/simple/main.go (0.0%)</option>
				
				<option value="file11">github.com/rzbill/rune/pkg/api/client/client.go (2.9%)</option>
				
				<option value="file12">github.com/rzbill/rune/pkg/api/client/instance_client.go (0.0%)</option>
				
				<option value="file13">github.com/rzbill/rune/pkg/api/client/service_client.go (0.0%)</option>
				
				<option value="file14">github.com/rzbill/rune/pkg/api/generated/common.pb.go (2.9%)</option>
				
				<option value="file15">github.com/rzbill/rune/pkg/api/generated/exec.pb.go (12.7%)</option>
				
				<option value="file16">github.com/rzbill/rune/pkg/api/generated/exec.pb.gw.go (0.0%)</option>
				
				<option value="file17">github.com/rzbill/rune/pkg/api/generated/exec_grpc.pb.go (5.3%)</option>
				
				<option value="file18">github.com/rzbill/rune/pkg/api/generated/health.pb.go (5.9%)</option>
				
				<option value="file19">github.com/rzbill/rune/pkg/api/generated/health.pb.gw.go (15.9%)</option>
				
				<option value="file20">github.com/rzbill/rune/pkg/api/generated/health_grpc.pb.go (11.8%)</option>
				
				<option value="file21">github.com/rzbill/rune/pkg/api/generated/instance.pb.go (3.3%)</option>
				
				<option value="file22">github.com/rzbill/rune/pkg/api/generated/instance.pb.gw.go (5.0%)</option>
				
				<option value="file23">github.com/rzbill/rune/pkg/api/generated/instance_grpc.pb.go (2.1%)</option>
				
				<option value="file24">github.com/rzbill/rune/pkg/api/generated/logs.pb.go (10.4%)</option>
				
				<option value="file25">github.com/rzbill/rune/pkg/api/generated/logs.pb.gw.go (0.0%)</option>
				
				<option value="file26">github.com/rzbill/rune/pkg/api/generated/logs_grpc.pb.go (5.3%)</option>
				
				<option value="file27">github.com/rzbill/rune/pkg/api/generated/service.pb.go (2.5%)</option>
				
				<option value="file28">github.com/rzbill/rune/pkg/api/generated/service.pb.gw.go (4.6%)</option>
				
				<option value="file29">github.com/rzbill/rune/pkg/api/generated/service_grpc.pb.go (1.8%)</option>
				
				<option value="file30">github.com/rzbill/rune/pkg/api/rest/middleware.go (0.0%)</option>
				
				<option value="file31">github.com/rzbill/rune/pkg/api/server/auth.go (7.7%)</option>
				
				<option value="file32">github.com/rzbill/rune/pkg/api/server/options.go (45.0%)</option>
				
				<option value="file33">github.com/rzbill/rune/pkg/api/server/server.go (67.9%)</option>
				
				<option value="file34">github.com/rzbill/rune/pkg/api/service/exec.go (16.8%)</option>
				
				<option value="file35">github.com/rzbill/rune/pkg/api/service/health.go (0.0%)</option>
				
				<option value="file36">github.com/rzbill/rune/pkg/api/service/instance.go (0.0%)</option>
				
				<option value="file37">github.com/rzbill/rune/pkg/api/service/logs.go (0.0%)</option>
				
				<option value="file38">github.com/rzbill/rune/pkg/api/service/mocks.go (62.5%)</option>
				
				<option value="file39">github.com/rzbill/rune/pkg/api/service/service.go (0.0%)</option>
				
				<option value="file40">github.com/rzbill/rune/pkg/cli/cmd/cast.go (29.4%)</option>
				
				<option value="file41">github.com/rzbill/rune/pkg/cli/cmd/get.go (20.8%)</option>
				
				<option value="file42">github.com/rzbill/rune/pkg/cli/cmd/lint.go (15.4%)</option>
				
				<option value="file43">github.com/rzbill/rune/pkg/cli/cmd/root.go (21.7%)</option>
				
				<option value="file44">github.com/rzbill/rune/pkg/cli/cmd/table.go (0.0%)</option>
				
				<option value="file45">github.com/rzbill/rune/pkg/cli/cmd/trace.go (27.3%)</option>
				
				<option value="file46">github.com/rzbill/rune/pkg/cli/cmd/version.go (50.0%)</option>
				
				<option value="file47">github.com/rzbill/rune/pkg/cli/cmd/watch.go (61.5%)</option>
				
				<option value="file48">github.com/rzbill/rune/pkg/cli/format/color.go (25.5%)</option>
				
				<option value="file49">github.com/rzbill/rune/pkg/cli/format/errors.go (0.0%)</option>
				
				<option value="file50">github.com/rzbill/rune/pkg/cli/util/file.go (0.0%)</option>
				
				<option value="file51">github.com/rzbill/rune/pkg/log/base_logger.go (36.3%)</option>
				
				<option value="file52">github.com/rzbill/rune/pkg/log/config.go (0.0%)</option>
				
				<option value="file53">github.com/rzbill/rune/pkg/log/field.go (40.0%)</option>
				
				<option value="file54">github.com/rzbill/rune/pkg/log/formatters.go (62.5%)</option>
				
				<option value="file55">github.com/rzbill/rune/pkg/log/hooks.go (0.0%)</option>
				
				<option value="file56">github.com/rzbill/rune/pkg/log/logger.go (23.5%)</option>
				
				<option value="file57">github.com/rzbill/rune/pkg/log/mock.go (0.0%)</option>
				
				<option value="file58">github.com/rzbill/rune/pkg/log/outputs.go (7.6%)</option>
				
				<option value="file59">github.com/rzbill/rune/pkg/log/utils.go (0.0%)</option>
				
				<option value="file60">github.com/rzbill/rune/pkg/orchestrator/envvar.go (100.0%)</option>
				
				<option value="file61">github.com/rzbill/rune/pkg/orchestrator/fake_instance_controller.go (25.7%)</option>
				
				<option value="file62">github.com/rzbill/rune/pkg/orchestrator/fake_orchestrator.go (0.0%)</option>
				
				<option value="file63">github.com/rzbill/rune/pkg/orchestrator/health_controller.go (73.3%)</option>
				
				<option value="file64">github.com/rzbill/rune/pkg/orchestrator/instance_controller.go (61.9%)</option>
				
				<option value="file65">github.com/rzbill/rune/pkg/orchestrator/log_streamer.go (0.0%)</option>
				
				<option value="file66">github.com/rzbill/rune/pkg/orchestrator/logs.go (0.0%)</option>
				
				<option value="file67">github.com/rzbill/rune/pkg/orchestrator/orchestrator.go (25.0%)</option>
				
				<option value="file68">github.com/rzbill/rune/pkg/orchestrator/reconciler.go (35.2%)</option>
				
				<option value="file69">github.com/rzbill/rune/pkg/orchestrator/util.go (0.0%)</option>
				
				<option value="file70">github.com/rzbill/rune/pkg/runner/docker/exec_stream.go (18.6%)</option>
				
				<option value="file71">github.com/rzbill/rune/pkg/runner/docker/log_reader.go (66.7%)</option>
				
				<option value="file72">github.com/rzbill/rune/pkg/runner/docker/runner.go (48.0%)</option>
				
				<option value="file73">github.com/rzbill/rune/pkg/runner/interface.go (0.0%)</option>
				
				<option value="file74">github.com/rzbill/rune/pkg/runner/manager/manager.go (40.3%)</option>
				
				<option value="file75">github.com/rzbill/rune/pkg/runner/manager/test_manager.go (69.6%)</option>
				
				<option value="file76">github.com/rzbill/rune/pkg/runner/mocks.go (0.0%)</option>
				
				<option value="file77">github.com/rzbill/rune/pkg/runner/process/exec_stream.go (65.9%)</option>
				
				<option value="file78">github.com/rzbill/rune/pkg/runner/process/resource_controller.go (0.0%)</option>
				
				<option value="file79">github.com/rzbill/rune/pkg/runner/process/runner.go (68.0%)</option>
				
				<option value="file80">github.com/rzbill/rune/pkg/runner/process/security/context.go (56.8%)</option>
				
				<option value="file81">github.com/rzbill/rune/pkg/runner/process/validation.go (79.4%)</option>
				
				<option value="file82">github.com/rzbill/rune/pkg/runner/test_runner.go (0.0%)</option>
				
				<option value="file83">github.com/rzbill/rune/pkg/types/cluster.go (0.0%)</option>
				
				<option value="file84">github.com/rzbill/rune/pkg/types/discovery.go (0.0%)</option>
				
				<option value="file85">github.com/rzbill/rune/pkg/types/errors.go (50.0%)</option>
				
				<option value="file86">github.com/rzbill/rune/pkg/types/function.go (0.0%)</option>
				
				<option value="file87">github.com/rzbill/rune/pkg/types/instance.go (0.0%)</option>
				
				<option value="file88">github.com/rzbill/rune/pkg/types/job.go (0.0%)</option>
				
				<option value="file89">github.com/rzbill/rune/pkg/types/namespace.go (0.0%)</option>
				
				<option value="file90">github.com/rzbill/rune/pkg/types/node.go (0.0%)</option>
				
				<option value="file91">github.com/rzbill/rune/pkg/types/policy.go (10.2%)</option>
				
				<option value="file92">github.com/rzbill/rune/pkg/types/process.go (0.0%)</option>
				
				<option value="file93">github.com/rzbill/rune/pkg/types/resources.go (0.0%)</option>
				
				<option value="file94">github.com/rzbill/rune/pkg/types/secret.go (0.0%)</option>
				
				<option value="file95">github.com/rzbill/rune/pkg/types/service.go (21.1%)</option>
				
				<option value="file96">github.com/rzbill/rune/pkg/types/spec.go (90.9%)</option>
				
				<option value="file97">github.com/rzbill/rune/pkg/version/version.go (100.0%)</option>
				
				<option value="file98">github.com/rzbill/rune/test/integration/helpers/docker.go (0.0%)</option>
				
				<option value="file99">github.com/rzbill/rune/test/integration/helpers/setup.go (0.0%)</option>
				
				<option value="file100">github.com/rzbill/rune/test/integration/helpers/test_helper.go (86.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"
)

// Simple mock CLI for integration testing
func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Println("Usage: rune-test &lt;command&gt; [args...]")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">command := os.Args[1]

        switch command </span>{
        case "cast":<span class="cov0" title="0">
                handleCast(os.Args[2:])</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Unknown command: %s\n", command)
                os.Exit(1)</span>
        }
}

func handleCast(args []string) <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fmt.Println("Usage: rune-test cast &lt;file&gt; [--namespace=&lt;namespace&gt;] [--dry-run]")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var namespace = "default"
        var dryRun = false
        var filePath = ""

        // Parse args
        for _, arg := range args </span><span class="cov0" title="0">{
                if strings.HasPrefix(arg, "--namespace=") </span><span class="cov0" title="0">{
                        namespace = strings.TrimPrefix(arg, "--namespace=")
                }</span> else<span class="cov0" title="0"> if arg == "--dry-run" </span><span class="cov0" title="0">{
                        dryRun = true
                }</span> else<span class="cov0" title="0"> if !strings.HasPrefix(arg, "--") </span><span class="cov0" title="0">{
                        filePath = arg
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("Deploying service from file: %s\n", filePath)
        fmt.Printf("Namespace: %s\n", namespace)

        if dryRun </span><span class="cov0" title="0">{
                fmt.Printf("Service 'dry-run-test' would be created\n")
                return
        }</span>

        // Read the service file
        <span class="cov0" title="0">data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading file: %s\n", err)
                os.Exit(1)
        }</span>

        // Parse the service definition
        <span class="cov0" title="0">var serviceMap map[string]interface{}
        err = json.Unmarshal(data, &amp;serviceMap)
        if err != nil </span><span class="cov0" title="0">{
                // If it's not JSON, assume it's YAML-like format
                lines := strings.Split(string(data), "\n")
                serviceMap = make(map[string]interface{})

                for _, line := range lines </span><span class="cov0" title="0">{
                        line = strings.TrimSpace(line)
                        if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">parts := strings.SplitN(line, ":", 2)
                        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                        value := strings.TrimSpace(parts[1])

                        // Handle some special cases
                        if key == "command" &amp;&amp; strings.HasPrefix(value, "[") &amp;&amp; strings.HasSuffix(value, "]") </span><span class="cov0" title="0">{
                                // Parse as array
                                cmdString := value[1 : len(value)-1]
                                cmdParts := strings.Split(cmdString, ",")
                                var cmds []string
                                for _, cmd := range cmdParts </span><span class="cov0" title="0">{
                                        cmd = strings.Trim(cmd, " \"'")
                                        cmds = append(cmds, cmd)
                                }</span>
                                <span class="cov0" title="0">serviceMap[key] = cmds</span>
                        } else<span class="cov0" title="0"> {
                                serviceMap[key] = value
                        }</span>
                }
        }

        // Create a service object for the test
        <span class="cov0" title="0">svcName, _ := serviceMap["name"].(string)
        if svcName == "" </span><span class="cov0" title="0">{
                fmt.Println("Service name not specified in file")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">svcRuntime, _ := serviceMap["runtime"].(string)
        if svcRuntime == "" </span><span class="cov0" title="0">{
                fmt.Println("Service runtime not specified in file")
                os.Exit(1)
        }</span>

        // Simple validation
        <span class="cov0" title="0">if svcRuntime != "container" &amp;&amp; svcRuntime != "process" </span><span class="cov0" title="0">{
                fmt.Printf("Error: invalid runtime\n")
                os.Exit(1)
        }</span>

        // Write to the test fixtures directory
        <span class="cov0" title="0">fixtureDir := os.Getenv("RUNE_FIXTURE_DIR")
        if fixtureDir == "" </span><span class="cov0" title="0">{
                fixtureDir = "test/integration/fixtures"
        }</span>

        // Ensure the directory exists
        <span class="cov0" title="0">err = os.MkdirAll(fixtureDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error creating fixture directory: %s\n", err)
                os.Exit(1)
        }</span>

        // Create the service file with namespace prefix
        <span class="cov0" title="0">fixturePath := fmt.Sprintf("%s/%s-%s.json", fixtureDir, namespace, svcName)

        // Add namespace to the service
        serviceMap["namespace"] = namespace

        // Write the file
        jsonData, _ := json.MarshalIndent(serviceMap, "", "  ")
        err = os.WriteFile(fixturePath, jsonData, 0644)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error writing fixture: %s\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Service '%s' created\n", svcName)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "github.com/rzbill/rune/pkg/cli/cmd"
)

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "os"
        "os/signal"
        "path/filepath"
        "strings"
        "syscall"

        "github.com/rzbill/rune/pkg/api/server"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/store"
        "github.com/rzbill/rune/pkg/version"
        "github.com/spf13/viper"
)

var (
        configFile    = flag.String("config", "", "Configuration file path")
        grpcAddr      = flag.String("grpc-addr", ":8080", "gRPC server address")
        httpAddr      = flag.String("http-addr", ":8081", "HTTP server address")
        dataDir       = flag.String("data-dir", "", "Data directory (if not specified, uses OS-specific application data directory)")
        logLevel      = flag.String("log-level", "info", "Log level (debug, info, warn, error)")
        debugLogLevel = flag.Bool("debug", false, "Enable debug mode (shorthand for --log-level=debug)")
        logFormat     = flag.String("log-format", "text", "Log format (text, json)")
        prettyLogs    = flag.Bool("pretty", false, "Enable pretty text log format (shorthand for --log-format=text)")
        apiKeys       = flag.String("api-keys", "", "Comma-separated list of API keys (empty to disable auth)")
        showHelp      = flag.Bool("help", false, "Show help")
        showVer       = flag.Bool("version", false, "Show version")
)

// getDefaultDataDir returns the default data directory based on the OS
func getDefaultDataDir() string <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "./data"
        }</span>

        // OS-specific paths
        <span class="cov0" title="0">switch </span>{
        case os.Getenv("XDG_DATA_HOME") != "":<span class="cov0" title="0">
                // Linux with XDG
                return filepath.Join(os.Getenv("XDG_DATA_HOME"), "rune")</span>
        case isDir("/var/lib"):<span class="cov0" title="0">
                // Linux/Unix system dir
                return "/var/lib/rune"</span>
        case isDir(filepath.Join(homeDir, "Library")):<span class="cov0" title="0">
                // macOS
                return filepath.Join(homeDir, "Library", "Application Support", "Rune")</span>
        case isDir(filepath.Join(homeDir, "AppData")):<span class="cov0" title="0">
                // Windows
                return filepath.Join(homeDir, "AppData", "Local", "Rune")</span>
        default:<span class="cov0" title="0">
                // Fallback
                return filepath.Join(homeDir, ".rune")</span>
        }
}

// isDir checks if a path exists and is a directory
func isDir(path string) bool <span class="cov0" title="0">{
        info, err := os.Stat(path)
        return err == nil &amp;&amp; info.IsDir()
}</span>

// loadConfig loads configuration from file and environment variables
func loadConfig() <span class="cov0" title="0">{
        // Initialize viper
        v := viper.New()

        // 1. Set default values that will be used if nothing else is specified
        defaultDataDir := getDefaultDataDir()
        v.SetDefault("server.grpc_address", ":8443")
        v.SetDefault("server.http_address", ":8081")
        v.SetDefault("data_dir", defaultDataDir)
        v.SetDefault("log.level", "info")
        v.SetDefault("log.format", "text")
        v.SetDefault("auth.api_keys", "")

        // 2. Try to load config file if specified or look in standard locations
        configFileSpecified := *configFile != ""
        if configFileSpecified </span><span class="cov0" title="0">{
                v.SetConfigFile(*configFile)
        }</span> else<span class="cov0" title="0"> {
                v.SetConfigName("rune")
                v.SetConfigType("yaml")
                v.AddConfigPath("/etc/rune/")
                v.AddConfigPath("$HOME/.rune")
                v.AddConfigPath(".")
        }</span>

        // Read config file if available
        <span class="cov0" title="0">if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if configFileSpecified </span><span class="cov0" title="0">{
                        // Only show an error if user explicitly specified a config file
                        fmt.Printf("Error reading config file %s: %s\n", *configFile, err)
                }</span> else<span class="cov0" title="0"> if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        // Show non-"not found" errors even for auto-discovered config
                        fmt.Printf("Error reading config file: %s\n", err)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("Using config file: %s\n", v.ConfigFileUsed())
        }</span>

        // 3. Override with environment variables
        <span class="cov0" title="0">v.SetEnvPrefix("RUNE")
        v.AutomaticEnv()
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

        // 4. Track which parameters were explicitly set via command-line flags
        // These will override everything else
        cmdFlags := make(map[string]bool)
        flag.Visit(func(f *flag.Flag) </span><span class="cov0" title="0">{
                cmdFlags[f.Name] = true
        }</span>)

        // 5. Apply values in order of precedence:
        // Command-line flags (already set) &gt; env vars &gt; config file &gt; defaults (already set)

        // Only apply values from config/env if not explicitly set by command-line flags
        <span class="cov0" title="0">if !cmdFlags["grpc-addr"] </span><span class="cov0" title="0">{
                *grpcAddr = v.GetString("server.grpc_address")
        }</span>

        <span class="cov0" title="0">if !cmdFlags["http-addr"] </span><span class="cov0" title="0">{
                *httpAddr = v.GetString("server.http_address")
        }</span>

        <span class="cov0" title="0">if !cmdFlags["data-dir"] </span><span class="cov0" title="0">{
                dataDirFromConfig := v.GetString("data_dir")
                if dataDirFromConfig != "" </span><span class="cov0" title="0">{
                        *dataDir = dataDirFromConfig
                }</span> else<span class="cov0" title="0"> {
                        *dataDir = defaultDataDir
                }</span>
        }

        <span class="cov0" title="0">if !cmdFlags["log-level"] </span><span class="cov0" title="0">{
                *logLevel = v.GetString("log.level")
        }</span>

        <span class="cov0" title="0">if !cmdFlags["log-format"] </span><span class="cov0" title="0">{
                *logFormat = v.GetString("log.format")
        }</span>

        <span class="cov0" title="0">if !cmdFlags["debug"] </span><span class="cov0" title="0">{
                *debugLogLevel = v.GetBool("debug")
        }</span>

        <span class="cov0" title="0">if !cmdFlags["pretty"] </span><span class="cov0" title="0">{
                *prettyLogs = v.GetBool("pretty")
        }</span>

        <span class="cov0" title="0">if !cmdFlags["api-keys"] </span><span class="cov0" title="0">{
                *apiKeys = v.GetString("auth.api_keys")
        }</span>

        // Final validation and defaults for required parameters
        <span class="cov0" title="0">if *dataDir == "" </span><span class="cov0" title="0">{
                *dataDir = defaultDataDir
        }</span>
}

func main() <span class="cov0" title="0">{
        // Parse flags
        flag.Parse()

        // Show help if requested
        if *showHelp </span><span class="cov0" title="0">{
                flag.Usage()
                return
        }</span>

        // Show version if requested
        <span class="cov0" title="0">if *showVer </span><span class="cov0" title="0">{
                fmt.Println(version.Info())
                return
        }</span>

        // Load configuration
        <span class="cov0" title="0">loadConfig()

        // If --pretty flag is set, override log format
        if *prettyLogs </span><span class="cov0" title="0">{
                *logFormat = "text"
        }</span>

        <span class="cov0" title="0">if *debugLogLevel </span><span class="cov0" title="0">{
                *logLevel = "debug"
        }</span>

        // Create logger with appropriate formatter
        <span class="cov0" title="0">var loggerOpts []log.LoggerOption

        // Convert string log level to log.Level type
        level, err := log.ParseLevel(*logLevel)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Invalid log level: %s, defaulting to 'info'\n", *logLevel)
                level = log.InfoLevel
        }</span>
        <span class="cov0" title="0">loggerOpts = append(loggerOpts, log.WithLevel(level))

        // Configure logger format
        switch strings.ToLower(*logFormat) </span>{
        case "json":<span class="cov0" title="0">
                loggerOpts = append(loggerOpts, log.WithFormatter(&amp;log.JSONFormatter{}))</span>
        case "text", "pretty":<span class="cov0" title="0">
                loggerOpts = append(loggerOpts, log.WithFormatter(&amp;log.TextFormatter{}))</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Invalid log format: %s, defaulting to 'text'\n", *logFormat)
                loggerOpts = append(loggerOpts, log.WithFormatter(&amp;log.TextFormatter{}))</span>
        }

        <span class="cov0" title="0">logger := log.NewLogger(loggerOpts...)

        logger.Info("Starting Rune Server", log.Str("version", version.Version))

        // Create context with cancellation
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Set up signal handler for graceful shutdown
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                sig := &lt;-sigCh
                logger.Info("Received signal", log.Str("signal", sig.String()))
                cancel()
        }</span>()

        // Ensure data directory exists
        <span class="cov0" title="0">storeDir := filepath.Join(*dataDir, "store")
        if err := os.MkdirAll(storeDir, 0755); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create data directory", log.Str("path", storeDir), log.Err(err))
                os.Exit(1)
        }</span>

        // Initialize state store
        <span class="cov0" title="0">logger.Info("Initializing state store", log.Str("path", storeDir))
        stateStore := store.NewBadgerStore(logger)
        if err := stateStore.Open(storeDir); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to open state store", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer stateStore.Close()

        // Parse API keys
        var apiKeysList []string
        if *apiKeys != "" </span><span class="cov0" title="0">{
                apiKeysList = parseAPIKeys(*apiKeys)
                logger.Info("Authentication enabled", log.Int("numKeys", len(apiKeysList)))
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Authentication disabled")
        }</span>

        // Create API server options
        <span class="cov0" title="0">serverOpts := []server.Option{
                server.WithGRPCAddr(*grpcAddr),
                server.WithHTTPAddr(*httpAddr),
                server.WithStore(stateStore),
                server.WithLogger(logger),
        }

        // Add auth if API keys are provided
        if len(apiKeysList) &gt; 0 </span><span class="cov0" title="0">{
                serverOpts = append(serverOpts, server.WithAuth(apiKeysList))
        }</span>

        // Create and start API server
        <span class="cov0" title="0">apiServer, err := server.New(serverOpts...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create API server", log.Err(err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err := apiServer.Start(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to start API server", log.Err(err))
                os.Exit(1)
        }</span>

        // Wait for cancellation
        <span class="cov0" title="0">&lt;-ctx.Done()

        // Gracefully stop the API server
        if err := apiServer.Stop(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to stop API server", log.Err(err))
        }</span>

        <span class="cov0" title="0">logger.Info("Rune server stopped")</span>
}

// parseAPIKeys parses a comma-separated list of API keys.
func parseAPIKeys(keys string) []string <span class="cov0" title="0">{
        if keys == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return splitCSV(keys)</span>
}

// splitCSV splits a comma-separated string into a slice of strings.
func splitCSV(s string) []string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var result []string
        for _, part := range splitAndTrim(s, ',') </span><span class="cov0" title="0">{
                if part != "" </span><span class="cov0" title="0">{
                        result = append(result, part)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// splitAndTrim splits a string by a separator and trims each part.
func splitAndTrim(s string, sep rune) []string <span class="cov0" title="0">{
        var result []string
        var part string
        for _, c := range s </span><span class="cov0" title="0">{
                if c == sep </span><span class="cov0" title="0">{
                        result = append(result, part)
                        part = ""
                }</span> else<span class="cov0" title="0"> {
                        part += string(c)
                }</span>
        }
        <span class="cov0" title="0">if part != "" </span><span class="cov0" title="0">{
                result = append(result, part)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "os/signal"

        "github.com/rzbill/rune/pkg/api/generated"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

// ExecClient demonstrates how to use the bidirectional streaming exec functionality.
func main() <span class="cov0" title="0">{
        // Connect to the Rune gRPC server
        conn, err := grpc.Dial("localhost:8080", grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to connect to server: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create a client for the ExecService
        client := generated.NewExecServiceClient(conn)

        // Check command line arguments
        if len(os.Args) &lt; 3 </span><span class="cov0" title="0">{
                fmt.Println("Usage: exec-client &lt;instance-id&gt; &lt;command&gt; [args...]")
                fmt.Println("Example: exec-client instance123 ls -la")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">instanceID := os.Args[1]
        command := os.Args[2:]

        // Set up context with cancellation
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Set up interrupt handling
        signalCh := make(chan os.Signal, 1)
        signal.Notify(signalCh, os.Interrupt)
        go func() </span><span class="cov0" title="0">{
                &lt;-signalCh
                fmt.Println("\nReceived interrupt, closing connection...")
                cancel()
        }</span>()

        // Start the bidirectional stream
        <span class="cov0" title="0">stream, err := client.StreamExec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create stream: %v\n", err)
                os.Exit(1)
        }</span>

        // Send initial exec request
        <span class="cov0" title="0">initReq := &amp;generated.ExecRequest{
                Request: &amp;generated.ExecRequest_Init{
                        Init: &amp;generated.ExecInitRequest{
                                Target: &amp;generated.ExecInitRequest_InstanceId{
                                        InstanceId: instanceID,
                                },
                                Command: command,
                                Tty:     true, // Enable TTY for interactive sessions
                        },
                },
        }

        if err := stream.Send(initReq); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to send initial request: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Executing command: %v on instance: %s\n", command, instanceID)

        // Use a separate goroutine to read stdin and send to the server
        go func() </span><span class="cov0" title="0">{
                scanner := bufio.NewScanner(os.Stdin)
                for scanner.Scan() </span><span class="cov0" title="0">{
                        // Send stdin data to the server
                        stdinReq := &amp;generated.ExecRequest{
                                Request: &amp;generated.ExecRequest_Stdin{
                                        Stdin: append(scanner.Bytes(), '\n'),
                                },
                        }

                        if err := stream.Send(stdinReq); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to send stdin: %v\n", err)
                                cancel()
                                return
                        }</span>
                }

                // If stdin is closed, complete the stream
                <span class="cov0" title="0">cancel()</span>
        }()

        // Receive and process responses from the server
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                resp, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        // Stream closed by server
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error receiving response: %v\n", err)
                        break</span>
                }

                // Process response based on type
                <span class="cov0" title="0">switch r := resp.Response.(type) </span>{
                case *generated.ExecResponse_Stdout:<span class="cov0" title="0">
                        // Print stdout data
                        fmt.Print(string(r.Stdout))</span>

                case *generated.ExecResponse_Stderr:<span class="cov0" title="0">
                        // Print stderr data
                        fmt.Fprint(os.Stderr, string(r.Stderr))</span>

                case *generated.ExecResponse_Status:<span class="cov0" title="0">
                        // Print status message
                        if r.Status.Code != 0 </span><span class="cov0" title="0">{
                                fmt.Printf("Status error (code %d): %s\n", r.Status.Code, r.Status.Message)
                        }</span>

                case *generated.ExecResponse_Exit:<span class="cov0" title="0">
                        // Print exit information
                        if r.Exit.Code != 0 </span><span class="cov0" title="0">{
                                fmt.Printf("Command exited with code %d\n", r.Exit.Code)
                        }</span>

                default:<span class="cov0" title="0">
                        fmt.Printf("Received unknown response type\n")</span>
                }
        }

        <span class="cov0" title="0">fmt.Println("Exec session completed")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/google/uuid"
        "github.com/rzbill/rune/pkg/api/generated"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/store"
        "github.com/rzbill/rune/pkg/types"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

// DirectRegistration demonstrates how to directly register a container with Rune
// by adding it to the store and then calling StartInstance
func main() <span class="cov0" title="0">{
        // Check command line arguments
        if len(os.Args) != 2 </span><span class="cov0" title="0">{
                fmt.Println("Usage: register-container &lt;container-id&gt;")
                fmt.Println("Example: register-container abcdef123456")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">containerID := os.Args[1]

        // Create a logger
        logger := log.NewLogger()

        // Generate a unique instance ID
        instanceID := fmt.Sprintf("inst-%s", uuid.New().String()[:8])

        // Step 1: Create a store and add the instance to it
        storeDir := "./data/store"
        badgerStore := store.NewBadgerStore(logger)
        if err := badgerStore.Open(storeDir); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to open store: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer badgerStore.Close()

        // Create the instance to register
        instance := &amp;types.Instance{
                ID:          instanceID,
                Name:        "test-instance",
                ServiceID:   "test-service",
                ContainerID: containerID,
                Status:      types.InstanceStatusCreated,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        // Save the instance to the store
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        namespace := "default"
        if err := badgerStore.Create(ctx, types.ResourceTypeInstance, namespace, instanceID, instance); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to save instance to store: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Container registered in store successfully!\n")

        // Step 2: Call StartInstance to activate it
        // Connect to the Rune gRPC server
        conn, err := grpc.Dial("localhost:8080", grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to connect to gRPC server: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create a client for the InstanceService
        instanceClient := generated.NewInstanceServiceClient(conn)

        // Create an instance action request to start the instance
        startReq := &amp;generated.InstanceActionRequest{
                Id:             instanceID,
                TimeoutSeconds: 30, // Default timeout
        }

        // Call the StartInstance method
        resp, err := instanceClient.StartInstance(ctx, startReq)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to start instance: %v\n", err)
                fmt.Println("Instance is registered in the store but could not be started.")
                fmt.Println("This could be because the container doesn't exist or is not running.")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Instance started successfully!\n")
                fmt.Printf("Instance ID: %s\n", resp.Instance.Id)
                fmt.Printf("Container ID: %s\n", resp.Instance.ContainerId)
                fmt.Printf("Status: %s\n", resp.Instance.Status)
        }</span>

        // Show how to use the exec-client with the registered instance
        <span class="cov0" title="0">fmt.Println("\nNow you can use the exec-client with the registered instance ID:")
        fmt.Printf("go run examples/exec-client/main.go %s ls -la\n", instanceID)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "math/rand"
        "time"

        "github.com/rzbill/rune/pkg/log"
)

func main() <span class="cov0" title="0">{
        // Create a logger with the improved text formatter
        logger := log.NewLogger(
                log.WithLevel(log.DebugLevel),
                log.WithFormatter(&amp;log.TextFormatter{
                        ShortTimestamp: false,
                        DisableColors:  false,
                        EnableCaller:   false,
                }),
        )

        // Set as the default logger
        log.SetDefaultLogger(logger)

        // Basic examples with the new Field-based API
        log.Info("Application starting", log.Component("app"))

        log.Debug("Debug message with fields",
                log.Str("user", "admin"),
                log.Int("attempt", 1),
                log.Bool("success", true))

        // Error handling with the Err helper
        if err := simulateError(); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to process request",
                        log.Err(err),
                        log.Component("processor"),
                        log.Int("status", 500))
        }</span>

        // Context with trace information
        <span class="cov0" title="0">ctx := context.Background()
        ctx = context.WithValue(ctx, log.RequestIDKey, "req-12345")
        ctx = context.WithValue(ctx, log.TraceIDKey, "trace-abcdef")
        ctx = context.WithValue(ctx, log.SpanIDKey, "span-123456")

        // Operation with context and timing
        performOperation(ctx)

        // Using With to create a component logger
        apiLogger := log.With(log.Component("api-server"))

        // Log various message types
        apiLogger.Info("API server initialized")
        apiLogger.Info("Server listening", log.Int("port", 8080))

        // Process a request
        processRequest(apiLogger)

        // Simulate different log levels
        logAllLevels()</span>
}

func simulateError() error <span class="cov0" title="0">{
        return errors.New("connection timeout")
}</span>

func performOperation(ctx context.Context) <span class="cov0" title="0">{
        logger := log.FromContext(ctx).With(
                log.Component("worker"),
                log.Str("operation", "data-processing"))

        logger.Info("Starting operation")

        start := time.Now()
        // Simulate work
        time.Sleep(time.Millisecond * time.Duration(rand.Intn(100)))

        logger.Info("Operation completed",
                log.Duration("duration", time.Since(start)),
                log.Int("records_processed", 42))
}</span>

func processRequest(logger log.Logger) <span class="cov0" title="0">{
        requestID := fmt.Sprintf("%d", rand.Int63())

        // Add request context to the logger
        reqLogger := logger.With(
                log.RequestID(requestID),
                log.Str("method", "GET"),
                log.Str("path", "/api/users"))

        reqLogger.Info("Request started")

        // Simulate processing
        start := time.Now()
        time.Sleep(time.Millisecond * time.Duration(rand.Intn(50)))

        // Log completion with duration and status
        reqLogger.Info("Request completed",
                log.Int("status", 200),
                log.Duration("duration_ms", time.Since(start)))
}</span>

func logAllLevels() <span class="cov0" title="0">{
        component := log.Component("demo")

        log.Debug("This is a debug message", component)
        log.Info("This is an info message", component)
        log.Warn("This is a warning message", component)
        log.Error("This is an error message", component)

        // Uncomment to see fatal (will exit the program)
        // log.Fatal("This is a fatal message", component)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "os"
        "time"

        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner"
        "github.com/rzbill/rune/pkg/runner/process"
        "github.com/rzbill/rune/pkg/types"
)

func main() <span class="cov0" title="0">{
        // Create a context with a timeout
        ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
        defer cancel()

        // Create a logger
        logger := log.NewLogger()

        // Create a process runner
        processRunner, err := process.NewProcessRunner(
                process.WithLogger(logger),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create process runner", log.Err(err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("Created process runner")

        // Create an instance with resource limits
        resources := &amp;types.Resources{
                CPU: types.ResourceLimit{
                        Request: "100m", // 0.1 CPU cores
                        Limit:   "200m", // 0.2 CPU cores
                },
                Memory: types.ResourceLimit{
                        Request: "64Mi",  // 64 MiB
                        Limit:   "128Mi", // 128 MiB
                },
        }

        instance := &amp;types.Instance{
                ID:        "example-echo",
                Name:      "example-echo",
                NodeID:    "local",
                ServiceID: "example-service",
                Resources: resources,
                Process: &amp;types.ProcessSpec{
                        Command: "echo",
                        Args:    []string{"Hello from process runner!"},
                },
        }

        // Create the instance
        logger.Info("Creating process instance")
        if err := processRunner.Create(ctx, instance); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create instance", log.Err(err))
                os.Exit(1)
        }</span>

        // Start the instance
        <span class="cov0" title="0">logger.Info("Starting process instance")
        if err := processRunner.Start(ctx, instance); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to start instance", log.Err(err))
                os.Exit(1)
        }</span>

        // Wait for the process to complete
        <span class="cov0" title="0">time.Sleep(1 * time.Second)

        // Get the status of the process
        status, err := processRunner.Status(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get instance status", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Info("Process status", log.Str("status", string(status)))

        // Get the logs from the process
        logger.Info("Getting process logs")
        logs, err := processRunner.GetLogs(ctx, instance, runner.LogOptions{
                Tail:       10,
                Timestamps: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get logs", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer logs.Close()

        // Print the logs
        logContent, err := io.ReadAll(logs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read logs", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Log output:\n%s\n", string(logContent))

        // List all instances
        instances, err := processRunner.List(ctx, instance.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list instances", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Info(fmt.Sprintf("Found %d instances", len(instances)))

        // Remove the instance
        logger.Info("Removing process instance")
        if err := processRunner.Remove(ctx, instance, true); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove instance", log.Err(err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("Process example completed successfully")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "os"
        "time"

        "github.com/google/uuid"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner"
        "github.com/rzbill/rune/pkg/runner/docker"
        "github.com/rzbill/rune/pkg/types"
)

func main() <span class="cov0" title="0">{
        // Create a logger with the text formatter
        logger := log.NewLogger(
                log.WithLevel(log.InfoLevel),
                log.WithFormatter(&amp;log.TextFormatter{
                        ShortTimestamp: false, // Use full timestamp (default)
                        DisableColors:  false, // Enable colors
                }),
        )

        // Set it as the default logger
        log.SetDefaultLogger(logger)

        // Create a component-specific logger
        runnerLogger := logger.WithComponent("runner-example")
        runnerLogger.Info("Starting Rune Docker Runner example")

        // Create a Docker runner
        dockerRunner, err := docker.NewDockerRunner(runnerLogger)
        if err != nil </span><span class="cov0" title="0">{
                runnerLogger.Fatal("Failed to create Docker runner", log.Err(err))
        }</span>

        // Create a context with timeout
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
        defer cancel()

        // Create a unique ID for the instance
        instanceID := uuid.New().String()
        instanceName := fmt.Sprintf("example-%s", instanceID[:8])

        // Create instance object
        instance := &amp;types.Instance{
                ID:        instanceID,
                Name:      instanceName,
                ServiceID: "example-service",
                NodeID:    "local",
        }

        // Create the instance
        runnerLogger.Info("Creating instance", log.Str("name", instanceName))
        if err := dockerRunner.Create(ctx, instance); err != nil </span><span class="cov0" title="0">{
                runnerLogger.Fatal("Failed to create instance", log.Err(err))
        }</span>
        <span class="cov0" title="0">runnerLogger.Info("Created instance",
                log.Str("container_id", instance.ContainerID),
                log.Str("instance_id", instance.ID))

        // Start the instance
        runnerLogger.Info("Starting instance", log.Str("id", instanceID))
        if err := dockerRunner.Start(ctx, instance); err != nil </span><span class="cov0" title="0">{
                runnerLogger.Fatal("Failed to start instance", log.Err(err))
        }</span>

        // Wait a bit for the container to start up
        <span class="cov0" title="0">runnerLogger.Info("Waiting for container to start...")
        time.Sleep(2 * time.Second)

        // Get the status
        status, err := dockerRunner.Status(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                runnerLogger.Fatal("Failed to get status", log.Err(err))
        }</span>
        <span class="cov0" title="0">runnerLogger.Info("Instance status", log.Str("status", string(status)))

        // Get logs
        runnerLogger.Info("Getting logs for instance", log.Str("id", instanceID))
        logs, err := dockerRunner.GetLogs(ctx, instance, runner.LogOptions{
                Tail:       10,
                Follow:     false,
                Timestamps: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                runnerLogger.Fatal("Failed to get logs", log.Err(err))
        }</span>

        // Print logs
        <span class="cov0" title="0">runnerLogger.Info("Logs:")
        if _, err := io.Copy(os.Stdout, logs); err != nil </span><span class="cov0" title="0">{
                runnerLogger.Fatal("Failed to read logs", log.Err(err))
        }</span>
        <span class="cov0" title="0">logs.Close()

        // List all instances
        runnerLogger.Info("Listing all instances:")
        instances, err := dockerRunner.List(ctx, instance.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                runnerLogger.Fatal("Failed to list instances", log.Err(err))
        }</span>
        <span class="cov0" title="0">for _, inst := range instances </span><span class="cov0" title="0">{
                runnerLogger.Info("Instance",
                        log.Str("name", inst.Name),
                        log.Str("id", inst.ID),
                        log.Str("status", string(inst.Status)))
        }</span>

        // Cleanup
        <span class="cov0" title="0">runnerLogger.Info("Stopping instance", log.Str("id", instanceID))
        if err := dockerRunner.Stop(ctx, instance, 10*time.Second); err != nil </span><span class="cov0" title="0">{
                runnerLogger.Fatal("Failed to stop instance", log.Err(err))
        }</span>

        <span class="cov0" title="0">runnerLogger.Info("Removing instance", log.Str("id", instanceID))
        if err := dockerRunner.Remove(ctx, instance, false); err != nil </span><span class="cov0" title="0">{
                runnerLogger.Fatal("Failed to remove instance", log.Err(err))
        }</span>

        <span class="cov0" title="0">runnerLogger.Info("Example completed successfully!")</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"

        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner"
        "github.com/rzbill/rune/pkg/runner/process"
        "github.com/rzbill/rune/pkg/types"
)

func main() <span class="cov0" title="0">{
        // Create a context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
        defer cancel()

        // Create a logger
        logger := log.NewLogger(
                log.WithLevel(log.InfoLevel),
                log.WithFormatter(&amp;log.TextFormatter{
                        ShortTimestamp: false,
                        DisableColors:  false,
                }),
        )

        // Create process runner
        processRunner, err := process.NewProcessRunner(
                process.WithLogger(logger),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create process runner", log.Err(err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("Created process runner")

        // Create temporary directory for test executable
        tempDir, err := os.MkdirTemp("", "process-runner-example")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create temp directory", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(tempDir)

        // Create a test script
        scriptPath := filepath.Join(tempDir, "test-script.sh")
        scriptContent := `#!/bin/sh
echo "Hello from a custom script!"
echo "Current working directory: $(pwd)"
echo "Running as user: $(id -un)"
echo "Arguments: $@"
`
        if err := os.WriteFile(scriptPath, []byte(scriptContent), 0755); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create test script", log.Err(err))
                os.Exit(1)
        }</span>

        // ------------------------------------------------------------
        // Example 1: Using command from PATH
        // ------------------------------------------------------------
        <span class="cov0" title="0">logger.Info("Example 1: Using command from PATH")

        instance1 := &amp;types.Instance{
                ID:        "path-example-1",
                Name:      "echo-from-path",
                NodeID:    "local",
                ServiceID: "example-service",
                Process: &amp;types.ProcessSpec{
                        Command: "echo", // Using command from PATH
                        Args:    []string{"This command is found in the system PATH"},
                },
        }

        // Create and run the instance
        runInstance(ctx, processRunner, instance1, logger)

        // ------------------------------------------------------------
        // Example 2: Using absolute path to executable
        // ------------------------------------------------------------
        logger.Info("Example 2: Using absolute path to executable")

        instance2 := &amp;types.Instance{
                ID:        "path-example-2",
                Name:      "script-with-absolute-path",
                NodeID:    "local",
                ServiceID: "example-service",
                Process: &amp;types.ProcessSpec{
                        Command: scriptPath, // Using absolute path to our test script
                        Args:    []string{"arg1", "arg2", "arg3"},
                },
        }

        // Create and run the instance
        runInstance(ctx, processRunner, instance2, logger)

        // ------------------------------------------------------------
        // Example 3: With Security Context (if not running as root, this may fail)
        // ------------------------------------------------------------
        logger.Info("Example 3: With Security Context (may require root)")

        // Create instance with security context
        // Note: This example will only work properly when running as root
        instance3 := &amp;types.Instance{
                ID:        "path-example-3",
                Name:      "with-security-context",
                NodeID:    "local",
                ServiceID: "example-service",
                Process: &amp;types.ProcessSpec{
                        Command: scriptPath,
                        Args:    []string{"with security context"},
                        SecurityContext: &amp;types.ProcessSecurityContext{
                                // On most systems, 'nobody' is a restricted user that exists
                                // Note: This requires the example to be run as root
                                User:       "nobody",
                                ReadOnlyFS: true, // This is currently just logged as a warning
                        },
                },
        }

        // Try to create and run the instance, but handle failure gracefully
        err = processRunner.Create(ctx, instance3)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Could not create instance with security context",
                        log.Str("error", err.Error()),
                        log.Str("note", "This is expected if not running as root"))
        }</span> else<span class="cov0" title="0"> {
                // If creation succeeded, try to run it
                // Don't re-create the instance, just start, get logs, and clean up
                if err := processRunner.Start(ctx, instance3); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to start instance with security context",
                                log.Str("id", instance3.ID),
                                log.Err(err))
                        // Clean up
                        _ = processRunner.Remove(ctx, instance3, true)
                }</span> else<span class="cov0" title="0"> {
                        // Wait for process to complete
                        time.Sleep(500 * time.Millisecond)

                        // Get logs
                        logs, err := processRunner.GetLogs(ctx, instance3, runner.LogOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to get logs",
                                        log.Str("id", instance3.ID),
                                        log.Err(err))
                        }</span> else<span class="cov0" title="0"> {
                                // Read and print logs
                                logContent, err := io.ReadAll(logs)
                                logs.Close()
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Error("Failed to read logs",
                                                log.Str("id", instance3.ID),
                                                log.Err(err))
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("--- Logs for %s ---\n%s\n", instance3.ID, string(logContent))
                                }</span>
                        }

                        // Cleanup
                        <span class="cov0" title="0">if err := processRunner.Remove(ctx, instance3, true); err != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to remove instance",
                                        log.Str("id", instance3.ID),
                                        log.Err(err))
                        }</span>
                }
        }

        // ------------------------------------------------------------
        // Example 4: Invalid path (should fail with validation error)
        // ------------------------------------------------------------
        <span class="cov0" title="0">logger.Info("Example 4: Invalid path (should fail with validation error)")

        instance4 := &amp;types.Instance{
                ID:        "path-example-4",
                Name:      "invalid-path",
                NodeID:    "local",
                ServiceID: "example-service",
                Process: &amp;types.ProcessSpec{
                        Command: "/path/to/nonexistent/executable",
                        Args:    []string{},
                },
        }

        // Try to create (should fail with validation error)
        err = processRunner.Create(ctx, instance4)
        if err != nil </span><span class="cov0" title="0">{
                logger.Info("Received expected validation error",
                        log.Str("error", err.Error()))
        }</span> else<span class="cov0" title="0"> {
                logger.Error("Expected validation to fail but it did not")
        }</span>

        // ------------------------------------------------------------
        // Example 5: Non-executable file (should fail with validation error)
        // ------------------------------------------------------------
        <span class="cov0" title="0">logger.Info("Example 5: Non-executable file (should fail)")

        // Create a non-executable file
        nonExecPath := filepath.Join(tempDir, "non-executable.txt")
        if err := os.WriteFile(nonExecPath, []byte("This is not executable"), 0644); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create non-executable file", log.Err(err))
        }</span> else<span class="cov0" title="0"> {
                instance5 := &amp;types.Instance{
                        ID:        "path-example-5",
                        Name:      "non-executable-file",
                        NodeID:    "local",
                        ServiceID: "example-service",
                        Process: &amp;types.ProcessSpec{
                                Command: nonExecPath,
                                Args:    []string{},
                        },
                }

                // Try to create (should fail with validation error)
                err = processRunner.Create(ctx, instance5)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Info("Received expected validation error",
                                log.Str("error", err.Error()))
                }</span> else<span class="cov0" title="0"> {
                        logger.Error("Expected validation to fail but it did not")
                }</span>
        }

        <span class="cov0" title="0">logger.Info("Process runner path validation example completed")</span>
}

// runInstance is a helper function to create, start, get logs, and cleanup an instance
func runInstance(ctx context.Context, processRunner *process.ProcessRunner, instance *types.Instance, logger log.Logger) <span class="cov0" title="0">{
        // Create the instance
        if err := processRunner.Create(ctx, instance); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create instance",
                        log.Str("id", instance.ID),
                        log.Err(err))
                return
        }</span>

        // Start the instance
        <span class="cov0" title="0">if err := processRunner.Start(ctx, instance); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to start instance",
                        log.Str("id", instance.ID),
                        log.Err(err))
                // Clean up
                _ = processRunner.Remove(ctx, instance, true)
                return
        }</span>

        // Wait for process to complete
        <span class="cov0" title="0">time.Sleep(500 * time.Millisecond)

        // Get logs
        logs, err := processRunner.GetLogs(ctx, instance, runner.LogOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get logs",
                        log.Str("id", instance.ID),
                        log.Err(err))
        }</span> else<span class="cov0" title="0"> {
                // Read and print logs
                logContent, err := io.ReadAll(logs)
                logs.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to read logs",
                                log.Str("id", instance.ID),
                                log.Err(err))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("--- Logs for %s ---\n%s\n", instance.ID, string(logContent))
                }</span>
        }

        // Cleanup
        <span class="cov0" title="0">if err := processRunner.Remove(ctx, instance, true); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove instance",
                        log.Str("id", instance.ID),
                        log.Err(err))
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "os"
        "time"

        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner"
        "github.com/rzbill/rune/pkg/runner/process"
        "github.com/rzbill/rune/pkg/types"
)

// This example demonstrates a longer-running process with interactive management
func main() <span class="cov0" title="0">{
        // Create a context with a timeout
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        // Create a logger with the text formatter
        logger := log.NewLogger(
                log.WithLevel(log.InfoLevel),
                log.WithFormatter(&amp;log.TextFormatter{
                        ShortTimestamp: false, // Use full timestamp (default)
                        DisableColors:  false, // Enable colors
                }),
        )

        // Create a process runner
        processRunner, err := process.NewProcessRunner(
                process.WithLogger(logger),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create process runner", log.Err(err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("Created process runner")

        // Create an instance running a simple interval counter script
        instance := &amp;types.Instance{
                ID:        "counter-process",
                Name:      "counter",
                NodeID:    "local",
                ServiceID: "example-service",
                Process: &amp;types.ProcessSpec{
                        // Run a shell script that counts to 30 with 1-second intervals
                        Command: "sh",
                        Args: []string{
                                "-c",
                                "for i in $(seq 1 30); do echo \"Count: $i\"; sleep 1; done",
                        },
                },
        }

        // Create the instance
        logger.Info("Creating counter process instance")
        if err := processRunner.Create(ctx, instance); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create instance", log.Err(err))
                os.Exit(1)
        }</span>

        // Start the instance
        <span class="cov0" title="0">logger.Info("Starting counter process")
        if err := processRunner.Start(ctx, instance); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to start instance", log.Err(err))
                os.Exit(1)
        }</span>

        // Wait a bit to let it start
        <span class="cov0" title="0">time.Sleep(2 * time.Second)

        // Get initial status
        status, err := processRunner.Status(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get status", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Info("Process status", log.Str("status", string(status)))

        // Follow logs with timeout
        logger.Info("Following logs for 5 seconds...")
        logCtx, logCancel := context.WithTimeout(ctx, 5*time.Second)
        defer logCancel()

        logs, err := processRunner.GetLogs(logCtx, instance, runner.LogOptions{
                Follow:     true,
                Timestamps: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get logs", log.Err(err))
                os.Exit(1)
        }</span>

        // Copy logs to stdout until context timeout
        <span class="cov0" title="0">fmt.Println("Log stream:")
        _, err = io.Copy(os.Stdout, logs)
        if err != nil &amp;&amp; err != context.Canceled &amp;&amp; err != context.DeadlineExceeded </span><span class="cov0" title="0">{
                logger.Error("Error reading logs", log.Err(err))
        }</span>
        <span class="cov0" title="0">logs.Close()
        fmt.Println("\nStopped following logs")

        // Pause for user to see output
        logger.Info("Process is still running, checking status...")
        time.Sleep(1 * time.Second)

        // Get current status
        status, err = processRunner.Status(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get status", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Info("Current process status", log.Str("status", string(status)))

        // Gracefully stop the process
        logger.Info("Stopping process...")
        if err := processRunner.Stop(ctx, instance, 5*time.Second); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to stop process", log.Err(err))
                os.Exit(1)
        }</span>

        // Check status after stopping
        <span class="cov0" title="0">status, err = processRunner.Status(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get status", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Info("Status after stopping", log.Str("status", string(status)))

        // Get final logs
        finalLogs, err := processRunner.GetLogs(ctx, instance, runner.LogOptions{
                Tail: 5, // Just the last 5 lines
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get final logs", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer finalLogs.Close()

        // Show final log lines
        fmt.Println("\nFinal log lines:")
        logContent, err := io.ReadAll(finalLogs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read logs", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Println(string(logContent))

        // Remove the instance
        logger.Info("Removing process instance")
        if err := processRunner.Remove(ctx, instance, false); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove instance", log.Err(err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("Long-running process example completed successfully")</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "os"
        "time"

        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner"
        "github.com/rzbill/rune/pkg/runner/process"
        "github.com/rzbill/rune/pkg/types"
)

func main() <span class="cov0" title="0">{
        // Create a context with a timeout
        ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
        defer cancel()

        // Create a logger with the text formatter
        logger := log.NewLogger(
                log.WithLevel(log.InfoLevel),
                log.WithFormatter(&amp;log.TextFormatter{
                        ShortTimestamp: false, // Use full timestamp (default)
                        DisableColors:  false, // Enable colors
                }),
        )

        // Create a process runner
        processRunner, err := process.NewProcessRunner(
                process.WithLogger(logger),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create process runner", log.Err(err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("Created process runner")

        // Create an instance with resource limits
        resources := &amp;types.Resources{
                CPU: types.ResourceLimit{
                        Request: "100m", // 0.1 CPU cores
                        Limit:   "200m", // 0.2 CPU cores
                },
                Memory: types.ResourceLimit{
                        Request: "64Mi",  // 64 MiB
                        Limit:   "128Mi", // 128 MiB
                },
        }

        instance := &amp;types.Instance{
                ID:        "example-echo",
                Name:      "example-echo",
                NodeID:    "local",
                ServiceID: "example-service", // Add required ServiceID
                Resources: resources,
                Process: &amp;types.ProcessSpec{
                        Command: "echo",
                        Args:    []string{"Hello from process runner!"},
                },
        }

        // Create the instance
        logger.Info("Creating process instance")
        if err := processRunner.Create(ctx, instance); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create instance", log.Err(err))
                os.Exit(1)
        }</span>

        // Start the instance
        <span class="cov0" title="0">logger.Info("Starting process instance")
        if err := processRunner.Start(ctx, instance); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to start instance", log.Err(err))
                os.Exit(1)
        }</span>

        // Wait for the process to complete
        <span class="cov0" title="0">time.Sleep(1 * time.Second)

        // Get the status of the process
        status, err := processRunner.Status(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get instance status", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Info("Process status", log.Str("status", string(status)))

        // Get the logs from the process
        logger.Info("Getting process logs")
        logs, err := processRunner.GetLogs(ctx, instance, runner.LogOptions{
                Tail:       10,
                Timestamps: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get logs", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer logs.Close()

        // Print the logs
        logContent, err := io.ReadAll(logs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read logs", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Log output:\n%s\n", string(logContent))

        // List all instances
        instances, err := processRunner.List(ctx, instance.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list instances", log.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Info(fmt.Sprintf("Found %d instances", len(instances)))

        // Remove the instance
        logger.Info("Removing process instance")
        if err := processRunner.Remove(ctx, instance, true); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove instance", log.Err(err))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("Process runner example completed successfully")</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package client

import (
        "context"
        "fmt"
        "time"

        "github.com/rzbill/rune/pkg/log"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/credentials/insecure"
)

// ClientOptions holds configuration options for the API client.
type ClientOptions struct {
        // Address of the API server
        Address string

        // TLS configuration
        UseTLS      bool
        TLSCertFile string

        // Authentication
        APIKey string

        // Timeouts
        DialTimeout time.Duration
        CallTimeout time.Duration

        // Logger
        Logger log.Logger
}

// DefaultClientOptions returns the default client options.
func DefaultClientOptions() *ClientOptions <span class="cov8" title="1">{
        return &amp;ClientOptions{
                Address:     "localhost:8443",
                UseTLS:      false,
                DialTimeout: 30 * time.Second,
                CallTimeout: 30 * time.Second,
                Logger:      log.GetDefaultLogger().WithComponent("api-client"),
        }
}</span>

// Client provides a client for interacting with the Rune API server.
type Client struct {
        options *ClientOptions
        conn    *grpc.ClientConn
        logger  log.Logger
}

// NewClient creates a new API client with the given options.
func NewClient(options *ClientOptions) (*Client, error) <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                options = DefaultClientOptions()
        }</span>

        // Set up logging
        <span class="cov0" title="0">logger := options.Logger
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.GetDefaultLogger().WithComponent("api-client")
        }</span>

        // Configure connection options
        <span class="cov0" title="0">dialOpts := []grpc.DialOption{
                grpc.WithBlock(),
        }

        // Configure TLS
        if options.UseTLS </span><span class="cov0" title="0">{
                if options.TLSCertFile != "" </span><span class="cov0" title="0">{
                        creds, err := credentials.NewClientTLSFromFile(options.TLSCertFile, "")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to load TLS certificate: %w", err)
                        }</span>
                        <span class="cov0" title="0">dialOpts = append(dialOpts, grpc.WithTransportCredentials(creds))</span>
                } else<span class="cov0" title="0"> {
                        // Use default TLS credentials
                        dialOpts = append(dialOpts, grpc.WithTransportCredentials(credentials.NewTLS(nil)))
                }</span>
        } else<span class="cov0" title="0"> {
                // No TLS
                dialOpts = append(dialOpts, grpc.WithTransportCredentials(insecure.NewCredentials()))
        }</span>

        // Add authentication if provided
        <span class="cov0" title="0">if options.APIKey != "" </span><span class="cov0" title="0">{
                dialOpts = append(dialOpts, grpc.WithPerRPCCredentials(&amp;apiKeyCredentials{
                        apiKey: options.APIKey,
                        secure: options.UseTLS,
                }))
        }</span>

        // Connect to the API server
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), options.DialTimeout)
        defer cancel()

        conn, err := grpc.DialContext(ctx, options.Address, dialOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to API server at %s: %w", options.Address, err)
        }</span>

        <span class="cov0" title="0">return &amp;Client{
                options: options,
                conn:    conn,
                logger:  logger,
        }, nil</span>
}

// Close closes the client connection.
func (c *Client) Close() error <span class="cov0" title="0">{
        if c.conn != nil </span><span class="cov0" title="0">{
                return c.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Context returns a context with the configured call timeout.
func (c *Client) Context() (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        return context.WithTimeout(context.Background(), c.options.CallTimeout)
}</span>

// apiKeyCredentials implements the grpc.PerRPCCredentials interface for API key authentication.
type apiKeyCredentials struct {
        apiKey string
        secure bool
}

// GetRequestMetadata implements the grpc.PerRPCCredentials interface.
func (c *apiKeyCredentials) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) <span class="cov0" title="0">{
        return map[string]string{
                "x-api-key": c.apiKey,
        }, nil
}</span>

// RequireTransportSecurity implements the grpc.PerRPCCredentials interface.
func (c *apiKeyCredentials) RequireTransportSecurity() bool <span class="cov0" title="0">{
        return c.secure
}</span>

// parseTimestamp parses a timestamp string into a time.Time.
func parseTimestamp(timestampStr string) (*time.Time, error) <span class="cov0" title="0">{
        // Parse created_at timestamp
        if timestampStr != "" </span><span class="cov0" title="0">{
                timestamp, err := time.Parse(time.RFC3339, timestampStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse timestamp: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;timestamp, nil</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package client

import (
        "fmt"
        "time"

        "github.com/rzbill/rune/pkg/api/generated"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// InstanceClient provides methods for interacting with instances on the Rune API server.
type InstanceClient struct {
        client *Client
        logger log.Logger
        inst   generated.InstanceServiceClient
}

// NewInstanceClient creates a new instance client.
func NewInstanceClient(client *Client) *InstanceClient <span class="cov0" title="0">{
        return &amp;InstanceClient{
                client: client,
                logger: client.logger.WithComponent("instance-client"),
                inst:   generated.NewInstanceServiceClient(client.conn),
        }
}</span>

// GetInstance retrieves an instance by ID.
func (i *InstanceClient) GetInstance(namespace, id string) (*types.Instance, error) <span class="cov0" title="0">{
        i.logger.Debug("Getting instance", log.Str("id", id), log.Str("namespace", namespace))

        // Create the gRPC request
        req := &amp;generated.GetInstanceRequest{
                Id:        id,
                Namespace: namespace,
        }

        // Send the request to the API server
        ctx, cancel := i.client.Context()
        defer cancel()

        resp, err := i.inst.GetInstance(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                statusErr, ok := status.FromError(err)
                if ok &amp;&amp; statusErr.Code() == codes.NotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("instance not found: %s/%s", namespace, id)
                }</span>
                <span class="cov0" title="0">i.logger.Error("Failed to get instance", log.Err(err), log.Str("id", id))
                return nil, convertGRPCError("get instance", err)</span>
        }

        // Check if the API returned an error status
        <span class="cov0" title="0">if resp.Status != nil &amp;&amp; resp.Status.Code != int32(codes.OK) </span><span class="cov0" title="0">{
                err := fmt.Errorf("API error: %s", resp.Status.Message)
                i.logger.Error("Failed to get instance", log.Err(err), log.Str("id", id))
                return nil, err
        }</span>

        // Convert the proto message to an instance
        <span class="cov0" title="0">instance, err := i.protoToInstance(resp.Instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert instance: %w", err)
        }</span>

        <span class="cov0" title="0">return instance, nil</span>
}

// ListInstances lists instances in a namespace with optional filtering.
func (i *InstanceClient) ListInstances(namespace, serviceID, labelSelector, fieldSelector string) ([]*types.Instance, error) <span class="cov0" title="0">{
        i.logger.Debug("Listing instances",
                log.Str("namespace", namespace),
                log.Str("serviceID", serviceID),
                log.Str("labelSelector", labelSelector),
                log.Str("fieldSelector", fieldSelector))

        // Create the gRPC request
        req := &amp;generated.ListInstancesRequest{
                Namespace:     namespace,
                ServiceName:   serviceID,
                LabelSelector: make(map[string]string),
                FieldSelector: make(map[string]string),
        }

        // Parse label selector if provided
        if labelSelector != "" </span><span class="cov0" title="0">{
                labels, err := parseSelector(labelSelector)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid label selector: %w", err)
                }</span>
                <span class="cov0" title="0">req.LabelSelector = labels</span>
        }

        // Parse field selector if provided
        <span class="cov0" title="0">if fieldSelector != "" </span><span class="cov0" title="0">{
                fields, err := parseSelector(fieldSelector)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid field selector: %w", err)
                }</span>
                <span class="cov0" title="0">req.FieldSelector = fields</span>
        }

        // Send the request to the API server
        <span class="cov0" title="0">ctx, cancel := i.client.Context()
        defer cancel()

        resp, err := i.inst.ListInstances(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                i.logger.Error("Failed to list instances", log.Err(err), log.Str("namespace", namespace))
                return nil, convertGRPCError("list instances", err)
        }</span>

        // Check if the API returned an error status
        <span class="cov0" title="0">if resp.Status != nil &amp;&amp; resp.Status.Code != int32(codes.OK) </span><span class="cov0" title="0">{
                err := fmt.Errorf("API error: %s", resp.Status.Message)
                i.logger.Error("Failed to list instances", log.Err(err), log.Str("namespace", namespace))
                return nil, err
        }</span>

        // Convert the proto messages to instances
        <span class="cov0" title="0">instances := make([]*types.Instance, 0, len(resp.Instances))
        for _, protoInstance := range resp.Instances </span><span class="cov0" title="0">{
                instance, err := i.protoToInstance(protoInstance)
                if err != nil </span><span class="cov0" title="0">{
                        i.logger.Error("Failed to convert instance", log.Err(err))
                        continue</span>
                }
                <span class="cov0" title="0">instances = append(instances, instance)</span>
        }

        <span class="cov0" title="0">return instances, nil</span>
}

// StartInstance starts an instance.
func (i *InstanceClient) StartInstance(namespace, id string) error <span class="cov0" title="0">{
        i.logger.Debug("Starting instance", log.Str("id", id), log.Str("namespace", namespace))

        // Create the gRPC request
        req := &amp;generated.InstanceActionRequest{
                Id: id,
        }

        // Send the request to the API server
        ctx, cancel := i.client.Context()
        defer cancel()

        resp, err := i.inst.StartInstance(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                statusErr, ok := status.FromError(err)
                if ok &amp;&amp; statusErr.Code() == codes.NotFound </span><span class="cov0" title="0">{
                        return fmt.Errorf("instance not found: %s/%s", namespace, id)
                }</span>
                <span class="cov0" title="0">i.logger.Error("Failed to start instance", log.Err(err), log.Str("id", id))
                return convertGRPCError("start instance", err)</span>
        }

        // Check if the API returned an error status
        <span class="cov0" title="0">if resp.Status != nil &amp;&amp; resp.Status.Code != int32(codes.OK) </span><span class="cov0" title="0">{
                err := fmt.Errorf("API error: %s", resp.Status.Message)
                i.logger.Error("Failed to start instance", log.Err(err), log.Str("id", id))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// StopInstance stops an instance.
func (i *InstanceClient) StopInstance(namespace, id string, timeout time.Duration) error <span class="cov0" title="0">{
        i.logger.Debug("Stopping instance",
                log.Str("id", id),
                log.Str("namespace", namespace),
                log.Str("timeout", timeout.String()))

        // Create the gRPC request
        req := &amp;generated.InstanceActionRequest{
                Id:             id,
                TimeoutSeconds: int32(timeout.Seconds()),
        }

        // Send the request to the API server
        ctx, cancel := i.client.Context()
        defer cancel()

        resp, err := i.inst.StopInstance(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                statusErr, ok := status.FromError(err)
                if ok &amp;&amp; statusErr.Code() == codes.NotFound </span><span class="cov0" title="0">{
                        return fmt.Errorf("instance not found: %s/%s", namespace, id)
                }</span>
                <span class="cov0" title="0">i.logger.Error("Failed to stop instance", log.Err(err), log.Str("id", id))
                return convertGRPCError("stop instance", err)</span>
        }

        // Check if the API returned an error status
        <span class="cov0" title="0">if resp.Status != nil &amp;&amp; resp.Status.Code != int32(codes.OK) </span><span class="cov0" title="0">{
                err := fmt.Errorf("API error: %s", resp.Status.Message)
                i.logger.Error("Failed to stop instance", log.Err(err), log.Str("id", id))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RestartInstance restarts an instance.
func (i *InstanceClient) RestartInstance(namespace, id string, timeout time.Duration) error <span class="cov0" title="0">{
        i.logger.Debug("Restarting instance",
                log.Str("id", id),
                log.Str("namespace", namespace),
                log.Str("timeout", timeout.String()))

        // Create the gRPC request
        req := &amp;generated.InstanceActionRequest{
                Id:             id,
                TimeoutSeconds: int32(timeout.Seconds()),
        }

        // Send the request to the API server
        ctx, cancel := i.client.Context()
        defer cancel()

        resp, err := i.inst.RestartInstance(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                statusErr, ok := status.FromError(err)
                if ok &amp;&amp; statusErr.Code() == codes.NotFound </span><span class="cov0" title="0">{
                        return fmt.Errorf("instance not found: %s/%s", namespace, id)
                }</span>
                <span class="cov0" title="0">i.logger.Error("Failed to restart instance", log.Err(err), log.Str("id", id))
                return convertGRPCError("restart instance", err)</span>
        }

        // Check if the API returned an error status
        <span class="cov0" title="0">if resp.Status != nil &amp;&amp; resp.Status.Code != int32(codes.OK) </span><span class="cov0" title="0">{
                err := fmt.Errorf("API error: %s", resp.Status.Message)
                i.logger.Error("Failed to restart instance", log.Err(err), log.Str("id", id))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// InstanceWatchEvent represents an instance change event
type InstanceWatchEvent struct {
        Instance  *types.Instance
        EventType string // "ADDED", "MODIFIED", "DELETED"
        Error     error
}

// WatchInstances watches instances for changes and returns a channel of events.
// Note: This simulates watch by polling the list endpoint, since we need to regenerate
// the protobuf code to include the new WatchInstances API.
func (i *InstanceClient) WatchInstances(namespace, serviceID, labelSelector, fieldSelector string) (&lt;-chan InstanceWatchEvent, error) <span class="cov0" title="0">{
        i.logger.Debug("Watching instances",
                log.Str("namespace", namespace),
                log.Str("serviceID", serviceID),
                log.Str("labelSelector", labelSelector),
                log.Str("fieldSelector", fieldSelector))

        // Create a channel for watch events
        eventCh := make(chan InstanceWatchEvent)

        // Create a context with the client timeout - we'll use this for the initial list
        ctx, cancel := i.client.Context()
        defer cancel()

        // Do an initial list to get the current state
        instances, err := i.ListInstances(namespace, serviceID, labelSelector, fieldSelector)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to perform initial list for watch: %w", err)
        }</span>

        // Start a goroutine to poll for changes and send them to the channel
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer close(eventCh)

                // Keep track of instances we've seen
                knownInstances := make(map[string]*types.Instance)
                for _, instance := range instances </span><span class="cov0" title="0">{
                        // Send initial ADDED events for all instances
                        eventCh &lt;- InstanceWatchEvent{
                                Instance:  instance,
                                EventType: "ADDED",
                                Error:     nil,
                        }
                        knownInstances[instance.ID] = instance
                }</span>

                // Poll every 2 seconds
                <span class="cov0" title="0">ticker := time.NewTicker(2 * time.Second)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                // Create a new context for each poll
                                _, pollCancel := i.client.Context()
                                defer pollCancel()

                                // List instances again
                                currentInstances, err := i.ListInstances(namespace, serviceID, labelSelector, fieldSelector)
                                if err != nil </span><span class="cov0" title="0">{
                                        // Send error event and continue
                                        eventCh &lt;- InstanceWatchEvent{
                                                Error: fmt.Errorf("error during watch poll: %w", err),
                                        }
                                        continue</span>
                                }

                                // Track instances we've seen in this poll
                                <span class="cov0" title="0">seenInstances := make(map[string]bool)

                                // Look for new or modified instances
                                for _, instance := range currentInstances </span><span class="cov0" title="0">{
                                        seenInstances[instance.ID] = true

                                        if prev, exists := knownInstances[instance.ID]; exists </span><span class="cov0" title="0">{
                                                // Check if the instance has changed
                                                if !instanceEquals(prev, instance) </span><span class="cov0" title="0">{
                                                        // Send MODIFIED event
                                                        eventCh &lt;- InstanceWatchEvent{
                                                                Instance:  instance,
                                                                EventType: "MODIFIED",
                                                                Error:     nil,
                                                        }
                                                        knownInstances[instance.ID] = instance
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                // New instance, send ADDED event
                                                eventCh &lt;- InstanceWatchEvent{
                                                        Instance:  instance,
                                                        EventType: "ADDED",
                                                        Error:     nil,
                                                }
                                                knownInstances[instance.ID] = instance
                                        }</span>
                                }

                                // Look for deleted instances
                                <span class="cov0" title="0">for id, instance := range knownInstances </span><span class="cov0" title="0">{
                                        if _, exists := seenInstances[id]; !exists </span><span class="cov0" title="0">{
                                                // Instance was deleted, send DELETED event
                                                eventCh &lt;- InstanceWatchEvent{
                                                        Instance:  instance,
                                                        EventType: "DELETED",
                                                        Error:     nil,
                                                }
                                                delete(knownInstances, id)
                                        }</span>
                                }

                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                // Client context canceled
                                i.logger.Debug("Watch context cancelled")
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return eventCh, nil</span>
}

// instanceEquals compares two instances to see if they're functionally equivalent
func instanceEquals(a, b *types.Instance) bool <span class="cov0" title="0">{
        if a == nil || b == nil </span><span class="cov0" title="0">{
                return a == b
        }</span>

        <span class="cov0" title="0">return a.ID == b.ID &amp;&amp;
                a.Name == b.Name &amp;&amp;
                a.Namespace == b.Namespace &amp;&amp;
                a.ServiceID == b.ServiceID &amp;&amp;
                a.NodeID == b.NodeID &amp;&amp;
                a.Status == b.Status &amp;&amp;
                a.IP == b.IP</span>
}

// Helper function to convert a protobuf Instance message to a types.Instance
func (i *InstanceClient) protoToInstance(proto *generated.Instance) (*types.Instance, error) <span class="cov0" title="0">{
        if proto == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("proto instance is nil")
        }</span>

        // Create a new Instance with basic fields
        <span class="cov0" title="0">instance := &amp;types.Instance{
                ID:            proto.Id,
                Runner:        types.RunnerType(proto.Runner),
                Name:          proto.Name,
                Namespace:     proto.Namespace,
                ServiceID:     proto.ServiceId,
                ServiceName:   proto.ServiceName,
                NodeID:        proto.NodeId,
                IP:            proto.Ip,
                StatusMessage: proto.StatusMessage,
                ContainerID:   proto.ContainerId,
                PID:           int(proto.Pid),
        }

        // Parse timestamps
        createdAt, err := parseTimestamp(proto.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                i.logger.Warn("Failed to parse created_at timestamp",
                        log.Str("instance", proto.Id),
                        log.Str("timestamp", proto.CreatedAt),
                        log.Err(err))
        }</span> else<span class="cov0" title="0"> {
                instance.CreatedAt = *createdAt
        }</span>

        <span class="cov0" title="0">updatedAt, err := parseTimestamp(proto.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                i.logger.Warn("Failed to parse updated_at timestamp",
                        log.Str("instance", proto.Id),
                        log.Str("timestamp", proto.UpdatedAt),
                        log.Err(err))
        }</span> else<span class="cov0" title="0"> {
                instance.UpdatedAt = *updatedAt
        }</span>

        // Convert status
        <span class="cov0" title="0">switch proto.Status </span>{
        case generated.InstanceStatus_INSTANCE_STATUS_PENDING:<span class="cov0" title="0">
                instance.Status = types.InstanceStatusPending</span>
        case generated.InstanceStatus_INSTANCE_STATUS_CREATED:<span class="cov0" title="0">
                instance.Status = types.InstanceStatusCreated</span>
        case generated.InstanceStatus_INSTANCE_STATUS_STARTING:<span class="cov0" title="0">
                instance.Status = types.InstanceStatusStarting</span>
        case generated.InstanceStatus_INSTANCE_STATUS_RUNNING:<span class="cov0" title="0">
                instance.Status = types.InstanceStatusRunning</span>
        case generated.InstanceStatus_INSTANCE_STATUS_STOPPED:<span class="cov0" title="0">
                instance.Status = types.InstanceStatusStopped</span>
        case generated.InstanceStatus_INSTANCE_STATUS_FAILED:<span class="cov0" title="0">
                instance.Status = types.InstanceStatusFailed</span>
        case generated.InstanceStatus_INSTANCE_STATUS_EXITED:<span class="cov0" title="0">
                instance.Status = types.InstanceStatusExited</span>
        default:<span class="cov0" title="0">
                instance.Status = types.InstanceStatusPending</span> // Default to pending if unspecified
        }

        // Convert resources
        <span class="cov0" title="0">if proto.Resources != nil </span><span class="cov0" title="0">{
                instance.Resources = &amp;types.Resources{}

                if proto.Resources.Cpu != nil </span><span class="cov0" title="0">{
                        instance.Resources.CPU = types.ResourceLimit{
                                Request: proto.Resources.Cpu.Request,
                                Limit:   proto.Resources.Cpu.Limit,
                        }
                }</span>

                <span class="cov0" title="0">if proto.Resources.Memory != nil </span><span class="cov0" title="0">{
                        instance.Resources.Memory = types.ResourceLimit{
                                Request: proto.Resources.Memory.Request,
                                Limit:   proto.Resources.Memory.Limit,
                        }
                }</span>
        }

        <span class="cov0" title="0">return instance, nil</span>
}

// Helper function to convert a types.Instance to a protobuf Instance message
func (i *InstanceClient) instanceToProto(instance *types.Instance) *generated.Instance <span class="cov0" title="0">{
        if instance == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">protoInstance := &amp;generated.Instance{
                Id:            instance.ID,
                Name:          instance.Name,
                Namespace:     instance.Namespace,
                ServiceId:     instance.ServiceID,
                NodeId:        instance.NodeID,
                Ip:            instance.IP,
                StatusMessage: instance.StatusMessage,
                ContainerId:   instance.ContainerID,
                Pid:           int32(instance.PID),
        }

        // Format timestamps as RFC3339 strings
        if !instance.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                protoInstance.CreatedAt = instance.CreatedAt.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">if !instance.UpdatedAt.IsZero() </span><span class="cov0" title="0">{
                protoInstance.UpdatedAt = instance.UpdatedAt.Format(time.RFC3339)
        }</span>

        // Convert status
        <span class="cov0" title="0">switch instance.Status </span>{
        case types.InstanceStatusPending:<span class="cov0" title="0">
                protoInstance.Status = generated.InstanceStatus_INSTANCE_STATUS_PENDING</span>
        case types.InstanceStatusCreated:<span class="cov0" title="0">
                protoInstance.Status = generated.InstanceStatus_INSTANCE_STATUS_CREATED</span>
        case types.InstanceStatusStarting:<span class="cov0" title="0">
                protoInstance.Status = generated.InstanceStatus_INSTANCE_STATUS_STARTING</span>
        case types.InstanceStatusRunning:<span class="cov0" title="0">
                protoInstance.Status = generated.InstanceStatus_INSTANCE_STATUS_RUNNING</span>
        case types.InstanceStatusStopped:<span class="cov0" title="0">
                protoInstance.Status = generated.InstanceStatus_INSTANCE_STATUS_STOPPED</span>
        case types.InstanceStatusFailed:<span class="cov0" title="0">
                protoInstance.Status = generated.InstanceStatus_INSTANCE_STATUS_FAILED</span>
        case types.InstanceStatusExited:<span class="cov0" title="0">
                protoInstance.Status = generated.InstanceStatus_INSTANCE_STATUS_EXITED</span>
        default:<span class="cov0" title="0">
                protoInstance.Status = generated.InstanceStatus_INSTANCE_STATUS_UNSPECIFIED</span>
        }

        // Convert resources
        <span class="cov0" title="0">if instance.Resources != nil </span><span class="cov0" title="0">{
                protoInstance.Resources = &amp;generated.Resources{
                        Cpu: &amp;generated.ResourceLimit{
                                Request: instance.Resources.CPU.Request,
                                Limit:   instance.Resources.CPU.Limit,
                        },
                        Memory: &amp;generated.ResourceLimit{
                                Request: instance.Resources.Memory.Request,
                                Limit:   instance.Resources.Memory.Limit,
                        },
                }
        }</span>

        <span class="cov0" title="0">return protoInstance</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package client

import (
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/rzbill/rune/pkg/api/generated"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// ServiceClient provides methods for interacting with services on the Rune API server.
type ServiceClient struct {
        client *Client
        logger log.Logger
        svc    generated.ServiceServiceClient
}

// NewServiceClient creates a new service client.
func NewServiceClient(client *Client) *ServiceClient <span class="cov0" title="0">{
        return &amp;ServiceClient{
                client: client,
                logger: client.logger.WithComponent("service-client"),
                svc:    generated.NewServiceServiceClient(client.conn),
        }
}</span>

// CreateService creates a new service on the API server.
func (s *ServiceClient) CreateService(service *types.Service) error <span class="cov0" title="0">{
        s.logger.Debug("Creating service", log.Str("name", service.Name), log.Str("namespace", service.Namespace))

        // Create the gRPC request
        req := &amp;generated.CreateServiceRequest{
                Service: s.serviceToProto(service),
        }

        // Send the request to the API server
        ctx, cancel := s.client.Context()
        defer cancel()

        resp, err := s.svc.CreateService(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create service", log.Err(err), log.Str("name", service.Name))
                return convertGRPCError("create service", err)
        }</span>

        // Check if the API returned an error status
        <span class="cov0" title="0">if resp.Status != nil &amp;&amp; resp.Status.Code != int32(codes.OK) </span><span class="cov0" title="0">{
                err := fmt.Errorf("API error: %s", resp.Status.Message)
                s.logger.Error("Failed to create service", log.Err(err), log.Str("name", service.Name))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetService retrieves a service by name.
func (s *ServiceClient) GetService(namespace, name string) (*types.Service, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting service", log.Str("name", name), log.Str("namespace", namespace))

        // Create the gRPC request
        req := &amp;generated.GetServiceRequest{
                Name:      name,
                Namespace: namespace,
        }

        // Send the request to the API server
        ctx, cancel := s.client.Context()
        defer cancel()

        resp, err := s.svc.GetService(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                statusErr, ok := status.FromError(err)
                if ok &amp;&amp; statusErr.Code() == codes.NotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("service not found: %s/%s", namespace, name)
                }</span>
                <span class="cov0" title="0">s.logger.Error("Failed to get service", log.Err(err), log.Str("name", name))
                return nil, convertGRPCError("get service", err)</span>
        }

        // Check if the API returned an error status
        <span class="cov0" title="0">if resp.Status != nil &amp;&amp; resp.Status.Code != int32(codes.OK) </span><span class="cov0" title="0">{
                err := fmt.Errorf("API error: %s", resp.Status.Message)
                s.logger.Error("Failed to get service", log.Err(err), log.Str("name", name))
                return nil, err
        }</span>

        // Convert the proto message to a service
        <span class="cov0" title="0">service, err := s.protoToService(resp.Service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert service: %w", err)
        }</span>

        <span class="cov0" title="0">return service, nil</span>
}

// UpdateService updates an existing service.
func (s *ServiceClient) UpdateService(service *types.Service) error <span class="cov0" title="0">{
        s.logger.Debug("Updating service", log.Str("name", service.Name), log.Str("namespace", service.Namespace))

        // Create the gRPC request
        req := &amp;generated.UpdateServiceRequest{
                Service: s.serviceToProto(service),
        }

        // Send the request to the API server
        ctx, cancel := s.client.Context()
        defer cancel()

        resp, err := s.svc.UpdateService(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                statusErr, ok := status.FromError(err)
                if ok &amp;&amp; statusErr.Code() == codes.NotFound </span><span class="cov0" title="0">{
                        return fmt.Errorf("service not found: %s/%s", service.Namespace, service.Name)
                }</span>
                <span class="cov0" title="0">s.logger.Error("Failed to update service", log.Err(err), log.Str("name", service.Name))
                return convertGRPCError("update service", err)</span>
        }

        // Check if the API returned an error status
        <span class="cov0" title="0">if resp.Status != nil &amp;&amp; resp.Status.Code != int32(codes.OK) </span><span class="cov0" title="0">{
                err := fmt.Errorf("API error: %s", resp.Status.Message)
                s.logger.Error("Failed to update service", log.Err(err), log.Str("name", service.Name))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteService deletes a service by name.
func (s *ServiceClient) DeleteService(namespace, name string) error <span class="cov0" title="0">{
        s.logger.Debug("Deleting service", log.Str("name", name), log.Str("namespace", namespace))

        // Create the gRPC request
        req := &amp;generated.DeleteServiceRequest{
                Name:      name,
                Namespace: namespace,
        }

        // Send the request to the API server
        ctx, cancel := s.client.Context()
        defer cancel()

        resp, err := s.svc.DeleteService(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                statusErr, ok := status.FromError(err)
                if ok &amp;&amp; statusErr.Code() == codes.NotFound </span><span class="cov0" title="0">{
                        return fmt.Errorf("service not found: %s/%s", namespace, name)
                }</span>
                <span class="cov0" title="0">s.logger.Error("Failed to delete service", log.Err(err), log.Str("name", name))
                return convertGRPCError("delete service", err)</span>
        }

        // Check if the API returned an error status
        <span class="cov0" title="0">if resp.Status != nil &amp;&amp; resp.Status.Code != int32(codes.OK) </span><span class="cov0" title="0">{
                err := fmt.Errorf("API error: %s", resp.Status.Message)
                s.logger.Error("Failed to delete service", log.Err(err), log.Str("name", name))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListServices lists services in a namespace with optional filtering.
func (s *ServiceClient) ListServices(namespace string, labelSelector string, fieldSelector string) ([]*types.Service, error) <span class="cov0" title="0">{
        s.logger.Debug("Listing services",
                log.Str("namespace", namespace),
                log.Str("labelSelector", labelSelector),
                log.Str("fieldSelector", fieldSelector))

        // Create the gRPC request
        req := &amp;generated.ListServicesRequest{
                Namespace:     namespace,
                LabelSelector: make(map[string]string),
                FieldSelector: make(map[string]string),
        }

        // Parse label selector if provided
        if labelSelector != "" </span><span class="cov0" title="0">{
                labels, err := parseSelector(labelSelector)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid label selector: %w", err)
                }</span>
                <span class="cov0" title="0">req.LabelSelector = labels</span>
        }

        // Parse field selector if provided
        <span class="cov0" title="0">if fieldSelector != "" </span><span class="cov0" title="0">{
                fields, err := parseSelector(fieldSelector)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid field selector: %w", err)
                }</span>
                <span class="cov0" title="0">req.FieldSelector = fields</span>
        }

        // Send the request to the API server
        <span class="cov0" title="0">ctx, cancel := s.client.Context()
        defer cancel()

        resp, err := s.svc.ListServices(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to list services", log.Err(err), log.Str("namespace", namespace))
                return nil, convertGRPCError("list services", err)
        }</span>

        // Check if the API returned an error status
        <span class="cov0" title="0">if resp.Status != nil &amp;&amp; resp.Status.Code != int32(codes.OK) </span><span class="cov0" title="0">{
                err := fmt.Errorf("API error: %s", resp.Status.Message)
                s.logger.Error("Failed to list services", log.Err(err), log.Str("namespace", namespace))
                return nil, err
        }</span>

        // Convert the proto messages to services
        <span class="cov0" title="0">services := make([]*types.Service, 0, len(resp.Services))
        for _, protoService := range resp.Services </span><span class="cov0" title="0">{
                service, err := s.protoToService(protoService)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to convert service", log.Err(err))
                        continue</span>
                }
                <span class="cov0" title="0">services = append(services, service)</span>
        }

        <span class="cov0" title="0">return services, nil</span>
}

// Helper function for parsing key=value selectors
func parseSelector(selector string) (map[string]string, error) <span class="cov0" title="0">{
        result := make(map[string]string)
        if selector == "" </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">pairs := strings.Split(selector, ",")
        for _, pair := range pairs </span><span class="cov0" title="0">{
                parts := strings.SplitN(pair, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid selector format, expected key=value: %s", pair)
                }</span>
                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])
                if key == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("empty key in selector: %s", pair)
                }</span>
                <span class="cov0" title="0">if value == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("empty value in selector: %s", pair)
                }</span>
                <span class="cov0" title="0">result[key] = value</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// ScaleService changes the scale of a service.
func (s *ServiceClient) ScaleService(namespace, name string, scale int) error <span class="cov0" title="0">{
        s.logger.Debug("Scaling service", log.Str("name", name), log.Str("namespace", namespace), log.Int("scale", scale))

        // Create the gRPC request
        req := &amp;generated.ScaleServiceRequest{
                Name:      name,
                Namespace: namespace,
                Scale:     int32(scale),
        }

        // Send the request to the API server
        ctx, cancel := s.client.Context()
        defer cancel()

        resp, err := s.svc.ScaleService(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                statusErr, ok := status.FromError(err)
                if ok &amp;&amp; statusErr.Code() == codes.NotFound </span><span class="cov0" title="0">{
                        return fmt.Errorf("service not found: %s/%s", namespace, name)
                }</span>
                <span class="cov0" title="0">s.logger.Error("Failed to scale service", log.Err(err), log.Str("name", name))
                return convertGRPCError("scale service", err)</span>
        }

        // Check if the API returned an error status
        <span class="cov0" title="0">if resp.Status != nil &amp;&amp; resp.Status.Code != int32(codes.OK) </span><span class="cov0" title="0">{
                err := fmt.Errorf("API error: %s", resp.Status.Message)
                s.logger.Error("Failed to scale service", log.Err(err), log.Str("name", name))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper functions for converting between types.Service and generated.Service

// serviceToProto converts a types.Service to a generated.Service proto message.
func (s *ServiceClient) serviceToProto(service *types.Service) *generated.Service <span class="cov0" title="0">{
        if service == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">protoService := &amp;generated.Service{
                Id:        service.ID,
                Name:      service.Name,
                Namespace: service.Namespace,
                Image:     service.Image,
                Command:   service.Command,
                Scale:     int32(service.Scale),
                Runtime:   string(service.Runtime),
        }

        // Format timestamps as RFC3339 strings
        if !service.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                protoService.CreatedAt = service.CreatedAt.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">if !service.UpdatedAt.IsZero() </span><span class="cov0" title="0">{
                protoService.UpdatedAt = service.UpdatedAt.Format(time.RFC3339)
        }</span>

        // Convert args
        <span class="cov0" title="0">if len(service.Args) &gt; 0 </span><span class="cov0" title="0">{
                protoService.Args = make([]string, len(service.Args))
                copy(protoService.Args, service.Args)
        }</span>

        // Convert environment variables
        <span class="cov0" title="0">if len(service.Env) &gt; 0 </span><span class="cov0" title="0">{
                protoService.Env = make(map[string]string)
                for k, v := range service.Env </span><span class="cov0" title="0">{
                        protoService.Env[k] = v
                }</span>
        }

        // Convert ports
        <span class="cov0" title="0">if len(service.Ports) &gt; 0 </span><span class="cov0" title="0">{
                protoService.Ports = make([]*generated.ServicePort, len(service.Ports))
                for i, port := range service.Ports </span><span class="cov0" title="0">{
                        protoService.Ports[i] = &amp;generated.ServicePort{
                                Name:       port.Name,
                                Port:       int32(port.Port),
                                TargetPort: int32(port.TargetPort),
                                Protocol:   port.Protocol,
                        }
                }</span>
        }

        // Convert resources
        <span class="cov0" title="0">if service.Resources != (types.Resources{}) </span><span class="cov0" title="0">{
                protoService.Resources = &amp;generated.Resources{
                        Cpu: &amp;generated.ResourceLimit{
                                Request: service.Resources.CPU.Request,
                                Limit:   service.Resources.CPU.Limit,
                        },
                        Memory: &amp;generated.ResourceLimit{
                                Request: service.Resources.Memory.Request,
                                Limit:   service.Resources.Memory.Limit,
                        },
                }
        }</span>

        // Convert status
        <span class="cov0" title="0">switch service.Status </span>{
        case types.ServiceStatusPending:<span class="cov0" title="0">
                protoService.Status = generated.ServiceStatus_SERVICE_STATUS_PENDING</span>
        case types.ServiceStatusRunning:<span class="cov0" title="0">
                protoService.Status = generated.ServiceStatus_SERVICE_STATUS_RUNNING</span>
        case types.ServiceStatusDeploying:<span class="cov0" title="0">
                protoService.Status = generated.ServiceStatus_SERVICE_STATUS_UPDATING</span>
        case types.ServiceStatusFailed:<span class="cov0" title="0">
                protoService.Status = generated.ServiceStatus_SERVICE_STATUS_FAILED</span>
        default:<span class="cov0" title="0">
                protoService.Status = generated.ServiceStatus_SERVICE_STATUS_UNSPECIFIED</span>
        }

        // Convert health checks
        <span class="cov0" title="0">if service.Health != nil </span><span class="cov0" title="0">{
                protoService.Health = &amp;generated.HealthCheck{}

                if service.Health.Liveness != nil </span><span class="cov0" title="0">{
                        protoService.Health.Liveness = &amp;generated.Probe{
                                InitialDelaySeconds: int32(service.Health.Liveness.InitialDelaySeconds),
                                PeriodSeconds:       int32(service.Health.Liveness.IntervalSeconds),
                                TimeoutSeconds:      int32(service.Health.Liveness.TimeoutSeconds),
                        }

                        switch service.Health.Liveness.Type </span>{
                        case "http":<span class="cov0" title="0">
                                protoService.Health.Liveness.Type = generated.ProbeType_PROBE_TYPE_HTTP
                                protoService.Health.Liveness.Path = service.Health.Liveness.Path
                                protoService.Health.Liveness.Port = int32(service.Health.Liveness.Port)</span>
                        case "tcp":<span class="cov0" title="0">
                                protoService.Health.Liveness.Type = generated.ProbeType_PROBE_TYPE_TCP
                                protoService.Health.Liveness.Port = int32(service.Health.Liveness.Port)</span>
                        case "command":<span class="cov0" title="0">
                                protoService.Health.Liveness.Type = generated.ProbeType_PROBE_TYPE_COMMAND
                                protoService.Health.Liveness.Command = service.Health.Liveness.Command</span>
                        }
                }

                <span class="cov0" title="0">if service.Health.Readiness != nil </span><span class="cov0" title="0">{
                        protoService.Health.Readiness = &amp;generated.Probe{
                                InitialDelaySeconds: int32(service.Health.Readiness.InitialDelaySeconds),
                                PeriodSeconds:       int32(service.Health.Readiness.IntervalSeconds),
                                TimeoutSeconds:      int32(service.Health.Readiness.TimeoutSeconds),
                        }

                        switch service.Health.Readiness.Type </span>{
                        case "http":<span class="cov0" title="0">
                                protoService.Health.Readiness.Type = generated.ProbeType_PROBE_TYPE_HTTP
                                protoService.Health.Readiness.Path = service.Health.Readiness.Path
                                protoService.Health.Readiness.Port = int32(service.Health.Readiness.Port)</span>
                        case "tcp":<span class="cov0" title="0">
                                protoService.Health.Readiness.Type = generated.ProbeType_PROBE_TYPE_TCP
                                protoService.Health.Readiness.Port = int32(service.Health.Readiness.Port)</span>
                        case "command":<span class="cov0" title="0">
                                protoService.Health.Readiness.Type = generated.ProbeType_PROBE_TYPE_COMMAND
                                protoService.Health.Readiness.Command = service.Health.Readiness.Command</span>
                        }
                }
        }

        <span class="cov0" title="0">return protoService</span>
}

// protoToService converts a generated.Service proto message to a types.Service.
func (s *ServiceClient) protoToService(proto *generated.Service) (*types.Service, error) <span class="cov0" title="0">{
        if proto == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("proto service is nil")
        }</span>

        // Create an initial service with basic fields
        <span class="cov0" title="0">service := &amp;types.Service{
                ID:        proto.Id,
                Name:      proto.Name,
                Namespace: proto.Namespace,
                Image:     proto.Image,
                Command:   proto.Command,
                Scale:     int(proto.Scale),
                Runtime:   types.RuntimeType(proto.Runtime),
        }

        createdAt, err := parseTimestamp(proto.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to parse created_at timestamp",
                        log.Str("service", proto.Name),
                        log.Str("timestamp", proto.CreatedAt),
                        log.Err(err))
        }</span>
        <span class="cov0" title="0">service.CreatedAt = *createdAt

        updatedAt, err := parseTimestamp(proto.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to parse updated_at timestamp",
                        log.Str("service", proto.Name),
                        log.Str("timestamp", proto.UpdatedAt),
                        log.Err(err))
        }</span>
        <span class="cov0" title="0">service.UpdatedAt = *updatedAt

        // Convert args
        if len(proto.Args) &gt; 0 </span><span class="cov0" title="0">{
                service.Args = make([]string, len(proto.Args))
                copy(service.Args, proto.Args)
        }</span>

        // Convert environment variables
        <span class="cov0" title="0">if len(proto.Env) &gt; 0 </span><span class="cov0" title="0">{
                service.Env = make(map[string]string)
                for k, v := range proto.Env </span><span class="cov0" title="0">{
                        service.Env[k] = v
                }</span>
        }

        // Convert ports
        <span class="cov0" title="0">if len(proto.Ports) &gt; 0 </span><span class="cov0" title="0">{
                service.Ports = make([]types.ServicePort, len(proto.Ports))
                for i, port := range proto.Ports </span><span class="cov0" title="0">{
                        service.Ports[i] = types.ServicePort{
                                Name:       port.Name,
                                Port:       int(port.Port),
                                TargetPort: int(port.TargetPort),
                                Protocol:   port.Protocol,
                        }
                }</span>
        }

        // Convert resources
        <span class="cov0" title="0">if proto.Resources != nil </span><span class="cov0" title="0">{
                if proto.Resources.Cpu != nil </span><span class="cov0" title="0">{
                        service.Resources.CPU = types.ResourceLimit{
                                Request: proto.Resources.Cpu.Request,
                                Limit:   proto.Resources.Cpu.Limit,
                        }
                }</span>
                <span class="cov0" title="0">if proto.Resources.Memory != nil </span><span class="cov0" title="0">{
                        service.Resources.Memory = types.ResourceLimit{
                                Request: proto.Resources.Memory.Request,
                                Limit:   proto.Resources.Memory.Limit,
                        }
                }</span>
        }

        // Convert status
        <span class="cov0" title="0">switch proto.Status </span>{
        case generated.ServiceStatus_SERVICE_STATUS_PENDING:<span class="cov0" title="0">
                service.Status = types.ServiceStatusPending</span>
        case generated.ServiceStatus_SERVICE_STATUS_RUNNING:<span class="cov0" title="0">
                service.Status = types.ServiceStatusRunning</span>
        case generated.ServiceStatus_SERVICE_STATUS_UPDATING:<span class="cov0" title="0">
                service.Status = types.ServiceStatusDeploying</span>
        case generated.ServiceStatus_SERVICE_STATUS_FAILED:<span class="cov0" title="0">
                service.Status = types.ServiceStatusFailed</span>
        default:<span class="cov0" title="0">
                service.Status = types.ServiceStatusPending</span>
        }

        // Convert health check
        <span class="cov0" title="0">if proto.Health != nil </span><span class="cov0" title="0">{
                service.Health = &amp;types.HealthCheck{}

                if proto.Health.Liveness != nil </span><span class="cov0" title="0">{
                        service.Health.Liveness = &amp;types.Probe{
                                InitialDelaySeconds: int(proto.Health.Liveness.InitialDelaySeconds),
                                IntervalSeconds:     int(proto.Health.Liveness.PeriodSeconds),
                                TimeoutSeconds:      int(proto.Health.Liveness.TimeoutSeconds),
                        }

                        switch proto.Health.Liveness.Type </span>{
                        case generated.ProbeType_PROBE_TYPE_HTTP:<span class="cov0" title="0">
                                service.Health.Liveness.Type = "http"
                                service.Health.Liveness.Path = proto.Health.Liveness.Path
                                service.Health.Liveness.Port = int(proto.Health.Liveness.Port)</span>
                        case generated.ProbeType_PROBE_TYPE_TCP:<span class="cov0" title="0">
                                service.Health.Liveness.Type = "tcp"
                                service.Health.Liveness.Port = int(proto.Health.Liveness.Port)</span>
                        case generated.ProbeType_PROBE_TYPE_COMMAND:<span class="cov0" title="0">
                                service.Health.Liveness.Type = "command"
                                service.Health.Liveness.Command = proto.Health.Liveness.Command</span>
                        }
                }

                <span class="cov0" title="0">if proto.Health.Readiness != nil </span><span class="cov0" title="0">{
                        service.Health.Readiness = &amp;types.Probe{
                                InitialDelaySeconds: int(proto.Health.Readiness.InitialDelaySeconds),
                                IntervalSeconds:     int(proto.Health.Readiness.PeriodSeconds),
                                TimeoutSeconds:      int(proto.Health.Readiness.TimeoutSeconds),
                        }

                        switch proto.Health.Readiness.Type </span>{
                        case generated.ProbeType_PROBE_TYPE_HTTP:<span class="cov0" title="0">
                                service.Health.Readiness.Type = "http"
                                service.Health.Readiness.Path = proto.Health.Readiness.Path
                                service.Health.Readiness.Port = int(proto.Health.Readiness.Port)</span>
                        case generated.ProbeType_PROBE_TYPE_TCP:<span class="cov0" title="0">
                                service.Health.Readiness.Type = "tcp"
                                service.Health.Readiness.Port = int(proto.Health.Readiness.Port)</span>
                        case generated.ProbeType_PROBE_TYPE_COMMAND:<span class="cov0" title="0">
                                service.Health.Readiness.Type = "command"
                                service.Health.Readiness.Command = proto.Health.Readiness.Command</span>
                        }
                }
        }

        <span class="cov0" title="0">return service, nil</span>
}

// convertGRPCError converts a gRPC error to a more user-friendly error message.
func convertGRPCError(operation string, err error) error <span class="cov0" title="0">{
        statusErr, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                // Not a gRPC error
                return fmt.Errorf("failed to %s: %w", operation, err)
        }</span>

        <span class="cov0" title="0">switch statusErr.Code() </span>{
        case codes.NotFound:<span class="cov0" title="0">
                return fmt.Errorf("resource not found: %s", statusErr.Message())</span>
        case codes.AlreadyExists:<span class="cov0" title="0">
                return fmt.Errorf("resource already exists: %s", statusErr.Message())</span>
        case codes.InvalidArgument:<span class="cov0" title="0">
                return fmt.Errorf("invalid argument: %s", statusErr.Message())</span>
        case codes.FailedPrecondition:<span class="cov0" title="0">
                return fmt.Errorf("failed precondition: %s", statusErr.Message())</span>
        case codes.PermissionDenied:<span class="cov0" title="0">
                return fmt.Errorf("permission denied: %s", statusErr.Message())</span>
        case codes.Unauthenticated:<span class="cov0" title="0">
                return fmt.Errorf("unauthenticated: %s", statusErr.Message())</span>
        case codes.ResourceExhausted:<span class="cov0" title="0">
                return fmt.Errorf("resource exhausted: %s", statusErr.Message())</span>
        case codes.Unavailable:<span class="cov0" title="0">
                return fmt.Errorf("service unavailable: %s", statusErr.Message())</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("failed to %s: %s (code %d)", operation, statusErr.Message(), statusErr.Code())</span>
        }
}

// WatchEvent represents a service change event
type WatchEvent struct {
        Service   *types.Service
        EventType string // "ADDED", "MODIFIED", "DELETED"
        Error     error
}

// WatchServices watches services for changes and returns a channel of events.
func (s *ServiceClient) WatchServices(namespace string, labelSelector string, fieldSelector string) (&lt;-chan WatchEvent, error) <span class="cov0" title="0">{
        s.logger.Debug("Watching services",
                log.Str("namespace", namespace),
                log.Str("labelSelector", labelSelector),
                log.Str("fieldSelector", fieldSelector))

        // Create the gRPC request
        req := &amp;generated.WatchServicesRequest{
                Namespace:     namespace,
                LabelSelector: make(map[string]string),
                FieldSelector: make(map[string]string),
        }

        // Parse label selector if provided
        if labelSelector != "" </span><span class="cov0" title="0">{
                labels, err := parseSelector(labelSelector)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid label selector: %w", err)
                }</span>
                <span class="cov0" title="0">req.LabelSelector = labels</span>
        }

        // Parse field selector if provided
        <span class="cov0" title="0">if fieldSelector != "" </span><span class="cov0" title="0">{
                fields, err := parseSelector(fieldSelector)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid field selector: %w", err)
                }</span>
                <span class="cov0" title="0">req.FieldSelector = fields</span>
        }

        // Create context with client timeout
        <span class="cov0" title="0">ctx, cancel := s.client.Context()

        // Establish the streaming connection
        stream, err := s.svc.WatchServices(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                s.logger.Error("Failed to establish watch connection", log.Err(err))
                return nil, convertGRPCError("watch services", err)
        }</span>

        // Create channel for watch events
        <span class="cov0" title="0">eventCh := make(chan WatchEvent)

        // Start goroutine to receive watch events and send them to the channel
        go func() </span><span class="cov0" title="0">{
                defer cancel()
                defer close(eventCh)

                for </span><span class="cov0" title="0">{
                        // Check if context is cancelled
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                s.logger.Debug("Watch context cancelled")
                                return</span>
                        default:<span class="cov0" title="0"></span>
                                // Continue processing
                        }

                        // Receive event from server
                        <span class="cov0" title="0">resp, err := stream.Recv()
                        if err == io.EOF </span><span class="cov0" title="0">{
                                s.logger.Debug("Watch stream closed by server")
                                return
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Error receiving watch event", log.Err(err))
                                eventCh &lt;- WatchEvent{
                                        Error: fmt.Errorf("watch error: %w", err),
                                }
                                return
                        }</span>

                        // Check if the API returned an error status
                        <span class="cov0" title="0">if resp.Status != nil &amp;&amp; resp.Status.Code != int32(codes.OK) </span><span class="cov0" title="0">{
                                err := fmt.Errorf("API error: %s", resp.Status.Message)
                                s.logger.Error("Watch API error", log.Err(err))
                                eventCh &lt;- WatchEvent{
                                        Error: err,
                                }
                                return
                        }</span>

                        // Convert proto event type to string
                        <span class="cov0" title="0">var eventType string
                        switch resp.EventType </span>{
                        case generated.EventType_EVENT_TYPE_ADDED:<span class="cov0" title="0">
                                eventType = "ADDED"</span>
                        case generated.EventType_EVENT_TYPE_MODIFIED:<span class="cov0" title="0">
                                eventType = "MODIFIED"</span>
                        case generated.EventType_EVENT_TYPE_DELETED:<span class="cov0" title="0">
                                eventType = "DELETED"</span>
                        default:<span class="cov0" title="0">
                                eventType = "UNKNOWN"</span>
                        }

                        // Convert the proto service to a type service
                        <span class="cov0" title="0">service, err := s.protoToService(resp.Service)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to convert service", log.Err(err))
                                eventCh &lt;- WatchEvent{
                                        Error: fmt.Errorf("failed to convert service: %w", err),
                                }
                                continue</span>
                        }

                        // Send the event to the channel
                        <span class="cov0" title="0">eventCh &lt;- WatchEvent{
                                Service:   service,
                                EventType: eventType,
                                Error:     nil,
                        }</span>
                }
        }()

        <span class="cov0" title="0">return eventCh, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v5.29.3
// source: pkg/api/proto/common.proto

package generated

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ResourceType represents different resource types in the system
type ResourceType int32

const (
        ResourceType_RESOURCE_TYPE_UNSPECIFIED ResourceType = 0
        ResourceType_RESOURCE_TYPE_SERVICE     ResourceType = 1
        ResourceType_RESOURCE_TYPE_INSTANCE    ResourceType = 2
        ResourceType_RESOURCE_TYPE_NODE        ResourceType = 3
        ResourceType_RESOURCE_TYPE_SECRET      ResourceType = 4
        ResourceType_RESOURCE_TYPE_CONFIG      ResourceType = 5
)

// Enum value maps for ResourceType.
var (
        ResourceType_name = map[int32]string{
                0: "RESOURCE_TYPE_UNSPECIFIED",
                1: "RESOURCE_TYPE_SERVICE",
                2: "RESOURCE_TYPE_INSTANCE",
                3: "RESOURCE_TYPE_NODE",
                4: "RESOURCE_TYPE_SECRET",
                5: "RESOURCE_TYPE_CONFIG",
        }
        ResourceType_value = map[string]int32{
                "RESOURCE_TYPE_UNSPECIFIED": 0,
                "RESOURCE_TYPE_SERVICE":     1,
                "RESOURCE_TYPE_INSTANCE":    2,
                "RESOURCE_TYPE_NODE":        3,
                "RESOURCE_TYPE_SECRET":      4,
                "RESOURCE_TYPE_CONFIG":      5,
        }
)

func (x ResourceType) Enum() *ResourceType <span class="cov0" title="0">{
        p := new(ResourceType)
        *p = x
        return p
}</span>

func (x ResourceType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (ResourceType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_enumTypes[0].Descriptor()
}</span>

func (ResourceType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_pkg_api_proto_common_proto_enumTypes[0]
}</span>

func (x ResourceType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use ResourceType.Descriptor instead.
func (ResourceType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{0}
}</span>

// EventType represents the type of event in a watch stream
type EventType int32

const (
        EventType_EVENT_TYPE_UNSPECIFIED EventType = 0
        EventType_EVENT_TYPE_ADDED       EventType = 1 // Resource was added
        EventType_EVENT_TYPE_MODIFIED    EventType = 2 // Resource was modified
        EventType_EVENT_TYPE_DELETED     EventType = 3 // Resource was deleted
)

// Enum value maps for EventType.
var (
        EventType_name = map[int32]string{
                0: "EVENT_TYPE_UNSPECIFIED",
                1: "EVENT_TYPE_ADDED",
                2: "EVENT_TYPE_MODIFIED",
                3: "EVENT_TYPE_DELETED",
        }
        EventType_value = map[string]int32{
                "EVENT_TYPE_UNSPECIFIED": 0,
                "EVENT_TYPE_ADDED":       1,
                "EVENT_TYPE_MODIFIED":    2,
                "EVENT_TYPE_DELETED":     3,
        }
)

func (x EventType) Enum() *EventType <span class="cov0" title="0">{
        p := new(EventType)
        *p = x
        return p
}</span>

func (x EventType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (EventType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_enumTypes[1].Descriptor()
}</span>

func (EventType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_pkg_api_proto_common_proto_enumTypes[1]
}</span>

func (x EventType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use EventType.Descriptor instead.
func (EventType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{1}
}</span>

// RestartPolicy defines the restart policy for a service.
type RestartPolicy int32

const (
        RestartPolicy_RESTART_POLICY_UNSPECIFIED RestartPolicy = 0
        RestartPolicy_RESTART_POLICY_ALWAYS      RestartPolicy = 1
        RestartPolicy_RESTART_POLICY_ON_FAILURE  RestartPolicy = 2
        RestartPolicy_RESTART_POLICY_NEVER       RestartPolicy = 3
)

// Enum value maps for RestartPolicy.
var (
        RestartPolicy_name = map[int32]string{
                0: "RESTART_POLICY_UNSPECIFIED",
                1: "RESTART_POLICY_ALWAYS",
                2: "RESTART_POLICY_ON_FAILURE",
                3: "RESTART_POLICY_NEVER",
        }
        RestartPolicy_value = map[string]int32{
                "RESTART_POLICY_UNSPECIFIED": 0,
                "RESTART_POLICY_ALWAYS":      1,
                "RESTART_POLICY_ON_FAILURE":  2,
                "RESTART_POLICY_NEVER":       3,
        }
)

func (x RestartPolicy) Enum() *RestartPolicy <span class="cov0" title="0">{
        p := new(RestartPolicy)
        *p = x
        return p
}</span>

func (x RestartPolicy) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (RestartPolicy) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_enumTypes[2].Descriptor()
}</span>

func (RestartPolicy) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_pkg_api_proto_common_proto_enumTypes[2]
}</span>

func (x RestartPolicy) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use RestartPolicy.Descriptor instead.
func (RestartPolicy) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{2}
}</span>

// ProbeType defines the type of health check
type ProbeType int32

const (
        ProbeType_PROBE_TYPE_UNSPECIFIED ProbeType = 0
        ProbeType_PROBE_TYPE_HTTP        ProbeType = 1
        ProbeType_PROBE_TYPE_TCP         ProbeType = 2
        ProbeType_PROBE_TYPE_COMMAND     ProbeType = 3
)

// Enum value maps for ProbeType.
var (
        ProbeType_name = map[int32]string{
                0: "PROBE_TYPE_UNSPECIFIED",
                1: "PROBE_TYPE_HTTP",
                2: "PROBE_TYPE_TCP",
                3: "PROBE_TYPE_COMMAND",
        }
        ProbeType_value = map[string]int32{
                "PROBE_TYPE_UNSPECIFIED": 0,
                "PROBE_TYPE_HTTP":        1,
                "PROBE_TYPE_TCP":         2,
                "PROBE_TYPE_COMMAND":     3,
        }
)

func (x ProbeType) Enum() *ProbeType <span class="cov0" title="0">{
        p := new(ProbeType)
        *p = x
        return p
}</span>

func (x ProbeType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (ProbeType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_enumTypes[3].Descriptor()
}</span>

func (ProbeType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_pkg_api_proto_common_proto_enumTypes[3]
}</span>

func (x ProbeType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use ProbeType.Descriptor instead.
func (ProbeType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{3}
}</span>

// Common status message returned by many operations
type Status struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Status code
        Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
        // Status message
        Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
        // Details about the status
        Details []string `protobuf:"bytes,3,rep,name=details,proto3" json:"details,omitempty"`
}

func (x *Status) Reset() <span class="cov0" title="0">{
        *x = Status{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_common_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Status) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Status) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Status) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_common_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Status.ProtoReflect.Descriptor instead.
func (*Status) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Status) GetCode() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Status) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Status) GetDetails() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Details
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Empty request or response
type Empty struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *Empty) Reset() <span class="cov0" title="0">{
        *x = Empty{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_common_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Empty) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Empty) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Empty) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_common_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Empty.ProtoReflect.Descriptor instead.
func (*Empty) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{1}
}</span>

// Common paging parameters for list operations
type PagingParams struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Maximum number of items to return
        Limit int32 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
        // Offset to start from
        Offset int32 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
        // Token for continuation (if limit was applied)
        ContinuationToken string `protobuf:"bytes,3,opt,name=continuation_token,json=continuationToken,proto3" json:"continuation_token,omitempty"`
}

func (x *PagingParams) Reset() <span class="cov0" title="0">{
        *x = PagingParams{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_common_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *PagingParams) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PagingParams) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PagingParams) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_common_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PagingParams.ProtoReflect.Descriptor instead.
func (*PagingParams) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{2}
}</span>

func (x *PagingParams) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PagingParams) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PagingParams) GetContinuationToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ContinuationToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ResourceLimit defines request and limit for a resource.
type ResourceLimit struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Requested resources (guaranteed)
        Request string `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty"`
        // Maximum resources (limit)
        Limit string `protobuf:"bytes,2,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (x *ResourceLimit) Reset() <span class="cov0" title="0">{
        *x = ResourceLimit{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_common_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ResourceLimit) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ResourceLimit) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ResourceLimit) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_common_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ResourceLimit.ProtoReflect.Descriptor instead.
func (*ResourceLimit) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{3}
}</span>

func (x *ResourceLimit) GetRequest() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Request
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ResourceLimit) GetLimit() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Resources represents resource requirements for a service instance.
type Resources struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // CPU request and limit
        Cpu *ResourceLimit `protobuf:"bytes,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
        // Memory request and limit
        Memory *ResourceLimit `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory,omitempty"`
}

func (x *Resources) Reset() <span class="cov0" title="0">{
        *x = Resources{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_common_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Resources) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Resources) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Resources) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_common_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Resources.ProtoReflect.Descriptor instead.
func (*Resources) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{4}
}</span>

func (x *Resources) GetCpu() *ResourceLimit <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Cpu
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Resources) GetMemory() *ResourceLimit <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Memory
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ProcessSpec represents process-specific configuration for a service.
type ProcessSpec struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Command to run in the container
        Command string `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
        // Arguments to the command
        Args []string `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
        // Working directory for the command
        WorkingDir string `protobuf:"bytes,3,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
        // Security context for the process
        SecurityContext *ProcessSecurityContext `protobuf:"bytes,4,opt,name=security_context,json=securityContext,proto3" json:"security_context,omitempty"`
}

func (x *ProcessSpec) Reset() <span class="cov0" title="0">{
        *x = ProcessSpec{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_common_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ProcessSpec) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProcessSpec) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProcessSpec) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_common_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProcessSpec.ProtoReflect.Descriptor instead.
func (*ProcessSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{5}
}</span>

func (x *ProcessSpec) GetCommand() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Command
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessSpec) GetArgs() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Args
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ProcessSpec) GetWorkingDir() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.WorkingDir
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessSpec) GetSecurityContext() *ProcessSecurityContext <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SecurityContext
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ProcessSecurityContext defines security settings for a process.
type ProcessSecurityContext struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // User to run as
        User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        // Group to run as
        Group string `protobuf:"bytes,2,opt,name=group,proto3" json:"group,omitempty"`
        // Run with read-only filesystem
        ReadOnlyFs bool `protobuf:"varint,3,opt,name=read_only_fs,json=readOnlyFs,proto3" json:"read_only_fs,omitempty"`
        // Linux capabilities to add
        Capabilities []string `protobuf:"bytes,4,rep,name=capabilities,proto3" json:"capabilities,omitempty"`
        // Allowed syscalls (seccomp)
        AllowedSyscalls []string `protobuf:"bytes,5,rep,name=allowed_syscalls,json=allowedSyscalls,proto3" json:"allowed_syscalls,omitempty"`
        // Denied syscalls (seccomp)
        DeniedSyscalls []string `protobuf:"bytes,6,rep,name=denied_syscalls,json=deniedSyscalls,proto3" json:"denied_syscalls,omitempty"`
}

func (x *ProcessSecurityContext) Reset() <span class="cov0" title="0">{
        *x = ProcessSecurityContext{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_common_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ProcessSecurityContext) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProcessSecurityContext) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProcessSecurityContext) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_common_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProcessSecurityContext.ProtoReflect.Descriptor instead.
func (*ProcessSecurityContext) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{6}
}</span>

func (x *ProcessSecurityContext) GetUser() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessSecurityContext) GetGroup() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Group
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessSecurityContext) GetReadOnlyFs() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadOnlyFs
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ProcessSecurityContext) GetCapabilities() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Capabilities
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ProcessSecurityContext) GetAllowedSyscalls() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AllowedSyscalls
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ProcessSecurityContext) GetDeniedSyscalls() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DeniedSyscalls
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ServicePort represents a port exposed by a service.
type ServicePort struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name for this port
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Port number
        Port int32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
        // Target port (if different from port)
        TargetPort int32 `protobuf:"varint,3,opt,name=target_port,json=targetPort,proto3" json:"target_port,omitempty"`
        // Protocol (default: TCP)
        Protocol string `protobuf:"bytes,4,opt,name=protocol,proto3" json:"protocol,omitempty"`
}

func (x *ServicePort) Reset() <span class="cov0" title="0">{
        *x = ServicePort{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_common_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ServicePort) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ServicePort) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ServicePort) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_common_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ServicePort.ProtoReflect.Descriptor instead.
func (*ServicePort) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{7}
}</span>

func (x *ServicePort) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ServicePort) GetPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Port
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ServicePort) GetTargetPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TargetPort
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ServicePort) GetProtocol() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Protocol
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Probe represents a health check probe configuration.
type Probe struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Type of probe
        Type ProbeType `protobuf:"varint,1,opt,name=type,proto3,enum=rune.api.ProbeType" json:"type,omitempty"`
        // Path for HTTP probes
        Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
        // Port to probe
        Port int32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
        // Command to execute for command probes
        Command []string `protobuf:"bytes,4,rep,name=command,proto3" json:"command,omitempty"`
        // Initial delay before starting checks
        InitialDelaySeconds int32 `protobuf:"varint,5,opt,name=initial_delay_seconds,json=initialDelaySeconds,proto3" json:"initial_delay_seconds,omitempty"`
        // How often to perform the check
        PeriodSeconds int32 `protobuf:"varint,6,opt,name=period_seconds,json=periodSeconds,proto3" json:"period_seconds,omitempty"`
        // Timeout for the check
        TimeoutSeconds int32 `protobuf:"varint,7,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
        // How many consecutive successes are needed to be considered healthy
        SuccessThreshold int32 `protobuf:"varint,8,opt,name=success_threshold,json=successThreshold,proto3" json:"success_threshold,omitempty"`
        // How many consecutive failures are needed to be considered unhealthy
        FailureThreshold int32 `protobuf:"varint,9,opt,name=failure_threshold,json=failureThreshold,proto3" json:"failure_threshold,omitempty"`
}

func (x *Probe) Reset() <span class="cov0" title="0">{
        *x = Probe{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_common_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Probe) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Probe) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Probe) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_common_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Probe.ProtoReflect.Descriptor instead.
func (*Probe) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{8}
}</span>

func (x *Probe) GetType() ProbeType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ProbeType_PROBE_TYPE_UNSPECIFIED</span>
}

func (x *Probe) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Probe) GetPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Port
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Probe) GetCommand() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Command
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Probe) GetInitialDelaySeconds() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.InitialDelaySeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Probe) GetPeriodSeconds() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PeriodSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Probe) GetTimeoutSeconds() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TimeoutSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Probe) GetSuccessThreshold() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SuccessThreshold
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Probe) GetFailureThreshold() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FailureThreshold
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// HealthCheck represents health check configuration for a service.
type HealthCheck struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Liveness probe checks if the instance is running
        Liveness *Probe `protobuf:"bytes,1,opt,name=liveness,proto3" json:"liveness,omitempty"`
        // Readiness probe checks if the instance is ready to receive traffic
        Readiness *Probe `protobuf:"bytes,2,opt,name=readiness,proto3" json:"readiness,omitempty"`
}

func (x *HealthCheck) Reset() <span class="cov0" title="0">{
        *x = HealthCheck{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_common_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *HealthCheck) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HealthCheck) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HealthCheck) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_common_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HealthCheck.ProtoReflect.Descriptor instead.
func (*HealthCheck) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_common_proto_rawDescGZIP(), []int{9}
}</span>

func (x *HealthCheck) GetLiveness() *Probe <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Liveness
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *HealthCheck) GetReadiness() *Probe <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Readiness
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_pkg_api_proto_common_proto protoreflect.FileDescriptor

var file_pkg_api_proto_common_proto_rawDesc = []byte{
        0x0a, 0x1a, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f,
        0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08, 0x72, 0x75,
        0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x22, 0x50, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
        0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04,
        0x63, 0x6f, 0x64, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x18,
        0x0a, 0x07, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52,
        0x07, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x22, 0x07, 0x0a, 0x05, 0x45, 0x6d, 0x70, 0x74,
        0x79, 0x22, 0x6b, 0x0a, 0x0c, 0x50, 0x61, 0x67, 0x69, 0x6e, 0x67, 0x50, 0x61, 0x72, 0x61, 0x6d,
        0x73, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05,
        0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65,
        0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x12,
        0x2d, 0x0a, 0x12, 0x63, 0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
        0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x11, 0x63, 0x6f, 0x6e,
        0x74, 0x69, 0x6e, 0x75, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x3f,
        0x0a, 0x0d, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12,
        0x18, 0x0a, 0x07, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x07, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d,
        0x69, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x22,
        0x67, 0x0a, 0x09, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x12, 0x29, 0x0a, 0x03,
        0x63, 0x70, 0x75, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x72, 0x75, 0x6e, 0x65,
        0x2e, 0x61, 0x70, 0x69, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x4c, 0x69, 0x6d,
        0x69, 0x74, 0x52, 0x03, 0x63, 0x70, 0x75, 0x12, 0x2f, 0x0a, 0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72,
        0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61,
        0x70, 0x69, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74,
        0x52, 0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x22, 0xa9, 0x01, 0x0a, 0x0b, 0x50, 0x72, 0x6f,
        0x63, 0x65, 0x73, 0x73, 0x53, 0x70, 0x65, 0x63, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d,
        0x61, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61,
        0x6e, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x61, 0x72, 0x67, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09,
        0x52, 0x04, 0x61, 0x72, 0x67, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x77, 0x6f, 0x72, 0x6b, 0x69, 0x6e,
        0x67, 0x5f, 0x64, 0x69, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x77, 0x6f, 0x72,
        0x6b, 0x69, 0x6e, 0x67, 0x44, 0x69, 0x72, 0x12, 0x4b, 0x0a, 0x10, 0x73, 0x65, 0x63, 0x75, 0x72,
        0x69, 0x74, 0x79, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x20, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x50, 0x72, 0x6f,
        0x63, 0x65, 0x73, 0x73, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x43, 0x6f, 0x6e, 0x74,
        0x65, 0x78, 0x74, 0x52, 0x0f, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x43, 0x6f, 0x6e,
        0x74, 0x65, 0x78, 0x74, 0x22, 0xdc, 0x01, 0x0a, 0x16, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73,
        0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x12,
        0x12, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75,
        0x73, 0x65, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x20, 0x0a, 0x0c, 0x72, 0x65, 0x61,
        0x64, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x5f, 0x66, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52,
        0x0a, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x46, 0x73, 0x12, 0x22, 0x0a, 0x0c, 0x63,
        0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28,
        0x09, 0x52, 0x0c, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12,
        0x29, 0x0a, 0x10, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x5f, 0x73, 0x79, 0x73, 0x63, 0x61,
        0x6c, 0x6c, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0f, 0x61, 0x6c, 0x6c, 0x6f, 0x77,
        0x65, 0x64, 0x53, 0x79, 0x73, 0x63, 0x61, 0x6c, 0x6c, 0x73, 0x12, 0x27, 0x0a, 0x0f, 0x64, 0x65,
        0x6e, 0x69, 0x65, 0x64, 0x5f, 0x73, 0x79, 0x73, 0x63, 0x61, 0x6c, 0x6c, 0x73, 0x18, 0x06, 0x20,
        0x03, 0x28, 0x09, 0x52, 0x0e, 0x64, 0x65, 0x6e, 0x69, 0x65, 0x64, 0x53, 0x79, 0x73, 0x63, 0x61,
        0x6c, 0x6c, 0x73, 0x22, 0x72, 0x0a, 0x0b, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x50, 0x6f,
        0x72, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x61,
        0x72, 0x67, 0x65, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x0a, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x22, 0xd0, 0x02, 0x0a, 0x05, 0x50, 0x72, 0x6f, 0x62,
        0x65, 0x12, 0x27, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32,
        0x13, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x50, 0x72, 0x6f, 0x62, 0x65,
        0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61,
        0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x70, 0x61, 0x74, 0x68, 0x12, 0x12,
        0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x70, 0x6f,
        0x72, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x04, 0x20,
        0x03, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x12, 0x32, 0x0a, 0x15,
        0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x5f, 0x73, 0x65,
        0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x13, 0x69, 0x6e, 0x69,
        0x74, 0x69, 0x61, 0x6c, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73,
        0x12, 0x25, 0x0a, 0x0e, 0x70, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e,
        0x64, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0d, 0x70, 0x65, 0x72, 0x69, 0x6f, 0x64,
        0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x12, 0x27, 0x0a, 0x0f, 0x74, 0x69, 0x6d, 0x65, 0x6f,
        0x75, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05,
        0x52, 0x0e, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73,
        0x12, 0x2b, 0x0a, 0x11, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x65,
        0x73, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x05, 0x52, 0x10, 0x73, 0x75, 0x63,
        0x63, 0x65, 0x73, 0x73, 0x54, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x12, 0x2b, 0x0a,
        0x11, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f,
        0x6c, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x05, 0x52, 0x10, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72,
        0x65, 0x54, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x22, 0x69, 0x0a, 0x0b, 0x48, 0x65,
        0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x2b, 0x0a, 0x08, 0x6c, 0x69, 0x76,
        0x65, 0x6e, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x72, 0x75,
        0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x50, 0x72, 0x6f, 0x62, 0x65, 0x52, 0x08, 0x6c, 0x69,
        0x76, 0x65, 0x6e, 0x65, 0x73, 0x73, 0x12, 0x2d, 0x0a, 0x09, 0x72, 0x65, 0x61, 0x64, 0x69, 0x6e,
        0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x72, 0x75, 0x6e, 0x65,
        0x2e, 0x61, 0x70, 0x69, 0x2e, 0x50, 0x72, 0x6f, 0x62, 0x65, 0x52, 0x09, 0x72, 0x65, 0x61, 0x64,
        0x69, 0x6e, 0x65, 0x73, 0x73, 0x2a, 0xb0, 0x01, 0x0a, 0x0c, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72,
        0x63, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1d, 0x0a, 0x19, 0x52, 0x45, 0x53, 0x4f, 0x55, 0x52,
        0x43, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46,
        0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x19, 0x0a, 0x15, 0x52, 0x45, 0x53, 0x4f, 0x55, 0x52, 0x43,
        0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x10, 0x01,
        0x12, 0x1a, 0x0a, 0x16, 0x52, 0x45, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x5f, 0x54, 0x59, 0x50,
        0x45, 0x5f, 0x49, 0x4e, 0x53, 0x54, 0x41, 0x4e, 0x43, 0x45, 0x10, 0x02, 0x12, 0x16, 0x0a, 0x12,
        0x52, 0x45, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4e, 0x4f,
        0x44, 0x45, 0x10, 0x03, 0x12, 0x18, 0x0a, 0x14, 0x52, 0x45, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45,
        0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x45, 0x43, 0x52, 0x45, 0x54, 0x10, 0x04, 0x12, 0x18,
        0x0a, 0x14, 0x52, 0x45, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
        0x43, 0x4f, 0x4e, 0x46, 0x49, 0x47, 0x10, 0x05, 0x2a, 0x6e, 0x0a, 0x09, 0x45, 0x76, 0x65, 0x6e,
        0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1a, 0x0a, 0x16, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x54,
        0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10,
        0x00, 0x12, 0x14, 0x0a, 0x10, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
        0x41, 0x44, 0x44, 0x45, 0x44, 0x10, 0x01, 0x12, 0x17, 0x0a, 0x13, 0x45, 0x56, 0x45, 0x4e, 0x54,
        0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4d, 0x4f, 0x44, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x02,
        0x12, 0x16, 0x0a, 0x12, 0x45, 0x56, 0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x44,
        0x45, 0x4c, 0x45, 0x54, 0x45, 0x44, 0x10, 0x03, 0x2a, 0x83, 0x01, 0x0a, 0x0d, 0x52, 0x65, 0x73,
        0x74, 0x61, 0x72, 0x74, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x1e, 0x0a, 0x1a, 0x52, 0x45,
        0x53, 0x54, 0x41, 0x52, 0x54, 0x5f, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x55, 0x4e, 0x53,
        0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x19, 0x0a, 0x15, 0x52, 0x45,
        0x53, 0x54, 0x41, 0x52, 0x54, 0x5f, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x41, 0x4c, 0x57,
        0x41, 0x59, 0x53, 0x10, 0x01, 0x12, 0x1d, 0x0a, 0x19, 0x52, 0x45, 0x53, 0x54, 0x41, 0x52, 0x54,
        0x5f, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x4f, 0x4e, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x55,
        0x52, 0x45, 0x10, 0x02, 0x12, 0x18, 0x0a, 0x14, 0x52, 0x45, 0x53, 0x54, 0x41, 0x52, 0x54, 0x5f,
        0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x4e, 0x45, 0x56, 0x45, 0x52, 0x10, 0x03, 0x2a, 0x68,
        0x0a, 0x09, 0x50, 0x72, 0x6f, 0x62, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1a, 0x0a, 0x16, 0x50,
        0x52, 0x4f, 0x42, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43,
        0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x13, 0x0a, 0x0f, 0x50, 0x52, 0x4f, 0x42, 0x45,
        0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x48, 0x54, 0x54, 0x50, 0x10, 0x01, 0x12, 0x12, 0x0a, 0x0e,
        0x50, 0x52, 0x4f, 0x42, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x54, 0x43, 0x50, 0x10, 0x02,
        0x12, 0x16, 0x0a, 0x12, 0x50, 0x52, 0x4f, 0x42, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x43,
        0x4f, 0x4d, 0x4d, 0x41, 0x4e, 0x44, 0x10, 0x03, 0x42, 0x2a, 0x5a, 0x28, 0x67, 0x69, 0x74, 0x68,
        0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x7a, 0x62, 0x69, 0x6c, 0x6c, 0x2f, 0x72, 0x75,
        0x6e, 0x65, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x67, 0x65, 0x6e, 0x65, 0x72,
        0x61, 0x74, 0x65, 0x64, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_pkg_api_proto_common_proto_rawDescOnce sync.Once
        file_pkg_api_proto_common_proto_rawDescData = file_pkg_api_proto_common_proto_rawDesc
)

func file_pkg_api_proto_common_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_pkg_api_proto_common_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_pkg_api_proto_common_proto_rawDescData = protoimpl.X.CompressGZIP(file_pkg_api_proto_common_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_pkg_api_proto_common_proto_rawDescData</span>
}

var file_pkg_api_proto_common_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_pkg_api_proto_common_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_pkg_api_proto_common_proto_goTypes = []interface{}{
        (ResourceType)(0),              // 0: rune.api.ResourceType
        (EventType)(0),                 // 1: rune.api.EventType
        (RestartPolicy)(0),             // 2: rune.api.RestartPolicy
        (ProbeType)(0),                 // 3: rune.api.ProbeType
        (*Status)(nil),                 // 4: rune.api.Status
        (*Empty)(nil),                  // 5: rune.api.Empty
        (*PagingParams)(nil),           // 6: rune.api.PagingParams
        (*ResourceLimit)(nil),          // 7: rune.api.ResourceLimit
        (*Resources)(nil),              // 8: rune.api.Resources
        (*ProcessSpec)(nil),            // 9: rune.api.ProcessSpec
        (*ProcessSecurityContext)(nil), // 10: rune.api.ProcessSecurityContext
        (*ServicePort)(nil),            // 11: rune.api.ServicePort
        (*Probe)(nil),                  // 12: rune.api.Probe
        (*HealthCheck)(nil),            // 13: rune.api.HealthCheck
}
var file_pkg_api_proto_common_proto_depIdxs = []int32{
        7,  // 0: rune.api.Resources.cpu:type_name -&gt; rune.api.ResourceLimit
        7,  // 1: rune.api.Resources.memory:type_name -&gt; rune.api.ResourceLimit
        10, // 2: rune.api.ProcessSpec.security_context:type_name -&gt; rune.api.ProcessSecurityContext
        3,  // 3: rune.api.Probe.type:type_name -&gt; rune.api.ProbeType
        12, // 4: rune.api.HealthCheck.liveness:type_name -&gt; rune.api.Probe
        12, // 5: rune.api.HealthCheck.readiness:type_name -&gt; rune.api.Probe
        6,  // [6:6] is the sub-list for method output_type
        6,  // [6:6] is the sub-list for method input_type
        6,  // [6:6] is the sub-list for extension type_name
        6,  // [6:6] is the sub-list for extension extendee
        0,  // [0:6] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_pkg_api_proto_common_proto_init() }</span>
func file_pkg_api_proto_common_proto_init() <span class="cov8" title="1">{
        if File_pkg_api_proto_common_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_pkg_api_proto_common_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Status); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_common_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Empty); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_common_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*PagingParams); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_common_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ResourceLimit); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_common_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Resources); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_common_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ProcessSpec); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_common_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ProcessSecurityContext); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_common_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ServicePort); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_common_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Probe); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_common_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*HealthCheck); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_pkg_api_proto_common_proto_rawDesc,
                        NumEnums:      4,
                        NumMessages:   10,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_pkg_api_proto_common_proto_goTypes,
                DependencyIndexes: file_pkg_api_proto_common_proto_depIdxs,
                EnumInfos:         file_pkg_api_proto_common_proto_enumTypes,
                MessageInfos:      file_pkg_api_proto_common_proto_msgTypes,
        }.Build()
        File_pkg_api_proto_common_proto = out.File
        file_pkg_api_proto_common_proto_rawDesc = nil
        file_pkg_api_proto_common_proto_goTypes = nil
        file_pkg_api_proto_common_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v5.29.3
// source: pkg/api/proto/exec.proto

package generated

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ExecRequest represents a request from client to server in an exec session.
type ExecRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Request can be one of the following
        //
        // Types that are assignable to Request:
        //
        //        *ExecRequest_Init
        //        *ExecRequest_Stdin
        //        *ExecRequest_Resize
        //        *ExecRequest_Signal
        Request isExecRequest_Request `protobuf_oneof:"request"`
}

func (x *ExecRequest) Reset() <span class="cov0" title="0">{
        *x = ExecRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_exec_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ExecRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ExecRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ExecRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_exec_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ExecRequest.ProtoReflect.Descriptor instead.
func (*ExecRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_exec_proto_rawDescGZIP(), []int{0}
}</span>

func (m *ExecRequest) GetRequest() isExecRequest_Request <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.Request
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ExecRequest) GetInit() *ExecInitRequest <span class="cov8" title="1">{
        if x, ok := x.GetRequest().(*ExecRequest_Init); ok </span><span class="cov8" title="1">{
                return x.Init
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ExecRequest) GetStdin() []byte <span class="cov0" title="0">{
        if x, ok := x.GetRequest().(*ExecRequest_Stdin); ok </span><span class="cov0" title="0">{
                return x.Stdin
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ExecRequest) GetResize() *TerminalSize <span class="cov0" title="0">{
        if x, ok := x.GetRequest().(*ExecRequest_Resize); ok </span><span class="cov0" title="0">{
                return x.Resize
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ExecRequest) GetSignal() *Signal <span class="cov0" title="0">{
        if x, ok := x.GetRequest().(*ExecRequest_Signal); ok </span><span class="cov0" title="0">{
                return x.Signal
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isExecRequest_Request interface {
        isExecRequest_Request()
}

type ExecRequest_Init struct {
        // Initial setup for the exec session
        Init *ExecInitRequest `protobuf:"bytes,1,opt,name=init,proto3,oneof"`
}

type ExecRequest_Stdin struct {
        // Standard input data to send to the process
        Stdin []byte `protobuf:"bytes,2,opt,name=stdin,proto3,oneof"`
}

type ExecRequest_Resize struct {
        // Terminal resize event
        Resize *TerminalSize `protobuf:"bytes,3,opt,name=resize,proto3,oneof"`
}

type ExecRequest_Signal struct {
        // Signal to send to the process
        Signal *Signal `protobuf:"bytes,4,opt,name=signal,proto3,oneof"`
}

func (*ExecRequest_Init) isExecRequest_Request() {<span class="cov0" title="0">}</span>

func (*ExecRequest_Stdin) isExecRequest_Request() {<span class="cov0" title="0">}</span>

func (*ExecRequest_Resize) isExecRequest_Request() {<span class="cov0" title="0">}</span>

func (*ExecRequest_Signal) isExecRequest_Request() {<span class="cov0" title="0">}</span>

// ExecInitRequest initializes an exec session.
type ExecInitRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Target instance or service
        //
        // Types that are assignable to Target:
        //
        //        *ExecInitRequest_ServiceName
        //        *ExecInitRequest_InstanceId
        Target isExecInitRequest_Target `protobuf_oneof:"target"`
        // Namespace of the service (optional, default: "default")
        Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Command to execute
        Command []string `protobuf:"bytes,4,rep,name=command,proto3" json:"command,omitempty"`
        // Environment variables for the command
        Env map[string]string `protobuf:"bytes,5,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Working directory for the command
        WorkingDir string `protobuf:"bytes,6,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
        // Whether to allocate a TTY
        Tty bool `protobuf:"varint,7,opt,name=tty,proto3" json:"tty,omitempty"`
        // Initial terminal size if TTY is true
        TerminalSize *TerminalSize `protobuf:"bytes,8,opt,name=terminal_size,json=terminalSize,proto3" json:"terminal_size,omitempty"`
}

func (x *ExecInitRequest) Reset() <span class="cov0" title="0">{
        *x = ExecInitRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_exec_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ExecInitRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ExecInitRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ExecInitRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_exec_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ExecInitRequest.ProtoReflect.Descriptor instead.
func (*ExecInitRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_exec_proto_rawDescGZIP(), []int{1}
}</span>

func (m *ExecInitRequest) GetTarget() isExecInitRequest_Target <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.Target
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ExecInitRequest) GetServiceName() string <span class="cov8" title="1">{
        if x, ok := x.GetTarget().(*ExecInitRequest_ServiceName); ok </span><span class="cov0" title="0">{
                return x.ServiceName
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func (x *ExecInitRequest) GetInstanceId() string <span class="cov8" title="1">{
        if x, ok := x.GetTarget().(*ExecInitRequest_InstanceId); ok </span><span class="cov8" title="1">{
                return x.InstanceId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ExecInitRequest) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ExecInitRequest) GetCommand() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Command
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ExecInitRequest) GetEnv() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Env
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ExecInitRequest) GetWorkingDir() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.WorkingDir
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ExecInitRequest) GetTty() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tty
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ExecInitRequest) GetTerminalSize() *TerminalSize <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TerminalSize
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isExecInitRequest_Target interface {
        isExecInitRequest_Target()
}

type ExecInitRequest_ServiceName struct {
        // Service name (will select one instance)
        ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3,oneof"`
}

type ExecInitRequest_InstanceId struct {
        // Specific instance ID
        InstanceId string `protobuf:"bytes,2,opt,name=instance_id,json=instanceId,proto3,oneof"`
}

func (*ExecInitRequest_ServiceName) isExecInitRequest_Target() {<span class="cov0" title="0">}</span>

func (*ExecInitRequest_InstanceId) isExecInitRequest_Target() {<span class="cov0" title="0">}</span>

// TerminalSize represents the size of a terminal.
type TerminalSize struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Width in characters
        Width uint32 `protobuf:"varint,1,opt,name=width,proto3" json:"width,omitempty"`
        // Height in characters
        Height uint32 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
}

func (x *TerminalSize) Reset() <span class="cov0" title="0">{
        *x = TerminalSize{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_exec_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TerminalSize) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TerminalSize) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TerminalSize) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_exec_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TerminalSize.ProtoReflect.Descriptor instead.
func (*TerminalSize) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_exec_proto_rawDescGZIP(), []int{2}
}</span>

func (x *TerminalSize) GetWidth() uint32 <span class="cov8" title="1">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Width
        }</span>
        <span class="cov8" title="1">return 0</span>
}

func (x *TerminalSize) GetHeight() uint32 <span class="cov8" title="1">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Height
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// Signal represents a signal to send to the process.
type Signal struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Signal name (e.g., "SIGINT", "SIGTERM")
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *Signal) Reset() <span class="cov0" title="0">{
        *x = Signal{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_exec_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Signal) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Signal) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Signal) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_exec_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Signal.ProtoReflect.Descriptor instead.
func (*Signal) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_exec_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Signal) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ExecResponse represents a response from server to client in an exec session.
type ExecResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Response can be one of the following
        //
        // Types that are assignable to Response:
        //
        //        *ExecResponse_Stdout
        //        *ExecResponse_Stderr
        //        *ExecResponse_Status
        //        *ExecResponse_Exit
        Response isExecResponse_Response `protobuf_oneof:"response"`
}

func (x *ExecResponse) Reset() <span class="cov0" title="0">{
        *x = ExecResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_exec_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ExecResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ExecResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ExecResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_exec_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ExecResponse.ProtoReflect.Descriptor instead.
func (*ExecResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_exec_proto_rawDescGZIP(), []int{4}
}</span>

func (m *ExecResponse) GetResponse() isExecResponse_Response <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Response
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ExecResponse) GetStdout() []byte <span class="cov0" title="0">{
        if x, ok := x.GetResponse().(*ExecResponse_Stdout); ok </span><span class="cov0" title="0">{
                return x.Stdout
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ExecResponse) GetStderr() []byte <span class="cov0" title="0">{
        if x, ok := x.GetResponse().(*ExecResponse_Stderr); ok </span><span class="cov0" title="0">{
                return x.Stderr
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ExecResponse) GetStatus() *Status <span class="cov0" title="0">{
        if x, ok := x.GetResponse().(*ExecResponse_Status); ok </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ExecResponse) GetExit() *ExitInfo <span class="cov0" title="0">{
        if x, ok := x.GetResponse().(*ExecResponse_Exit); ok </span><span class="cov0" title="0">{
                return x.Exit
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isExecResponse_Response interface {
        isExecResponse_Response()
}

type ExecResponse_Stdout struct {
        // Standard output from the process
        Stdout []byte `protobuf:"bytes,1,opt,name=stdout,proto3,oneof"`
}

type ExecResponse_Stderr struct {
        // Standard error from the process
        Stderr []byte `protobuf:"bytes,2,opt,name=stderr,proto3,oneof"`
}

type ExecResponse_Status struct {
        // Status message (for errors, completion, etc.)
        Status *Status `protobuf:"bytes,3,opt,name=status,proto3,oneof"`
}

type ExecResponse_Exit struct {
        // Exit information when the process completes
        Exit *ExitInfo `protobuf:"bytes,4,opt,name=exit,proto3,oneof"`
}

func (*ExecResponse_Stdout) isExecResponse_Response() {<span class="cov0" title="0">}</span>

func (*ExecResponse_Stderr) isExecResponse_Response() {<span class="cov0" title="0">}</span>

func (*ExecResponse_Status) isExecResponse_Response() {<span class="cov0" title="0">}</span>

func (*ExecResponse_Exit) isExecResponse_Response() {<span class="cov0" title="0">}</span>

// ExitInfo provides information about the process exit.
type ExitInfo struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Exit code of the process
        Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
        // Whether the process exited due to a signal
        Signaled bool `protobuf:"varint,2,opt,name=signaled,proto3" json:"signaled,omitempty"`
        // Signal that caused the exit, if signaled is true
        Signal string `protobuf:"bytes,3,opt,name=signal,proto3" json:"signal,omitempty"`
}

func (x *ExitInfo) Reset() <span class="cov0" title="0">{
        *x = ExitInfo{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_exec_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ExitInfo) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ExitInfo) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ExitInfo) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_exec_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ExitInfo.ProtoReflect.Descriptor instead.
func (*ExitInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_exec_proto_rawDescGZIP(), []int{5}
}</span>

func (x *ExitInfo) GetCode() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ExitInfo) GetSignaled() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Signaled
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ExitInfo) GetSignal() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Signal
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_pkg_api_proto_exec_proto protoreflect.FileDescriptor

var file_pkg_api_proto_exec_proto_rawDesc = []byte{
        0x0a, 0x18, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f,
        0x65, 0x78, 0x65, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08, 0x72, 0x75, 0x6e, 0x65,
        0x2e, 0x61, 0x70, 0x69, 0x1a, 0x1a, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x22, 0xbf, 0x01, 0x0a, 0x0b, 0x45, 0x78, 0x65, 0x63, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x2f, 0x0a, 0x04, 0x69, 0x6e, 0x69, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19,
        0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x49, 0x6e,
        0x69, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x00, 0x52, 0x04, 0x69, 0x6e, 0x69,
        0x74, 0x12, 0x16, 0x0a, 0x05, 0x73, 0x74, 0x64, 0x69, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c,
        0x48, 0x00, 0x52, 0x05, 0x73, 0x74, 0x64, 0x69, 0x6e, 0x12, 0x30, 0x0a, 0x06, 0x72, 0x65, 0x73,
        0x69, 0x7a, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x72, 0x75, 0x6e, 0x65,
        0x2e, 0x61, 0x70, 0x69, 0x2e, 0x54, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x53, 0x69, 0x7a,
        0x65, 0x48, 0x00, 0x52, 0x06, 0x72, 0x65, 0x73, 0x69, 0x7a, 0x65, 0x12, 0x2a, 0x0a, 0x06, 0x73,
        0x69, 0x67, 0x6e, 0x61, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x72, 0x75,
        0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x48, 0x00, 0x52,
        0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x42, 0x09, 0x0a, 0x07, 0x72, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x22, 0xf9, 0x02, 0x0a, 0x0f, 0x45, 0x78, 0x65, 0x63, 0x49, 0x6e, 0x69, 0x74, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x23, 0x0a, 0x0c, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x0b,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x21, 0x0a, 0x0b, 0x69,
        0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x48, 0x00, 0x52, 0x0a, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x49, 0x64, 0x12, 0x1c,
        0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x18, 0x0a, 0x07,
        0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x63,
        0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x12, 0x34, 0x0a, 0x03, 0x65, 0x6e, 0x76, 0x18, 0x05, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x45,
        0x78, 0x65, 0x63, 0x49, 0x6e, 0x69, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x45,
        0x6e, 0x76, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x03, 0x65, 0x6e, 0x76, 0x12, 0x1f, 0x0a, 0x0b,
        0x77, 0x6f, 0x72, 0x6b, 0x69, 0x6e, 0x67, 0x5f, 0x64, 0x69, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x0a, 0x77, 0x6f, 0x72, 0x6b, 0x69, 0x6e, 0x67, 0x44, 0x69, 0x72, 0x12, 0x10, 0x0a,
        0x03, 0x74, 0x74, 0x79, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x03, 0x74, 0x74, 0x79, 0x12,
        0x3b, 0x0a, 0x0d, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65,
        0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70,
        0x69, 0x2e, 0x54, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x52, 0x0c,
        0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x1a, 0x36, 0x0a, 0x08,
        0x45, 0x6e, 0x76, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x42, 0x08, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x22, 0x3c,
        0x0a, 0x0c, 0x54, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x14,
        0x0a, 0x05, 0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x77,
        0x69, 0x64, 0x74, 0x68, 0x12, 0x16, 0x0a, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x22, 0x1c, 0x0a, 0x06,
        0x53, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0xa4, 0x01, 0x0a, 0x0c, 0x45,
        0x78, 0x65, 0x63, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x06, 0x73,
        0x74, 0x64, 0x6f, 0x75, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x06, 0x73,
        0x74, 0x64, 0x6f, 0x75, 0x74, 0x12, 0x18, 0x0a, 0x06, 0x73, 0x74, 0x64, 0x65, 0x72, 0x72, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x06, 0x73, 0x74, 0x64, 0x65, 0x72, 0x72, 0x12,
        0x2a, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x10, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75,
        0x73, 0x48, 0x00, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x28, 0x0a, 0x04, 0x65,
        0x78, 0x69, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x72, 0x75, 0x6e, 0x65,
        0x2e, 0x61, 0x70, 0x69, 0x2e, 0x45, 0x78, 0x69, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x48, 0x00, 0x52,
        0x04, 0x65, 0x78, 0x69, 0x74, 0x42, 0x0a, 0x0a, 0x08, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x22, 0x52, 0x0a, 0x08, 0x45, 0x78, 0x69, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x12, 0x0a,
        0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x63, 0x6f, 0x64,
        0x65, 0x12, 0x1a, 0x0a, 0x08, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x65, 0x64, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x08, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x65, 0x64, 0x12, 0x16, 0x0a,
        0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73,
        0x69, 0x67, 0x6e, 0x61, 0x6c, 0x32, 0x4e, 0x0a, 0x0b, 0x45, 0x78, 0x65, 0x63, 0x53, 0x65, 0x72,
        0x76, 0x69, 0x63, 0x65, 0x12, 0x3f, 0x0a, 0x0a, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x45, 0x78,
        0x65, 0x63, 0x12, 0x15, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x45, 0x78,
        0x65, 0x63, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x72, 0x75, 0x6e, 0x65,
        0x2e, 0x61, 0x70, 0x69, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x28, 0x01, 0x30, 0x01, 0x42, 0x2a, 0x5a, 0x28, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e,
        0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x7a, 0x62, 0x69, 0x6c, 0x6c, 0x2f, 0x72, 0x75, 0x6e, 0x65, 0x2f,
        0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65,
        0x64, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_pkg_api_proto_exec_proto_rawDescOnce sync.Once
        file_pkg_api_proto_exec_proto_rawDescData = file_pkg_api_proto_exec_proto_rawDesc
)

func file_pkg_api_proto_exec_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_pkg_api_proto_exec_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_pkg_api_proto_exec_proto_rawDescData = protoimpl.X.CompressGZIP(file_pkg_api_proto_exec_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_pkg_api_proto_exec_proto_rawDescData</span>
}

var file_pkg_api_proto_exec_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_pkg_api_proto_exec_proto_goTypes = []interface{}{
        (*ExecRequest)(nil),     // 0: rune.api.ExecRequest
        (*ExecInitRequest)(nil), // 1: rune.api.ExecInitRequest
        (*TerminalSize)(nil),    // 2: rune.api.TerminalSize
        (*Signal)(nil),          // 3: rune.api.Signal
        (*ExecResponse)(nil),    // 4: rune.api.ExecResponse
        (*ExitInfo)(nil),        // 5: rune.api.ExitInfo
        nil,                     // 6: rune.api.ExecInitRequest.EnvEntry
        (*Status)(nil),          // 7: rune.api.Status
}
var file_pkg_api_proto_exec_proto_depIdxs = []int32{
        1, // 0: rune.api.ExecRequest.init:type_name -&gt; rune.api.ExecInitRequest
        2, // 1: rune.api.ExecRequest.resize:type_name -&gt; rune.api.TerminalSize
        3, // 2: rune.api.ExecRequest.signal:type_name -&gt; rune.api.Signal
        6, // 3: rune.api.ExecInitRequest.env:type_name -&gt; rune.api.ExecInitRequest.EnvEntry
        2, // 4: rune.api.ExecInitRequest.terminal_size:type_name -&gt; rune.api.TerminalSize
        7, // 5: rune.api.ExecResponse.status:type_name -&gt; rune.api.Status
        5, // 6: rune.api.ExecResponse.exit:type_name -&gt; rune.api.ExitInfo
        0, // 7: rune.api.ExecService.StreamExec:input_type -&gt; rune.api.ExecRequest
        4, // 8: rune.api.ExecService.StreamExec:output_type -&gt; rune.api.ExecResponse
        8, // [8:9] is the sub-list for method output_type
        7, // [7:8] is the sub-list for method input_type
        7, // [7:7] is the sub-list for extension type_name
        7, // [7:7] is the sub-list for extension extendee
        0, // [0:7] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_pkg_api_proto_exec_proto_init() }</span>
func file_pkg_api_proto_exec_proto_init() <span class="cov8" title="1">{
        if File_pkg_api_proto_exec_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_pkg_api_proto_common_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_pkg_api_proto_exec_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ExecRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_exec_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ExecInitRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_exec_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TerminalSize); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_exec_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Signal); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_exec_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ExecResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_exec_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ExitInfo); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_pkg_api_proto_exec_proto_msgTypes[0].OneofWrappers = []interface{}{
                (*ExecRequest_Init)(nil),
                (*ExecRequest_Stdin)(nil),
                (*ExecRequest_Resize)(nil),
                (*ExecRequest_Signal)(nil),
        }
        file_pkg_api_proto_exec_proto_msgTypes[1].OneofWrappers = []interface{}{
                (*ExecInitRequest_ServiceName)(nil),
                (*ExecInitRequest_InstanceId)(nil),
        }
        file_pkg_api_proto_exec_proto_msgTypes[4].OneofWrappers = []interface{}{
                (*ExecResponse_Stdout)(nil),
                (*ExecResponse_Stderr)(nil),
                (*ExecResponse_Status)(nil),
                (*ExecResponse_Exit)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_pkg_api_proto_exec_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   7,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_pkg_api_proto_exec_proto_goTypes,
                DependencyIndexes: file_pkg_api_proto_exec_proto_depIdxs,
                MessageInfos:      file_pkg_api_proto_exec_proto_msgTypes,
        }.Build()
        File_pkg_api_proto_exec_proto = out.File
        file_pkg_api_proto_exec_proto_rawDesc = nil
        file_pkg_api_proto_exec_proto_goTypes = nil
        file_pkg_api_proto_exec_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: pkg/api/proto/exec.proto

/*
Package generated is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package generated

import (
        "context"
        "io"
        "net/http"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/v2/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = metadata.Join

func request_ExecService_StreamExec_0(ctx context.Context, marshaler runtime.Marshaler, client ExecServiceClient, req *http.Request, pathParams map[string]string) (ExecService_StreamExecClient, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var metadata runtime.ServerMetadata
        stream, err := client.StreamExec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                grpclog.Infof("Failed to start streaming: %v", err)
                return nil, metadata, err
        }</span>
        <span class="cov0" title="0">dec := marshaler.NewDecoder(req.Body)
        handleSend := func() error </span><span class="cov0" title="0">{
                var protoReq ExecRequest
                err := dec.Decode(&amp;protoReq)
                if err == io.EOF </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        grpclog.Infof("Failed to decode request: %v", err)
                        return err
                }</span>
                <span class="cov0" title="0">if err := stream.Send(&amp;protoReq); err != nil </span><span class="cov0" title="0">{
                        grpclog.Infof("Failed to send request: %v", err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        if err := handleSend(); err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">if err := stream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                        grpclog.Infof("Failed to terminate client stream: %v", err)
                }</span>
        }()
        <span class="cov0" title="0">header, err := stream.Header()
        if err != nil </span><span class="cov0" title="0">{
                grpclog.Infof("Failed to get header from client: %v", err)
                return nil, metadata, err
        }</span>
        <span class="cov0" title="0">metadata.HeaderMD = header
        return stream, metadata, nil</span>
}

// RegisterExecServiceHandlerServer registers the http handlers for service ExecService to "mux".
// UnaryRPC     :call ExecServiceServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterExecServiceHandlerFromEndpoint instead.
func RegisterExecServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ExecServiceServer) error <span class="cov0" title="0">{

        mux.Handle("POST", pattern_ExecService_StreamExec_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                err := status.Error(codes.Unimplemented, "streaming calls are not yet supported in the in-process transport")
                _, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                return
        }</span>)

        <span class="cov0" title="0">return nil</span>
}

// RegisterExecServiceHandlerFromEndpoint is same as RegisterExecServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterExecServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.DialContext(ctx, endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterExecServiceHandler(ctx, mux, conn)</span>
}

// RegisterExecServiceHandler registers the http handlers for service ExecService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterExecServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterExecServiceHandlerClient(ctx, mux, NewExecServiceClient(conn))
}</span>

// RegisterExecServiceHandlerClient registers the http handlers for service ExecService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ExecServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ExecServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ExecServiceClient" to call the correct interceptors.
func RegisterExecServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ExecServiceClient) error <span class="cov0" title="0">{

        mux.Handle("POST", pattern_ExecService_StreamExec_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.ExecService/StreamExec", runtime.WithHTTPPathPattern("/rune.api.ExecService/StreamExec"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_ExecService_StreamExec_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ExecService_StreamExec_0(annotatedContext, mux, outboundMarshaler, w, req, func() (proto.Message, error) </span><span class="cov0" title="0">{ return resp.Recv() }</span>, mux.GetForwardResponseOptions()...)

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_ExecService_StreamExec_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.ExecService", "StreamExec"}, ""))
)

var (
        forward_ExecService_StreamExec_0 = runtime.ForwardResponseStream
)
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.29.3
// source: pkg/api/proto/exec.proto

package generated

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ExecServiceClient is the client API for ExecService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExecServiceClient interface {
        // StreamExec provides bidirectional streaming for exec.
        StreamExec(ctx context.Context, opts ...grpc.CallOption) (ExecService_StreamExecClient, error)
}

type execServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewExecServiceClient(cc grpc.ClientConnInterface) ExecServiceClient <span class="cov0" title="0">{
        return &amp;execServiceClient{cc}
}</span>

func (c *execServiceClient) StreamExec(ctx context.Context, opts ...grpc.CallOption) (ExecService_StreamExecClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;ExecService_ServiceDesc.Streams[0], "/rune.api.ExecService/StreamExec", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;execServiceStreamExecClient{stream}
        return x, nil</span>
}

type ExecService_StreamExecClient interface {
        Send(*ExecRequest) error
        Recv() (*ExecResponse, error)
        grpc.ClientStream
}

type execServiceStreamExecClient struct {
        grpc.ClientStream
}

func (x *execServiceStreamExecClient) Send(m *ExecRequest) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *execServiceStreamExecClient) Recv() (*ExecResponse, error) <span class="cov0" title="0">{
        m := new(ExecResponse)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// ExecServiceServer is the server API for ExecService service.
// All implementations must embed UnimplementedExecServiceServer
// for forward compatibility
type ExecServiceServer interface {
        // StreamExec provides bidirectional streaming for exec.
        StreamExec(ExecService_StreamExecServer) error
        mustEmbedUnimplementedExecServiceServer()
}

// UnimplementedExecServiceServer must be embedded to have forward compatible implementations.
type UnimplementedExecServiceServer struct {
}

func (UnimplementedExecServiceServer) StreamExec(ExecService_StreamExecServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method StreamExec not implemented")
}</span>
func (UnimplementedExecServiceServer) mustEmbedUnimplementedExecServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeExecServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExecServiceServer will
// result in compilation errors.
type UnsafeExecServiceServer interface {
        mustEmbedUnimplementedExecServiceServer()
}

func RegisterExecServiceServer(s grpc.ServiceRegistrar, srv ExecServiceServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;ExecService_ServiceDesc, srv)
}</span>

func _ExecService_StreamExec_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(ExecServiceServer).StreamExec(&amp;execServiceStreamExecServer{stream})
}</span>

type ExecService_StreamExecServer interface {
        Send(*ExecResponse) error
        Recv() (*ExecRequest, error)
        grpc.ServerStream
}

type execServiceStreamExecServer struct {
        grpc.ServerStream
}

func (x *execServiceStreamExecServer) Send(m *ExecResponse) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *execServiceStreamExecServer) Recv() (*ExecRequest, error) <span class="cov0" title="0">{
        m := new(ExecRequest)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// ExecService_ServiceDesc is the grpc.ServiceDesc for ExecService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExecService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "rune.api.ExecService",
        HandlerType: (*ExecServiceServer)(nil),
        Methods:     []grpc.MethodDesc{},
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "StreamExec",
                        Handler:       _ExecService_StreamExec_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
        },
        Metadata: "pkg/api/proto/exec.proto",
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v5.29.3
// source: pkg/api/proto/health.proto

package generated

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// HealthStatus represents the health status of a component.
type HealthStatus int32

const (
        HealthStatus_HEALTH_STATUS_UNSPECIFIED HealthStatus = 0
        HealthStatus_HEALTH_STATUS_UNKNOWN     HealthStatus = 1 // Status is unknown
        HealthStatus_HEALTH_STATUS_HEALTHY     HealthStatus = 2 // Healthy and functioning correctly
        HealthStatus_HEALTH_STATUS_UNHEALTHY   HealthStatus = 3 // Unhealthy and not functioning correctly
        HealthStatus_HEALTH_STATUS_DEGRADED    HealthStatus = 4 // Functioning but with reduced capabilities
)

// Enum value maps for HealthStatus.
var (
        HealthStatus_name = map[int32]string{
                0: "HEALTH_STATUS_UNSPECIFIED",
                1: "HEALTH_STATUS_UNKNOWN",
                2: "HEALTH_STATUS_HEALTHY",
                3: "HEALTH_STATUS_UNHEALTHY",
                4: "HEALTH_STATUS_DEGRADED",
        }
        HealthStatus_value = map[string]int32{
                "HEALTH_STATUS_UNSPECIFIED": 0,
                "HEALTH_STATUS_UNKNOWN":     1,
                "HEALTH_STATUS_HEALTHY":     2,
                "HEALTH_STATUS_UNHEALTHY":   3,
                "HEALTH_STATUS_DEGRADED":    4,
        }
)

func (x HealthStatus) Enum() *HealthStatus <span class="cov0" title="0">{
        p := new(HealthStatus)
        *p = x
        return p
}</span>

func (x HealthStatus) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (HealthStatus) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_pkg_api_proto_health_proto_enumTypes[0].Descriptor()
}</span>

func (HealthStatus) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_pkg_api_proto_health_proto_enumTypes[0]
}</span>

func (x HealthStatus) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use HealthStatus.Descriptor instead.
func (HealthStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_health_proto_rawDescGZIP(), []int{0}
}</span>

// HealthCheckType defines different types of health checks.
type HealthCheckType int32

const (
        HealthCheckType_HEALTH_CHECK_TYPE_UNSPECIFIED HealthCheckType = 0
        HealthCheckType_HEALTH_CHECK_TYPE_LIVENESS    HealthCheckType = 1 // Basic liveness check
        HealthCheckType_HEALTH_CHECK_TYPE_READINESS   HealthCheckType = 2 // Readiness to receive traffic
        HealthCheckType_HEALTH_CHECK_TYPE_STARTUP     HealthCheckType = 3 // Initialization check
)

// Enum value maps for HealthCheckType.
var (
        HealthCheckType_name = map[int32]string{
                0: "HEALTH_CHECK_TYPE_UNSPECIFIED",
                1: "HEALTH_CHECK_TYPE_LIVENESS",
                2: "HEALTH_CHECK_TYPE_READINESS",
                3: "HEALTH_CHECK_TYPE_STARTUP",
        }
        HealthCheckType_value = map[string]int32{
                "HEALTH_CHECK_TYPE_UNSPECIFIED": 0,
                "HEALTH_CHECK_TYPE_LIVENESS":    1,
                "HEALTH_CHECK_TYPE_READINESS":   2,
                "HEALTH_CHECK_TYPE_STARTUP":     3,
        }
)

func (x HealthCheckType) Enum() *HealthCheckType <span class="cov0" title="0">{
        p := new(HealthCheckType)
        *p = x
        return p
}</span>

func (x HealthCheckType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (HealthCheckType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_pkg_api_proto_health_proto_enumTypes[1].Descriptor()
}</span>

func (HealthCheckType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_pkg_api_proto_health_proto_enumTypes[1]
}</span>

func (x HealthCheckType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use HealthCheckType.Descriptor instead.
func (HealthCheckType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_health_proto_rawDescGZIP(), []int{1}
}</span>

// HealthCheckResult represents the result of a health check.
type HealthCheckResult struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Type of health check
        Type HealthCheckType `protobuf:"varint,1,opt,name=type,proto3,enum=rune.api.HealthCheckType" json:"type,omitempty"`
        // Status of the check
        Status HealthStatus `protobuf:"varint,2,opt,name=status,proto3,enum=rune.api.HealthStatus" json:"status,omitempty"`
        // Detailed message about the health status
        Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
        // Last check timestamp (RFC 3339 format)
        Timestamp string `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        // Consecutive successes
        ConsecutiveSuccesses int32 `protobuf:"varint,5,opt,name=consecutive_successes,json=consecutiveSuccesses,proto3" json:"consecutive_successes,omitempty"`
        // Consecutive failures
        ConsecutiveFailures int32 `protobuf:"varint,6,opt,name=consecutive_failures,json=consecutiveFailures,proto3" json:"consecutive_failures,omitempty"`
}

func (x *HealthCheckResult) Reset() <span class="cov0" title="0">{
        *x = HealthCheckResult{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_health_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *HealthCheckResult) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HealthCheckResult) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HealthCheckResult) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_health_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HealthCheckResult.ProtoReflect.Descriptor instead.
func (*HealthCheckResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_health_proto_rawDescGZIP(), []int{0}
}</span>

func (x *HealthCheckResult) GetType() HealthCheckType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return HealthCheckType_HEALTH_CHECK_TYPE_UNSPECIFIED</span>
}

func (x *HealthCheckResult) GetStatus() HealthStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return HealthStatus_HEALTH_STATUS_UNSPECIFIED</span>
}

func (x *HealthCheckResult) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HealthCheckResult) GetTimestamp() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HealthCheckResult) GetConsecutiveSuccesses() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConsecutiveSuccesses
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *HealthCheckResult) GetConsecutiveFailures() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConsecutiveFailures
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ComponentHealth represents the health status of a component.
type ComponentHealth struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Component type (e.g., "service", "instance", "node", "api-server")
        ComponentType string `protobuf:"bytes,1,opt,name=component_type,json=componentType,proto3" json:"component_type,omitempty"`
        // Component identifier
        Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
        // Name of the component
        Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
        // Namespace of the component (if applicable)
        Namespace string `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Overall health status
        Status HealthStatus `protobuf:"varint,5,opt,name=status,proto3,enum=rune.api.HealthStatus" json:"status,omitempty"`
        // Detailed message about the health status
        Message string `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
        // Last update timestamp (RFC 3339 format)
        Timestamp string `protobuf:"bytes,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        // Individual health check results
        CheckResults []*HealthCheckResult `protobuf:"bytes,8,rep,name=check_results,json=checkResults,proto3" json:"check_results,omitempty"`
}

func (x *ComponentHealth) Reset() <span class="cov0" title="0">{
        *x = ComponentHealth{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_health_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ComponentHealth) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ComponentHealth) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ComponentHealth) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_health_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ComponentHealth.ProtoReflect.Descriptor instead.
func (*ComponentHealth) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_health_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ComponentHealth) GetComponentType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ComponentType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ComponentHealth) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ComponentHealth) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ComponentHealth) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ComponentHealth) GetStatus() HealthStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return HealthStatus_HEALTH_STATUS_UNSPECIFIED</span>
}

func (x *ComponentHealth) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ComponentHealth) GetTimestamp() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ComponentHealth) GetCheckResults() []*HealthCheckResult <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CheckResults
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetHealthRequest requests health information.
type GetHealthRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Component type to check (e.g., "service", "instance", "node", "api-server")
        ComponentType string `protobuf:"bytes,1,opt,name=component_type,json=componentType,proto3" json:"component_type,omitempty"`
        // Component name to check (optional)
        Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        // Namespace of the component (if applicable)
        Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Include detailed check results
        IncludeChecks bool `protobuf:"varint,4,opt,name=include_checks,json=includeChecks,proto3" json:"include_checks,omitempty"`
}

func (x *GetHealthRequest) Reset() <span class="cov0" title="0">{
        *x = GetHealthRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_health_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetHealthRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetHealthRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetHealthRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_health_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetHealthRequest.ProtoReflect.Descriptor instead.
func (*GetHealthRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_health_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetHealthRequest) GetComponentType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ComponentType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetHealthRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetHealthRequest) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetHealthRequest) GetIncludeChecks() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IncludeChecks
        }</span>
        <span class="cov0" title="0">return false</span>
}

// GetHealthResponse returns health information.
type GetHealthResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Health information of the requested components
        Components []*ComponentHealth `protobuf:"bytes,1,rep,name=components,proto3" json:"components,omitempty"`
        // Status message
        Status *Status `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *GetHealthResponse) Reset() <span class="cov0" title="0">{
        *x = GetHealthResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_health_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetHealthResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetHealthResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetHealthResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_health_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetHealthResponse.ProtoReflect.Descriptor instead.
func (*GetHealthResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_health_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetHealthResponse) GetComponents() []*ComponentHealth <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Components
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetHealthResponse) GetStatus() *Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_pkg_api_proto_health_proto protoreflect.FileDescriptor

var file_pkg_api_proto_health_proto_rawDesc = []byte{
        0x0a, 0x1a, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f,
        0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08, 0x72, 0x75,
        0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x1a, 0x1a, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x22, 0x92, 0x02, 0x0a, 0x11, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65,
        0x63, 0x6b, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x2d, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70,
        0x69, 0x2e, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x54, 0x79, 0x70,
        0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x2e, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,
        0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61,
        0x70, 0x69, 0x2e, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52,
        0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61,
        0x67, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
        0x65, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12,
        0x33, 0x0a, 0x15, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x75, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x73,
        0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x14,
        0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x75, 0x74, 0x69, 0x76, 0x65, 0x53, 0x75, 0x63, 0x63, 0x65,
        0x73, 0x73, 0x65, 0x73, 0x12, 0x31, 0x0a, 0x14, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x75, 0x74,
        0x69, 0x76, 0x65, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x73, 0x18, 0x06, 0x20, 0x01,
        0x28, 0x05, 0x52, 0x13, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x75, 0x74, 0x69, 0x76, 0x65, 0x46,
        0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x73, 0x22, 0xa4, 0x02, 0x0a, 0x0f, 0x43, 0x6f, 0x6d, 0x70,
        0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x12, 0x25, 0x0a, 0x0e, 0x63,
        0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0d, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x54, 0x79,
        0x70, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02,
        0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70,
        0x61, 0x63, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73,
        0x70, 0x61, 0x63, 0x65, 0x12, 0x2e, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e,
        0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74,
        0x61, 0x74, 0x75, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18,
        0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x1c,
        0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x07, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x40, 0x0a, 0x0d,
        0x63, 0x68, 0x65, 0x63, 0x6b, 0x5f, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x08, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x48,
        0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74,
        0x52, 0x0c, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x22, 0x92,
        0x01, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x25, 0x0a, 0x0e, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74,
        0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x63, 0x6f, 0x6d,
        0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61,
        0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1c,
        0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x25, 0x0a, 0x0e,
        0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x43, 0x68, 0x65,
        0x63, 0x6b, 0x73, 0x22, 0x78, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x6f, 0x6d, 0x70,
        0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x72,
        0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e,
        0x74, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x52, 0x0a, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65,
        0x6e, 0x74, 0x73, 0x12, 0x28, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53,
        0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2a, 0x9c, 0x01,
        0x0a, 0x0c, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1d,
        0x0a, 0x19, 0x48, 0x45, 0x41, 0x4c, 0x54, 0x48, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f,
        0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x19, 0x0a,
        0x15, 0x48, 0x45, 0x41, 0x4c, 0x54, 0x48, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55,
        0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x01, 0x12, 0x19, 0x0a, 0x15, 0x48, 0x45, 0x41, 0x4c,
        0x54, 0x48, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x48, 0x45, 0x41, 0x4c, 0x54, 0x48,
        0x59, 0x10, 0x02, 0x12, 0x1b, 0x0a, 0x17, 0x48, 0x45, 0x41, 0x4c, 0x54, 0x48, 0x5f, 0x53, 0x54,
        0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x4e, 0x48, 0x45, 0x41, 0x4c, 0x54, 0x48, 0x59, 0x10, 0x03,
        0x12, 0x1a, 0x0a, 0x16, 0x48, 0x45, 0x41, 0x4c, 0x54, 0x48, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55,
        0x53, 0x5f, 0x44, 0x45, 0x47, 0x52, 0x41, 0x44, 0x45, 0x44, 0x10, 0x04, 0x2a, 0x94, 0x01, 0x0a,
        0x0f, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x54, 0x79, 0x70, 0x65,
        0x12, 0x21, 0x0a, 0x1d, 0x48, 0x45, 0x41, 0x4c, 0x54, 0x48, 0x5f, 0x43, 0x48, 0x45, 0x43, 0x4b,
        0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45,
        0x44, 0x10, 0x00, 0x12, 0x1e, 0x0a, 0x1a, 0x48, 0x45, 0x41, 0x4c, 0x54, 0x48, 0x5f, 0x43, 0x48,
        0x45, 0x43, 0x4b, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x49, 0x56, 0x45, 0x4e, 0x45, 0x53,
        0x53, 0x10, 0x01, 0x12, 0x1f, 0x0a, 0x1b, 0x48, 0x45, 0x41, 0x4c, 0x54, 0x48, 0x5f, 0x43, 0x48,
        0x45, 0x43, 0x4b, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52, 0x45, 0x41, 0x44, 0x49, 0x4e, 0x45,
        0x53, 0x53, 0x10, 0x02, 0x12, 0x1d, 0x0a, 0x19, 0x48, 0x45, 0x41, 0x4c, 0x54, 0x48, 0x5f, 0x43,
        0x48, 0x45, 0x43, 0x4b, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x54, 0x41, 0x52, 0x54, 0x55,
        0x50, 0x10, 0x03, 0x32, 0x55, 0x0a, 0x0d, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x53, 0x65, 0x72,
        0x76, 0x69, 0x63, 0x65, 0x12, 0x44, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x48, 0x65, 0x61, 0x6c, 0x74,
        0x68, 0x12, 0x1a, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x47, 0x65, 0x74,
        0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e,
        0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x47, 0x65, 0x74, 0x48, 0x65, 0x61, 0x6c,
        0x74, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x2a, 0x5a, 0x28, 0x67, 0x69,
        0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x7a, 0x62, 0x69, 0x6c, 0x6c, 0x2f,
        0x72, 0x75, 0x6e, 0x65, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x67, 0x65, 0x6e,
        0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_pkg_api_proto_health_proto_rawDescOnce sync.Once
        file_pkg_api_proto_health_proto_rawDescData = file_pkg_api_proto_health_proto_rawDesc
)

func file_pkg_api_proto_health_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_pkg_api_proto_health_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_pkg_api_proto_health_proto_rawDescData = protoimpl.X.CompressGZIP(file_pkg_api_proto_health_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_pkg_api_proto_health_proto_rawDescData</span>
}

var file_pkg_api_proto_health_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_pkg_api_proto_health_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_pkg_api_proto_health_proto_goTypes = []interface{}{
        (HealthStatus)(0),         // 0: rune.api.HealthStatus
        (HealthCheckType)(0),      // 1: rune.api.HealthCheckType
        (*HealthCheckResult)(nil), // 2: rune.api.HealthCheckResult
        (*ComponentHealth)(nil),   // 3: rune.api.ComponentHealth
        (*GetHealthRequest)(nil),  // 4: rune.api.GetHealthRequest
        (*GetHealthResponse)(nil), // 5: rune.api.GetHealthResponse
        (*Status)(nil),            // 6: rune.api.Status
}
var file_pkg_api_proto_health_proto_depIdxs = []int32{
        1, // 0: rune.api.HealthCheckResult.type:type_name -&gt; rune.api.HealthCheckType
        0, // 1: rune.api.HealthCheckResult.status:type_name -&gt; rune.api.HealthStatus
        0, // 2: rune.api.ComponentHealth.status:type_name -&gt; rune.api.HealthStatus
        2, // 3: rune.api.ComponentHealth.check_results:type_name -&gt; rune.api.HealthCheckResult
        3, // 4: rune.api.GetHealthResponse.components:type_name -&gt; rune.api.ComponentHealth
        6, // 5: rune.api.GetHealthResponse.status:type_name -&gt; rune.api.Status
        4, // 6: rune.api.HealthService.GetHealth:input_type -&gt; rune.api.GetHealthRequest
        5, // 7: rune.api.HealthService.GetHealth:output_type -&gt; rune.api.GetHealthResponse
        7, // [7:8] is the sub-list for method output_type
        6, // [6:7] is the sub-list for method input_type
        6, // [6:6] is the sub-list for extension type_name
        6, // [6:6] is the sub-list for extension extendee
        0, // [0:6] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_pkg_api_proto_health_proto_init() }</span>
func file_pkg_api_proto_health_proto_init() <span class="cov8" title="1">{
        if File_pkg_api_proto_health_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_pkg_api_proto_common_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_pkg_api_proto_health_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*HealthCheckResult); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_health_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ComponentHealth); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_health_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetHealthRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_health_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetHealthResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_pkg_api_proto_health_proto_rawDesc,
                        NumEnums:      2,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_pkg_api_proto_health_proto_goTypes,
                DependencyIndexes: file_pkg_api_proto_health_proto_depIdxs,
                EnumInfos:         file_pkg_api_proto_health_proto_enumTypes,
                MessageInfos:      file_pkg_api_proto_health_proto_msgTypes,
        }.Build()
        File_pkg_api_proto_health_proto = out.File
        file_pkg_api_proto_health_proto_rawDesc = nil
        file_pkg_api_proto_health_proto_goTypes = nil
        file_pkg_api_proto_health_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: pkg/api/proto/health.proto

/*
Package generated is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package generated

import (
        "context"
        "io"
        "net/http"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/v2/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = metadata.Join

func request_HealthService_GetHealth_0(ctx context.Context, marshaler runtime.Marshaler, client HealthServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq GetHealthRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetHealth(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_HealthService_GetHealth_0(ctx context.Context, marshaler runtime.Marshaler, server HealthServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq GetHealthRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetHealth(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

// RegisterHealthServiceHandlerServer registers the http handlers for service HealthService to "mux".
// UnaryRPC     :call HealthServiceServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterHealthServiceHandlerFromEndpoint instead.
func RegisterHealthServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server HealthServiceServer) error <span class="cov0" title="0">{

        mux.Handle("POST", pattern_HealthService_GetHealth_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/rune.api.HealthService/GetHealth", runtime.WithHTTPPathPattern("/rune.api.HealthService/GetHealth"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_HealthService_GetHealth_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_HealthService_GetHealth_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterHealthServiceHandlerFromEndpoint is same as RegisterHealthServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterHealthServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov8" title="1">{
        conn, err := grpc.DialContext(ctx, endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov8" title="1">return RegisterHealthServiceHandler(ctx, mux, conn)</span>
}

// RegisterHealthServiceHandler registers the http handlers for service HealthService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterHealthServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov8" title="1">{
        return RegisterHealthServiceHandlerClient(ctx, mux, NewHealthServiceClient(conn))
}</span>

// RegisterHealthServiceHandlerClient registers the http handlers for service HealthService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "HealthServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "HealthServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "HealthServiceClient" to call the correct interceptors.
func RegisterHealthServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client HealthServiceClient) error <span class="cov8" title="1">{

        mux.Handle("POST", pattern_HealthService_GetHealth_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.HealthService/GetHealth", runtime.WithHTTPPathPattern("/rune.api.HealthService/GetHealth"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_HealthService_GetHealth_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_HealthService_GetHealth_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov8" title="1">return nil</span>
}

var (
        pattern_HealthService_GetHealth_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.HealthService", "GetHealth"}, ""))
)

var (
        forward_HealthService_GetHealth_0 = runtime.ForwardResponseMessage
)
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.29.3
// source: pkg/api/proto/health.proto

package generated

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthServiceClient interface {
        // GetHealth retrieves health status of platform components.
        GetHealth(ctx context.Context, in *GetHealthRequest, opts ...grpc.CallOption) (*GetHealthResponse, error)
}

type healthServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient <span class="cov8" title="1">{
        return &amp;healthServiceClient{cc}
}</span>

func (c *healthServiceClient) GetHealth(ctx context.Context, in *GetHealthRequest, opts ...grpc.CallOption) (*GetHealthResponse, error) <span class="cov0" title="0">{
        out := new(GetHealthResponse)
        err := c.cc.Invoke(ctx, "/rune.api.HealthService/GetHealth", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// HealthServiceServer is the server API for HealthService service.
// All implementations must embed UnimplementedHealthServiceServer
// for forward compatibility
type HealthServiceServer interface {
        // GetHealth retrieves health status of platform components.
        GetHealth(context.Context, *GetHealthRequest) (*GetHealthResponse, error)
        mustEmbedUnimplementedHealthServiceServer()
}

// UnimplementedHealthServiceServer must be embedded to have forward compatible implementations.
type UnimplementedHealthServiceServer struct {
}

func (UnimplementedHealthServiceServer) GetHealth(context.Context, *GetHealthRequest) (*GetHealthResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetHealth not implemented")
}</span>
func (UnimplementedHealthServiceServer) mustEmbedUnimplementedHealthServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
        mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;HealthService_ServiceDesc, srv)
}</span>

func _HealthService_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetHealthRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(HealthServiceServer).GetHealth(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/rune.api.HealthService/GetHealth",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(HealthServiceServer).GetHealth(ctx, req.(*GetHealthRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "rune.api.HealthService",
        HandlerType: (*HealthServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetHealth",
                        Handler:    _HealthService_GetHealth_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "pkg/api/proto/health.proto",
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v5.29.3
// source: pkg/api/proto/instance.proto

package generated

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// InstanceStatus represents the current status of an instance.
type InstanceStatus int32

const (
        InstanceStatus_INSTANCE_STATUS_UNSPECIFIED InstanceStatus = 0
        InstanceStatus_INSTANCE_STATUS_PENDING     InstanceStatus = 1 // Instance is being created
        InstanceStatus_INSTANCE_STATUS_CREATED     InstanceStatus = 2 // Instance is created but not started
        InstanceStatus_INSTANCE_STATUS_STARTING    InstanceStatus = 3 // Instance is starting
        InstanceStatus_INSTANCE_STATUS_RUNNING     InstanceStatus = 4 // Instance is running
        InstanceStatus_INSTANCE_STATUS_STOPPING    InstanceStatus = 5 // Instance is stopping
        InstanceStatus_INSTANCE_STATUS_STOPPED     InstanceStatus = 6 // Instance has stopped
        InstanceStatus_INSTANCE_STATUS_FAILED      InstanceStatus = 7 // Instance failed to start or crashed
        InstanceStatus_INSTANCE_STATUS_EXITED      InstanceStatus = 8 // Instance exited
)

// Enum value maps for InstanceStatus.
var (
        InstanceStatus_name = map[int32]string{
                0: "INSTANCE_STATUS_UNSPECIFIED",
                1: "INSTANCE_STATUS_PENDING",
                2: "INSTANCE_STATUS_CREATED",
                3: "INSTANCE_STATUS_STARTING",
                4: "INSTANCE_STATUS_RUNNING",
                5: "INSTANCE_STATUS_STOPPING",
                6: "INSTANCE_STATUS_STOPPED",
                7: "INSTANCE_STATUS_FAILED",
                8: "INSTANCE_STATUS_EXITED",
        }
        InstanceStatus_value = map[string]int32{
                "INSTANCE_STATUS_UNSPECIFIED": 0,
                "INSTANCE_STATUS_PENDING":     1,
                "INSTANCE_STATUS_CREATED":     2,
                "INSTANCE_STATUS_STARTING":    3,
                "INSTANCE_STATUS_RUNNING":     4,
                "INSTANCE_STATUS_STOPPING":    5,
                "INSTANCE_STATUS_STOPPED":     6,
                "INSTANCE_STATUS_FAILED":      7,
                "INSTANCE_STATUS_EXITED":      8,
        }
)

func (x InstanceStatus) Enum() *InstanceStatus <span class="cov0" title="0">{
        p := new(InstanceStatus)
        *p = x
        return p
}</span>

func (x InstanceStatus) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (InstanceStatus) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_pkg_api_proto_instance_proto_enumTypes[0].Descriptor()
}</span>

func (InstanceStatus) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_pkg_api_proto_instance_proto_enumTypes[0]
}</span>

func (x InstanceStatus) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use InstanceStatus.Descriptor instead.
func (InstanceStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_instance_proto_rawDescGZIP(), []int{0}
}</span>

// Instance represents a running copy of a service.
type Instance struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Unique identifier for the instance
        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        // Runner type for the instance
        Runner string `protobuf:"bytes,2,opt,name=runner,proto3" json:"runner,omitempty"`
        // Namespace of the instance
        Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Human-readable name for the instance
        Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
        // ID of the service this instance belongs to
        ServiceId string `protobuf:"bytes,5,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
        // Name of the service this instance belongs to
        ServiceName string `protobuf:"bytes,6,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
        // ID of the node running this instance
        NodeId string `protobuf:"bytes,7,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
        // IP address assigned to this instance
        Ip string `protobuf:"bytes,8,opt,name=ip,proto3" json:"ip,omitempty"`
        // Status of the instance
        Status InstanceStatus `protobuf:"varint,9,opt,name=status,proto3,enum=rune.api.InstanceStatus" json:"status,omitempty"`
        // Detailed status information
        StatusMessage string `protobuf:"bytes,10,opt,name=status_message,json=statusMessage,proto3" json:"status_message,omitempty"`
        // Container ID or process ID
        ContainerId string `protobuf:"bytes,11,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
        // Process ID for process runner
        Pid int32 `protobuf:"varint,12,opt,name=pid,proto3" json:"pid,omitempty"`
        // Creation timestamp (in RFC 3339 format)
        CreatedAt string `protobuf:"bytes,13,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        // Last update timestamp (in RFC 3339 format)
        UpdatedAt string `protobuf:"bytes,14,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
        // Resource usage
        Resources *Resources `protobuf:"bytes,15,opt,name=resources,proto3" json:"resources,omitempty"`
}

func (x *Instance) Reset() <span class="cov0" title="0">{
        *x = Instance{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Instance) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Instance) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Instance) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Instance.ProtoReflect.Descriptor instead.
func (*Instance) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_instance_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Instance) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Instance) GetRunner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Runner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Instance) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Instance) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Instance) GetServiceId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServiceId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Instance) GetServiceName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServiceName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Instance) GetNodeId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NodeId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Instance) GetIp() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ip
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Instance) GetStatus() InstanceStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return InstanceStatus_INSTANCE_STATUS_UNSPECIFIED</span>
}

func (x *Instance) GetStatusMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StatusMessage
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Instance) GetContainerId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ContainerId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Instance) GetPid() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pid
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Instance) GetCreatedAt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Instance) GetUpdatedAt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Instance) GetResources() *Resources <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Resources
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetInstanceRequest requests a specific instance.
type GetInstanceRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // ID of the instance
        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        // Namespace of the instance
        Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (x *GetInstanceRequest) Reset() <span class="cov0" title="0">{
        *x = GetInstanceRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetInstanceRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetInstanceRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetInstanceRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetInstanceRequest.ProtoReflect.Descriptor instead.
func (*GetInstanceRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_instance_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetInstanceRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetInstanceRequest) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// InstanceResponse returns an instance or status.
type InstanceResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The instance, if successful
        Instance *Instance `protobuf:"bytes,1,opt,name=instance,proto3" json:"instance,omitempty"`
        // Status message
        Status *Status `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *InstanceResponse) Reset() <span class="cov0" title="0">{
        *x = InstanceResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *InstanceResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*InstanceResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *InstanceResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use InstanceResponse.ProtoReflect.Descriptor instead.
func (*InstanceResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_instance_proto_rawDescGZIP(), []int{2}
}</span>

func (x *InstanceResponse) GetInstance() *Instance <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Instance
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *InstanceResponse) GetStatus() *Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ListInstancesRequest requests a list of instances.
type ListInstancesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Filter by service name
        ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
        // Filter by namespace
        Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Filter by node ID
        NodeId string `protobuf:"bytes,3,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
        // Filter by status
        Status InstanceStatus `protobuf:"varint,4,opt,name=status,proto3,enum=rune.api.InstanceStatus" json:"status,omitempty"`
        // Paging parameters
        Paging *PagingParams `protobuf:"bytes,5,opt,name=paging,proto3" json:"paging,omitempty"`
        // Filter instances by label
        LabelSelector map[string]string `protobuf:"bytes,6,rep,name=label_selector,json=labelSelector,proto3" json:"label_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Filter instances by field
        FieldSelector map[string]string `protobuf:"bytes,7,rep,name=field_selector,json=fieldSelector,proto3" json:"field_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *ListInstancesRequest) Reset() <span class="cov0" title="0">{
        *x = ListInstancesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListInstancesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListInstancesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListInstancesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListInstancesRequest.ProtoReflect.Descriptor instead.
func (*ListInstancesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_instance_proto_rawDescGZIP(), []int{3}
}</span>

func (x *ListInstancesRequest) GetServiceName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServiceName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ListInstancesRequest) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ListInstancesRequest) GetNodeId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NodeId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ListInstancesRequest) GetStatus() InstanceStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return InstanceStatus_INSTANCE_STATUS_UNSPECIFIED</span>
}

func (x *ListInstancesRequest) GetPaging() *PagingParams <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Paging
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListInstancesRequest) GetLabelSelector() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LabelSelector
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListInstancesRequest) GetFieldSelector() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FieldSelector
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ListInstancesResponse returns a list of instances.
type ListInstancesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // List of instances
        Instances []*Instance `protobuf:"bytes,1,rep,name=instances,proto3" json:"instances,omitempty"`
        // Status message
        Status *Status `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
        // Paging information for continuation
        Paging *PagingParams `protobuf:"bytes,3,opt,name=paging,proto3" json:"paging,omitempty"`
}

func (x *ListInstancesResponse) Reset() <span class="cov0" title="0">{
        *x = ListInstancesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListInstancesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListInstancesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListInstancesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListInstancesResponse.ProtoReflect.Descriptor instead.
func (*ListInstancesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_instance_proto_rawDescGZIP(), []int{4}
}</span>

func (x *ListInstancesResponse) GetInstances() []*Instance <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Instances
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListInstancesResponse) GetStatus() *Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListInstancesResponse) GetPaging() *PagingParams <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Paging
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// InstanceActionRequest requests an action on an instance.
type InstanceActionRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // ID of the instance
        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        // Timeout in seconds for the action
        TimeoutSeconds int32 `protobuf:"varint,2,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
        // Force the action if applicable
        Force bool `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
}

func (x *InstanceActionRequest) Reset() <span class="cov0" title="0">{
        *x = InstanceActionRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *InstanceActionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*InstanceActionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *InstanceActionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use InstanceActionRequest.ProtoReflect.Descriptor instead.
func (*InstanceActionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_instance_proto_rawDescGZIP(), []int{5}
}</span>

func (x *InstanceActionRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *InstanceActionRequest) GetTimeoutSeconds() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TimeoutSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *InstanceActionRequest) GetForce() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Force
        }</span>
        <span class="cov0" title="0">return false</span>
}

// WatchInstancesRequest requests to watch instances for changes.
type WatchInstancesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Namespace to watch instances from (optional, default: "default", use "*" for all namespaces)
        Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Service ID to filter by
        ServiceId string `protobuf:"bytes,2,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
        // Filter instances by label
        LabelSelector map[string]string `protobuf:"bytes,3,rep,name=label_selector,json=labelSelector,proto3" json:"label_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Filter instances by field
        FieldSelector map[string]string `protobuf:"bytes,4,rep,name=field_selector,json=fieldSelector,proto3" json:"field_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *WatchInstancesRequest) Reset() <span class="cov0" title="0">{
        *x = WatchInstancesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *WatchInstancesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WatchInstancesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WatchInstancesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WatchInstancesRequest.ProtoReflect.Descriptor instead.
func (*WatchInstancesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_instance_proto_rawDescGZIP(), []int{6}
}</span>

func (x *WatchInstancesRequest) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *WatchInstancesRequest) GetServiceId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServiceId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *WatchInstancesRequest) GetLabelSelector() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LabelSelector
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *WatchInstancesRequest) GetFieldSelector() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FieldSelector
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WatchInstancesResponse returns instance change events.
type WatchInstancesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The instance that changed
        Instance *Instance `protobuf:"bytes,1,opt,name=instance,proto3" json:"instance,omitempty"`
        // Type of event (added, modified, deleted)
        EventType EventType `protobuf:"varint,2,opt,name=event_type,json=eventType,proto3,enum=rune.api.EventType" json:"event_type,omitempty"`
        // Status message
        Status *Status `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *WatchInstancesResponse) Reset() <span class="cov0" title="0">{
        *x = WatchInstancesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *WatchInstancesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WatchInstancesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WatchInstancesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_instance_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WatchInstancesResponse.ProtoReflect.Descriptor instead.
func (*WatchInstancesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_instance_proto_rawDescGZIP(), []int{7}
}</span>

func (x *WatchInstancesResponse) GetInstance() *Instance <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Instance
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *WatchInstancesResponse) GetEventType() EventType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EventType
        }</span>
        <span class="cov0" title="0">return EventType_EVENT_TYPE_UNSPECIFIED</span>
}

func (x *WatchInstancesResponse) GetStatus() *Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_pkg_api_proto_instance_proto protoreflect.FileDescriptor

var file_pkg_api_proto_instance_proto_rawDesc = []byte{
        0x0a, 0x1c, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f,
        0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08,
        0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x1a, 0x1a, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70,
        0x69, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x22, 0xce, 0x03, 0x0a, 0x08, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63,
        0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69,
        0x64, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x75, 0x6e, 0x6e, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x06, 0x72, 0x75, 0x6e, 0x6e, 0x65, 0x72, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d,
        0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61,
        0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x09, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x17, 0x0a,
        0x07, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
        0x6e, 0x6f, 0x64, 0x65, 0x49, 0x64, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x70, 0x18, 0x08, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x02, 0x69, 0x70, 0x12, 0x30, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
        0x18, 0x09, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70,
        0x69, 0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
        0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x73, 0x74, 0x61, 0x74,
        0x75, 0x73, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0d, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12,
        0x21, 0x0a, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18,
        0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
        0x49, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x70, 0x69, 0x64, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x03, 0x70, 0x69, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f,
        0x61, 0x74, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x64, 0x41, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61,
        0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64,
        0x41, 0x74, 0x12, 0x31, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18,
        0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69,
        0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x52, 0x09, 0x72, 0x65, 0x73, 0x6f,
        0x75, 0x72, 0x63, 0x65, 0x73, 0x22, 0x42, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x49, 0x6e, 0x73, 0x74,
        0x61, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69,
        0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x6e,
        0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
        0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x22, 0x6c, 0x0a, 0x10, 0x49, 0x6e, 0x73,
        0x74, 0x61, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2e, 0x0a,
        0x08, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x12, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61,
        0x6e, 0x63, 0x65, 0x52, 0x08, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x28, 0x0a,
        0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e,
        0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52,
        0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x8a, 0x04, 0x0a, 0x14, 0x4c, 0x69, 0x73, 0x74,
        0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x21, 0x0a, 0x0c, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4e,
        0x61, 0x6d, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63,
        0x65, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x06, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x64, 0x12, 0x30, 0x0a, 0x06, 0x73, 0x74,
        0x61, 0x74, 0x75, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x72, 0x75, 0x6e,
        0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x53, 0x74,
        0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x2e, 0x0a, 0x06,
        0x70, 0x61, 0x67, 0x69, 0x6e, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x72,
        0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x50, 0x61, 0x67, 0x69, 0x6e, 0x67, 0x50, 0x61,
        0x72, 0x61, 0x6d, 0x73, 0x52, 0x06, 0x70, 0x61, 0x67, 0x69, 0x6e, 0x67, 0x12, 0x58, 0x0a, 0x0e,
        0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x06,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e,
        0x4c, 0x69, 0x73, 0x74, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0d, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x65,
        0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x58, 0x0a, 0x0e, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x5f,
        0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x31,
        0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x6e,
        0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x46,
        0x69, 0x65, 0x6c, 0x64, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x0d, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72,
        0x1a, 0x40, 0x0a, 0x12, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
        0x72, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,
        0x38, 0x01, 0x1a, 0x40, 0x0a, 0x12, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x53, 0x65, 0x6c, 0x65, 0x63,
        0x74, 0x6f, 0x72, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x22, 0xa3, 0x01, 0x0a, 0x15, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x6e, 0x73,
        0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x30,
        0x0a, 0x09, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x12, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x6e, 0x73,
        0x74, 0x61, 0x6e, 0x63, 0x65, 0x52, 0x09, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x73,
        0x12, 0x28, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x10, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x74, 0x61, 0x74,
        0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x2e, 0x0a, 0x06, 0x70, 0x61,
        0x67, 0x69, 0x6e, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x72, 0x75, 0x6e,
        0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x50, 0x61, 0x67, 0x69, 0x6e, 0x67, 0x50, 0x61, 0x72, 0x61,
        0x6d, 0x73, 0x52, 0x06, 0x70, 0x61, 0x67, 0x69, 0x6e, 0x67, 0x22, 0x66, 0x0a, 0x15, 0x49, 0x6e,
        0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x02, 0x69, 0x64, 0x12, 0x27, 0x0a, 0x0f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73,
        0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0e, 0x74, 0x69,
        0x6d, 0x65, 0x6f, 0x75, 0x74, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x12, 0x14, 0x0a, 0x05,
        0x66, 0x6f, 0x72, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x66, 0x6f, 0x72,
        0x63, 0x65, 0x22, 0x8e, 0x03, 0x0a, 0x15, 0x57, 0x61, 0x74, 0x63, 0x68, 0x49, 0x6e, 0x73, 0x74,
        0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1c, 0x0a, 0x09,
        0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64, 0x12, 0x59, 0x0a, 0x0e, 0x6c, 0x61, 0x62,
        0x65, 0x6c, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x32, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x57, 0x61, 0x74,
        0x63, 0x68, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0d, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x65, 0x6c, 0x65,
        0x63, 0x74, 0x6f, 0x72, 0x12, 0x59, 0x0a, 0x0e, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x5f, 0x73, 0x65,
        0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x72,
        0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x57, 0x61, 0x74, 0x63, 0x68, 0x49, 0x6e, 0x73,
        0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x46, 0x69,
        0x65, 0x6c, 0x64, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x45, 0x6e, 0x74, 0x72, 0x79,
        0x52, 0x0d, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x1a,
        0x40, 0x0a, 0x12, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
        0x01, 0x1a, 0x40, 0x0a, 0x12, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,
        0x02, 0x38, 0x01, 0x22, 0xa6, 0x01, 0x0a, 0x16, 0x57, 0x61, 0x74, 0x63, 0x68, 0x49, 0x6e, 0x73,
        0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2e,
        0x0a, 0x08, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x12, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x6e, 0x73, 0x74,
        0x61, 0x6e, 0x63, 0x65, 0x52, 0x08, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x32,
        0x0a, 0x0a, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x0e, 0x32, 0x13, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x45, 0x76,
        0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x09, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x79,
        0x70, 0x65, 0x12, 0x28, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x10, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x74,
        0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2a, 0x99, 0x02, 0x0a,
        0x0e, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12,
        0x1f, 0x0a, 0x1b, 0x49, 0x4e, 0x53, 0x54, 0x41, 0x4e, 0x43, 0x45, 0x5f, 0x53, 0x54, 0x41, 0x54,
        0x55, 0x53, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00,
        0x12, 0x1b, 0x0a, 0x17, 0x49, 0x4e, 0x53, 0x54, 0x41, 0x4e, 0x43, 0x45, 0x5f, 0x53, 0x54, 0x41,
        0x54, 0x55, 0x53, 0x5f, 0x50, 0x45, 0x4e, 0x44, 0x49, 0x4e, 0x47, 0x10, 0x01, 0x12, 0x1b, 0x0a,
        0x17, 0x49, 0x4e, 0x53, 0x54, 0x41, 0x4e, 0x43, 0x45, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53,
        0x5f, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x44, 0x10, 0x02, 0x12, 0x1c, 0x0a, 0x18, 0x49, 0x4e,
        0x53, 0x54, 0x41, 0x4e, 0x43, 0x45, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x53, 0x54,
        0x41, 0x52, 0x54, 0x49, 0x4e, 0x47, 0x10, 0x03, 0x12, 0x1b, 0x0a, 0x17, 0x49, 0x4e, 0x53, 0x54,
        0x41, 0x4e, 0x43, 0x45, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x52, 0x55, 0x4e, 0x4e,
        0x49, 0x4e, 0x47, 0x10, 0x04, 0x12, 0x1c, 0x0a, 0x18, 0x49, 0x4e, 0x53, 0x54, 0x41, 0x4e, 0x43,
        0x45, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x53, 0x54, 0x4f, 0x50, 0x50, 0x49, 0x4e,
        0x47, 0x10, 0x05, 0x12, 0x1b, 0x0a, 0x17, 0x49, 0x4e, 0x53, 0x54, 0x41, 0x4e, 0x43, 0x45, 0x5f,
        0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x53, 0x54, 0x4f, 0x50, 0x50, 0x45, 0x44, 0x10, 0x06,
        0x12, 0x1a, 0x0a, 0x16, 0x49, 0x4e, 0x53, 0x54, 0x41, 0x4e, 0x43, 0x45, 0x5f, 0x53, 0x54, 0x41,
        0x54, 0x55, 0x53, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x07, 0x12, 0x1a, 0x0a, 0x16,
        0x49, 0x4e, 0x53, 0x54, 0x41, 0x4e, 0x43, 0x45, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f,
        0x45, 0x58, 0x49, 0x54, 0x45, 0x44, 0x10, 0x08, 0x32, 0xee, 0x03, 0x0a, 0x0f, 0x49, 0x6e, 0x73,
        0x74, 0x61, 0x6e, 0x63, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x47, 0x0a, 0x0b,
        0x47, 0x65, 0x74, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x1c, 0x2e, 0x72, 0x75,
        0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x47, 0x65, 0x74, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e,
        0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x72, 0x75, 0x6e, 0x65,
        0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x50, 0x0a, 0x0d, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x6e, 0x73,
        0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x1e, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70,
        0x69, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70,
        0x69, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4c, 0x0a, 0x0d, 0x53, 0x74, 0x61, 0x72, 0x74,
        0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x1f, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e,
        0x61, 0x70, 0x69, 0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x41, 0x63, 0x74, 0x69,
        0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x72, 0x75, 0x6e, 0x65,
        0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4b, 0x0a, 0x0c, 0x53, 0x74, 0x6f, 0x70, 0x49, 0x6e, 0x73,
        0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x1f, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69,
        0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70,
        0x69, 0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x4e, 0x0a, 0x0f, 0x52, 0x65, 0x73, 0x74, 0x61, 0x72, 0x74, 0x49, 0x6e, 0x73,
        0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x1f, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69,
        0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70,
        0x69, 0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x55, 0x0a, 0x0e, 0x57, 0x61, 0x74, 0x63, 0x68, 0x49, 0x6e, 0x73, 0x74, 0x61,
        0x6e, 0x63, 0x65, 0x73, 0x12, 0x1f, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e,
        0x57, 0x61, 0x74, 0x63, 0x68, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69,
        0x2e, 0x57, 0x61, 0x74, 0x63, 0x68, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x30, 0x01, 0x42, 0x2a, 0x5a, 0x28, 0x67, 0x69, 0x74,
        0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x7a, 0x62, 0x69, 0x6c, 0x6c, 0x2f, 0x72,
        0x75, 0x6e, 0x65, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x67, 0x65, 0x6e, 0x65,
        0x72, 0x61, 0x74, 0x65, 0x64, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_pkg_api_proto_instance_proto_rawDescOnce sync.Once
        file_pkg_api_proto_instance_proto_rawDescData = file_pkg_api_proto_instance_proto_rawDesc
)

func file_pkg_api_proto_instance_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_pkg_api_proto_instance_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_pkg_api_proto_instance_proto_rawDescData = protoimpl.X.CompressGZIP(file_pkg_api_proto_instance_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_pkg_api_proto_instance_proto_rawDescData</span>
}

var file_pkg_api_proto_instance_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_pkg_api_proto_instance_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_pkg_api_proto_instance_proto_goTypes = []interface{}{
        (InstanceStatus)(0),            // 0: rune.api.InstanceStatus
        (*Instance)(nil),               // 1: rune.api.Instance
        (*GetInstanceRequest)(nil),     // 2: rune.api.GetInstanceRequest
        (*InstanceResponse)(nil),       // 3: rune.api.InstanceResponse
        (*ListInstancesRequest)(nil),   // 4: rune.api.ListInstancesRequest
        (*ListInstancesResponse)(nil),  // 5: rune.api.ListInstancesResponse
        (*InstanceActionRequest)(nil),  // 6: rune.api.InstanceActionRequest
        (*WatchInstancesRequest)(nil),  // 7: rune.api.WatchInstancesRequest
        (*WatchInstancesResponse)(nil), // 8: rune.api.WatchInstancesResponse
        nil,                            // 9: rune.api.ListInstancesRequest.LabelSelectorEntry
        nil,                            // 10: rune.api.ListInstancesRequest.FieldSelectorEntry
        nil,                            // 11: rune.api.WatchInstancesRequest.LabelSelectorEntry
        nil,                            // 12: rune.api.WatchInstancesRequest.FieldSelectorEntry
        (*Resources)(nil),              // 13: rune.api.Resources
        (*Status)(nil),                 // 14: rune.api.Status
        (*PagingParams)(nil),           // 15: rune.api.PagingParams
        (EventType)(0),                 // 16: rune.api.EventType
}
var file_pkg_api_proto_instance_proto_depIdxs = []int32{
        0,  // 0: rune.api.Instance.status:type_name -&gt; rune.api.InstanceStatus
        13, // 1: rune.api.Instance.resources:type_name -&gt; rune.api.Resources
        1,  // 2: rune.api.InstanceResponse.instance:type_name -&gt; rune.api.Instance
        14, // 3: rune.api.InstanceResponse.status:type_name -&gt; rune.api.Status
        0,  // 4: rune.api.ListInstancesRequest.status:type_name -&gt; rune.api.InstanceStatus
        15, // 5: rune.api.ListInstancesRequest.paging:type_name -&gt; rune.api.PagingParams
        9,  // 6: rune.api.ListInstancesRequest.label_selector:type_name -&gt; rune.api.ListInstancesRequest.LabelSelectorEntry
        10, // 7: rune.api.ListInstancesRequest.field_selector:type_name -&gt; rune.api.ListInstancesRequest.FieldSelectorEntry
        1,  // 8: rune.api.ListInstancesResponse.instances:type_name -&gt; rune.api.Instance
        14, // 9: rune.api.ListInstancesResponse.status:type_name -&gt; rune.api.Status
        15, // 10: rune.api.ListInstancesResponse.paging:type_name -&gt; rune.api.PagingParams
        11, // 11: rune.api.WatchInstancesRequest.label_selector:type_name -&gt; rune.api.WatchInstancesRequest.LabelSelectorEntry
        12, // 12: rune.api.WatchInstancesRequest.field_selector:type_name -&gt; rune.api.WatchInstancesRequest.FieldSelectorEntry
        1,  // 13: rune.api.WatchInstancesResponse.instance:type_name -&gt; rune.api.Instance
        16, // 14: rune.api.WatchInstancesResponse.event_type:type_name -&gt; rune.api.EventType
        14, // 15: rune.api.WatchInstancesResponse.status:type_name -&gt; rune.api.Status
        2,  // 16: rune.api.InstanceService.GetInstance:input_type -&gt; rune.api.GetInstanceRequest
        4,  // 17: rune.api.InstanceService.ListInstances:input_type -&gt; rune.api.ListInstancesRequest
        6,  // 18: rune.api.InstanceService.StartInstance:input_type -&gt; rune.api.InstanceActionRequest
        6,  // 19: rune.api.InstanceService.StopInstance:input_type -&gt; rune.api.InstanceActionRequest
        6,  // 20: rune.api.InstanceService.RestartInstance:input_type -&gt; rune.api.InstanceActionRequest
        7,  // 21: rune.api.InstanceService.WatchInstances:input_type -&gt; rune.api.WatchInstancesRequest
        3,  // 22: rune.api.InstanceService.GetInstance:output_type -&gt; rune.api.InstanceResponse
        5,  // 23: rune.api.InstanceService.ListInstances:output_type -&gt; rune.api.ListInstancesResponse
        3,  // 24: rune.api.InstanceService.StartInstance:output_type -&gt; rune.api.InstanceResponse
        3,  // 25: rune.api.InstanceService.StopInstance:output_type -&gt; rune.api.InstanceResponse
        3,  // 26: rune.api.InstanceService.RestartInstance:output_type -&gt; rune.api.InstanceResponse
        8,  // 27: rune.api.InstanceService.WatchInstances:output_type -&gt; rune.api.WatchInstancesResponse
        22, // [22:28] is the sub-list for method output_type
        16, // [16:22] is the sub-list for method input_type
        16, // [16:16] is the sub-list for extension type_name
        16, // [16:16] is the sub-list for extension extendee
        0,  // [0:16] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_pkg_api_proto_instance_proto_init() }</span>
func file_pkg_api_proto_instance_proto_init() <span class="cov8" title="1">{
        if File_pkg_api_proto_instance_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_pkg_api_proto_common_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_pkg_api_proto_instance_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Instance); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_instance_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetInstanceRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_instance_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*InstanceResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_instance_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListInstancesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_instance_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListInstancesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_instance_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*InstanceActionRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_instance_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*WatchInstancesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_instance_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*WatchInstancesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_pkg_api_proto_instance_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   12,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_pkg_api_proto_instance_proto_goTypes,
                DependencyIndexes: file_pkg_api_proto_instance_proto_depIdxs,
                EnumInfos:         file_pkg_api_proto_instance_proto_enumTypes,
                MessageInfos:      file_pkg_api_proto_instance_proto_msgTypes,
        }.Build()
        File_pkg_api_proto_instance_proto = out.File
        file_pkg_api_proto_instance_proto_rawDesc = nil
        file_pkg_api_proto_instance_proto_goTypes = nil
        file_pkg_api_proto_instance_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: pkg/api/proto/instance.proto

/*
Package generated is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package generated

import (
        "context"
        "io"
        "net/http"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/v2/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = metadata.Join

func request_InstanceService_GetInstance_0(ctx context.Context, marshaler runtime.Marshaler, client InstanceServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq GetInstanceRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetInstance(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_InstanceService_GetInstance_0(ctx context.Context, marshaler runtime.Marshaler, server InstanceServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq GetInstanceRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetInstance(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_InstanceService_ListInstances_0(ctx context.Context, marshaler runtime.Marshaler, client InstanceServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ListInstancesRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.ListInstances(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_InstanceService_ListInstances_0(ctx context.Context, marshaler runtime.Marshaler, server InstanceServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ListInstancesRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.ListInstances(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_InstanceService_StartInstance_0(ctx context.Context, marshaler runtime.Marshaler, client InstanceServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq InstanceActionRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.StartInstance(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_InstanceService_StartInstance_0(ctx context.Context, marshaler runtime.Marshaler, server InstanceServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq InstanceActionRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.StartInstance(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_InstanceService_StopInstance_0(ctx context.Context, marshaler runtime.Marshaler, client InstanceServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq InstanceActionRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.StopInstance(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_InstanceService_StopInstance_0(ctx context.Context, marshaler runtime.Marshaler, server InstanceServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq InstanceActionRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.StopInstance(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_InstanceService_RestartInstance_0(ctx context.Context, marshaler runtime.Marshaler, client InstanceServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq InstanceActionRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.RestartInstance(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_InstanceService_RestartInstance_0(ctx context.Context, marshaler runtime.Marshaler, server InstanceServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq InstanceActionRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.RestartInstance(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_InstanceService_WatchInstances_0(ctx context.Context, marshaler runtime.Marshaler, client InstanceServiceClient, req *http.Request, pathParams map[string]string) (InstanceService_WatchInstancesClient, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq WatchInstancesRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">stream, err := client.WatchInstances(ctx, &amp;protoReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, err
        }</span>
        <span class="cov0" title="0">header, err := stream.Header()
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, err
        }</span>
        <span class="cov0" title="0">metadata.HeaderMD = header
        return stream, metadata, nil</span>

}

// RegisterInstanceServiceHandlerServer registers the http handlers for service InstanceService to "mux".
// UnaryRPC     :call InstanceServiceServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterInstanceServiceHandlerFromEndpoint instead.
func RegisterInstanceServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server InstanceServiceServer) error <span class="cov0" title="0">{

        mux.Handle("POST", pattern_InstanceService_GetInstance_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/rune.api.InstanceService/GetInstance", runtime.WithHTTPPathPattern("/rune.api.InstanceService/GetInstance"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_InstanceService_GetInstance_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_InstanceService_GetInstance_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("POST", pattern_InstanceService_ListInstances_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/rune.api.InstanceService/ListInstances", runtime.WithHTTPPathPattern("/rune.api.InstanceService/ListInstances"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_InstanceService_ListInstances_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_InstanceService_ListInstances_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("POST", pattern_InstanceService_StartInstance_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/rune.api.InstanceService/StartInstance", runtime.WithHTTPPathPattern("/rune.api.InstanceService/StartInstance"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_InstanceService_StartInstance_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_InstanceService_StartInstance_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("POST", pattern_InstanceService_StopInstance_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/rune.api.InstanceService/StopInstance", runtime.WithHTTPPathPattern("/rune.api.InstanceService/StopInstance"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_InstanceService_StopInstance_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_InstanceService_StopInstance_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("POST", pattern_InstanceService_RestartInstance_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/rune.api.InstanceService/RestartInstance", runtime.WithHTTPPathPattern("/rune.api.InstanceService/RestartInstance"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_InstanceService_RestartInstance_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_InstanceService_RestartInstance_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("POST", pattern_InstanceService_WatchInstances_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                err := status.Error(codes.Unimplemented, "streaming calls are not yet supported in the in-process transport")
                _, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                return
        }</span>)

        <span class="cov0" title="0">return nil</span>
}

// RegisterInstanceServiceHandlerFromEndpoint is same as RegisterInstanceServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterInstanceServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov8" title="1">{
        conn, err := grpc.DialContext(ctx, endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov8" title="1">return RegisterInstanceServiceHandler(ctx, mux, conn)</span>
}

// RegisterInstanceServiceHandler registers the http handlers for service InstanceService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterInstanceServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov8" title="1">{
        return RegisterInstanceServiceHandlerClient(ctx, mux, NewInstanceServiceClient(conn))
}</span>

// RegisterInstanceServiceHandlerClient registers the http handlers for service InstanceService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "InstanceServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "InstanceServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "InstanceServiceClient" to call the correct interceptors.
func RegisterInstanceServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client InstanceServiceClient) error <span class="cov8" title="1">{

        mux.Handle("POST", pattern_InstanceService_GetInstance_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.InstanceService/GetInstance", runtime.WithHTTPPathPattern("/rune.api.InstanceService/GetInstance"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_InstanceService_GetInstance_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_InstanceService_GetInstance_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov8" title="1">mux.Handle("POST", pattern_InstanceService_ListInstances_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.InstanceService/ListInstances", runtime.WithHTTPPathPattern("/rune.api.InstanceService/ListInstances"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_InstanceService_ListInstances_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_InstanceService_ListInstances_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov8" title="1">mux.Handle("POST", pattern_InstanceService_StartInstance_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.InstanceService/StartInstance", runtime.WithHTTPPathPattern("/rune.api.InstanceService/StartInstance"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_InstanceService_StartInstance_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_InstanceService_StartInstance_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov8" title="1">mux.Handle("POST", pattern_InstanceService_StopInstance_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.InstanceService/StopInstance", runtime.WithHTTPPathPattern("/rune.api.InstanceService/StopInstance"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_InstanceService_StopInstance_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_InstanceService_StopInstance_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov8" title="1">mux.Handle("POST", pattern_InstanceService_RestartInstance_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.InstanceService/RestartInstance", runtime.WithHTTPPathPattern("/rune.api.InstanceService/RestartInstance"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_InstanceService_RestartInstance_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_InstanceService_RestartInstance_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov8" title="1">mux.Handle("POST", pattern_InstanceService_WatchInstances_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.InstanceService/WatchInstances", runtime.WithHTTPPathPattern("/rune.api.InstanceService/WatchInstances"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_InstanceService_WatchInstances_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_InstanceService_WatchInstances_0(annotatedContext, mux, outboundMarshaler, w, req, func() (proto.Message, error) </span><span class="cov0" title="0">{ return resp.Recv() }</span>, mux.GetForwardResponseOptions()...)

        })

        <span class="cov8" title="1">return nil</span>
}

var (
        pattern_InstanceService_GetInstance_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.InstanceService", "GetInstance"}, ""))

        pattern_InstanceService_ListInstances_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.InstanceService", "ListInstances"}, ""))

        pattern_InstanceService_StartInstance_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.InstanceService", "StartInstance"}, ""))

        pattern_InstanceService_StopInstance_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.InstanceService", "StopInstance"}, ""))

        pattern_InstanceService_RestartInstance_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.InstanceService", "RestartInstance"}, ""))

        pattern_InstanceService_WatchInstances_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.InstanceService", "WatchInstances"}, ""))
)

var (
        forward_InstanceService_GetInstance_0 = runtime.ForwardResponseMessage

        forward_InstanceService_ListInstances_0 = runtime.ForwardResponseMessage

        forward_InstanceService_StartInstance_0 = runtime.ForwardResponseMessage

        forward_InstanceService_StopInstance_0 = runtime.ForwardResponseMessage

        forward_InstanceService_RestartInstance_0 = runtime.ForwardResponseMessage

        forward_InstanceService_WatchInstances_0 = runtime.ForwardResponseStream
)
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.29.3
// source: pkg/api/proto/instance.proto

package generated

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// InstanceServiceClient is the client API for InstanceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstanceServiceClient interface {
        // GetInstance retrieves an instance by ID.
        GetInstance(ctx context.Context, in *GetInstanceRequest, opts ...grpc.CallOption) (*InstanceResponse, error)
        // ListInstances lists instances with filtering.
        ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error)
        // StartInstance starts an instance.
        StartInstance(ctx context.Context, in *InstanceActionRequest, opts ...grpc.CallOption) (*InstanceResponse, error)
        // StopInstance stops an instance.
        StopInstance(ctx context.Context, in *InstanceActionRequest, opts ...grpc.CallOption) (*InstanceResponse, error)
        // RestartInstance restarts an instance.
        RestartInstance(ctx context.Context, in *InstanceActionRequest, opts ...grpc.CallOption) (*InstanceResponse, error)
        // WatchInstances watches instances for changes.
        WatchInstances(ctx context.Context, in *WatchInstancesRequest, opts ...grpc.CallOption) (InstanceService_WatchInstancesClient, error)
}

type instanceServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewInstanceServiceClient(cc grpc.ClientConnInterface) InstanceServiceClient <span class="cov8" title="1">{
        return &amp;instanceServiceClient{cc}
}</span>

func (c *instanceServiceClient) GetInstance(ctx context.Context, in *GetInstanceRequest, opts ...grpc.CallOption) (*InstanceResponse, error) <span class="cov0" title="0">{
        out := new(InstanceResponse)
        err := c.cc.Invoke(ctx, "/rune.api.InstanceService/GetInstance", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *instanceServiceClient) ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error) <span class="cov0" title="0">{
        out := new(ListInstancesResponse)
        err := c.cc.Invoke(ctx, "/rune.api.InstanceService/ListInstances", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *instanceServiceClient) StartInstance(ctx context.Context, in *InstanceActionRequest, opts ...grpc.CallOption) (*InstanceResponse, error) <span class="cov0" title="0">{
        out := new(InstanceResponse)
        err := c.cc.Invoke(ctx, "/rune.api.InstanceService/StartInstance", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *instanceServiceClient) StopInstance(ctx context.Context, in *InstanceActionRequest, opts ...grpc.CallOption) (*InstanceResponse, error) <span class="cov0" title="0">{
        out := new(InstanceResponse)
        err := c.cc.Invoke(ctx, "/rune.api.InstanceService/StopInstance", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *instanceServiceClient) RestartInstance(ctx context.Context, in *InstanceActionRequest, opts ...grpc.CallOption) (*InstanceResponse, error) <span class="cov0" title="0">{
        out := new(InstanceResponse)
        err := c.cc.Invoke(ctx, "/rune.api.InstanceService/RestartInstance", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *instanceServiceClient) WatchInstances(ctx context.Context, in *WatchInstancesRequest, opts ...grpc.CallOption) (InstanceService_WatchInstancesClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;InstanceService_ServiceDesc.Streams[0], "/rune.api.InstanceService/WatchInstances", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;instanceServiceWatchInstancesClient{stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

type InstanceService_WatchInstancesClient interface {
        Recv() (*WatchInstancesResponse, error)
        grpc.ClientStream
}

type instanceServiceWatchInstancesClient struct {
        grpc.ClientStream
}

func (x *instanceServiceWatchInstancesClient) Recv() (*WatchInstancesResponse, error) <span class="cov0" title="0">{
        m := new(WatchInstancesResponse)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// InstanceServiceServer is the server API for InstanceService service.
// All implementations must embed UnimplementedInstanceServiceServer
// for forward compatibility
type InstanceServiceServer interface {
        // GetInstance retrieves an instance by ID.
        GetInstance(context.Context, *GetInstanceRequest) (*InstanceResponse, error)
        // ListInstances lists instances with filtering.
        ListInstances(context.Context, *ListInstancesRequest) (*ListInstancesResponse, error)
        // StartInstance starts an instance.
        StartInstance(context.Context, *InstanceActionRequest) (*InstanceResponse, error)
        // StopInstance stops an instance.
        StopInstance(context.Context, *InstanceActionRequest) (*InstanceResponse, error)
        // RestartInstance restarts an instance.
        RestartInstance(context.Context, *InstanceActionRequest) (*InstanceResponse, error)
        // WatchInstances watches instances for changes.
        WatchInstances(*WatchInstancesRequest, InstanceService_WatchInstancesServer) error
        mustEmbedUnimplementedInstanceServiceServer()
}

// UnimplementedInstanceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInstanceServiceServer struct {
}

func (UnimplementedInstanceServiceServer) GetInstance(context.Context, *GetInstanceRequest) (*InstanceResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetInstance not implemented")
}</span>
func (UnimplementedInstanceServiceServer) ListInstances(context.Context, *ListInstancesRequest) (*ListInstancesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListInstances not implemented")
}</span>
func (UnimplementedInstanceServiceServer) StartInstance(context.Context, *InstanceActionRequest) (*InstanceResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method StartInstance not implemented")
}</span>
func (UnimplementedInstanceServiceServer) StopInstance(context.Context, *InstanceActionRequest) (*InstanceResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method StopInstance not implemented")
}</span>
func (UnimplementedInstanceServiceServer) RestartInstance(context.Context, *InstanceActionRequest) (*InstanceResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RestartInstance not implemented")
}</span>
func (UnimplementedInstanceServiceServer) WatchInstances(*WatchInstancesRequest, InstanceService_WatchInstancesServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method WatchInstances not implemented")
}</span>
func (UnimplementedInstanceServiceServer) mustEmbedUnimplementedInstanceServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeInstanceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstanceServiceServer will
// result in compilation errors.
type UnsafeInstanceServiceServer interface {
        mustEmbedUnimplementedInstanceServiceServer()
}

func RegisterInstanceServiceServer(s grpc.ServiceRegistrar, srv InstanceServiceServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;InstanceService_ServiceDesc, srv)
}</span>

func _InstanceService_GetInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetInstanceRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(InstanceServiceServer).GetInstance(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/rune.api.InstanceService/GetInstance",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(InstanceServiceServer).GetInstance(ctx, req.(*GetInstanceRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _InstanceService_ListInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListInstancesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(InstanceServiceServer).ListInstances(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/rune.api.InstanceService/ListInstances",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(InstanceServiceServer).ListInstances(ctx, req.(*ListInstancesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _InstanceService_StartInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(InstanceActionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(InstanceServiceServer).StartInstance(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/rune.api.InstanceService/StartInstance",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(InstanceServiceServer).StartInstance(ctx, req.(*InstanceActionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _InstanceService_StopInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(InstanceActionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(InstanceServiceServer).StopInstance(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/rune.api.InstanceService/StopInstance",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(InstanceServiceServer).StopInstance(ctx, req.(*InstanceActionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _InstanceService_RestartInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(InstanceActionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(InstanceServiceServer).RestartInstance(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/rune.api.InstanceService/RestartInstance",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(InstanceServiceServer).RestartInstance(ctx, req.(*InstanceActionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _InstanceService_WatchInstances_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(WatchInstancesRequest)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(InstanceServiceServer).WatchInstances(m, &amp;instanceServiceWatchInstancesServer{stream})</span>
}

type InstanceService_WatchInstancesServer interface {
        Send(*WatchInstancesResponse) error
        grpc.ServerStream
}

type instanceServiceWatchInstancesServer struct {
        grpc.ServerStream
}

func (x *instanceServiceWatchInstancesServer) Send(m *WatchInstancesResponse) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

// InstanceService_ServiceDesc is the grpc.ServiceDesc for InstanceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstanceService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "rune.api.InstanceService",
        HandlerType: (*InstanceServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetInstance",
                        Handler:    _InstanceService_GetInstance_Handler,
                },
                {
                        MethodName: "ListInstances",
                        Handler:    _InstanceService_ListInstances_Handler,
                },
                {
                        MethodName: "StartInstance",
                        Handler:    _InstanceService_StartInstance_Handler,
                },
                {
                        MethodName: "StopInstance",
                        Handler:    _InstanceService_StopInstance_Handler,
                },
                {
                        MethodName: "RestartInstance",
                        Handler:    _InstanceService_RestartInstance_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "WatchInstances",
                        Handler:       _InstanceService_WatchInstances_Handler,
                        ServerStreams: true,
                },
        },
        Metadata: "pkg/api/proto/instance.proto",
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v5.29.3
// source: pkg/api/proto/logs.proto

package generated

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// LogRequest represents a request to get logs from a service or instance.
type LogRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Type of log request
        //
        // Types that are assignable to Target:
        //
        //        *LogRequest_ServiceName
        //        *LogRequest_InstanceId
        Target isLogRequest_Target `protobuf_oneof:"target"`
        // Namespace of the service (optional, default: "default")
        Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Follow the log output (like tail -f)
        Follow bool `protobuf:"varint,4,opt,name=follow,proto3" json:"follow,omitempty"`
        // Number of lines to show from the end of the logs (0 for all)
        Tail int32 `protobuf:"varint,5,opt,name=tail,proto3" json:"tail,omitempty"`
        // Show logs since this time (RFC 3339 format)
        Since string `protobuf:"bytes,6,opt,name=since,proto3" json:"since,omitempty"`
        // Show logs until this time (RFC 3339 format)
        Until string `protobuf:"bytes,7,opt,name=until,proto3" json:"until,omitempty"`
        // Include timestamps with logs
        Timestamps bool `protobuf:"varint,8,opt,name=timestamps,proto3" json:"timestamps,omitempty"`
        // Filter logs by text pattern
        Filter string `protobuf:"bytes,9,opt,name=filter,proto3" json:"filter,omitempty"`
        // Client can send updated parameters while streaming
        ParameterUpdate bool `protobuf:"varint,10,opt,name=parameter_update,json=parameterUpdate,proto3" json:"parameter_update,omitempty"`
}

func (x *LogRequest) Reset() <span class="cov0" title="0">{
        *x = LogRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_logs_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LogRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_logs_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogRequest.ProtoReflect.Descriptor instead.
func (*LogRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_logs_proto_rawDescGZIP(), []int{0}
}</span>

func (m *LogRequest) GetTarget() isLogRequest_Target <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Target
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LogRequest) GetServiceName() string <span class="cov0" title="0">{
        if x, ok := x.GetTarget().(*LogRequest_ServiceName); ok </span><span class="cov0" title="0">{
                return x.ServiceName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogRequest) GetInstanceId() string <span class="cov0" title="0">{
        if x, ok := x.GetTarget().(*LogRequest_InstanceId); ok </span><span class="cov0" title="0">{
                return x.InstanceId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogRequest) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogRequest) GetFollow() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Follow
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LogRequest) GetTail() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tail
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *LogRequest) GetSince() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Since
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogRequest) GetUntil() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Until
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogRequest) GetTimestamps() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamps
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LogRequest) GetFilter() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Filter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogRequest) GetParameterUpdate() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ParameterUpdate
        }</span>
        <span class="cov0" title="0">return false</span>
}

type isLogRequest_Target interface {
        isLogRequest_Target()
}

type LogRequest_ServiceName struct {
        // Service name to get logs from (all instances)
        ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3,oneof"`
}

type LogRequest_InstanceId struct {
        // Specific instance ID to get logs from
        InstanceId string `protobuf:"bytes,2,opt,name=instance_id,json=instanceId,proto3,oneof"`
}

func (*LogRequest_ServiceName) isLogRequest_Target() {<span class="cov0" title="0">}</span>

func (*LogRequest_InstanceId) isLogRequest_Target() {<span class="cov0" title="0">}</span>

// LogResponse represents a log message in a stream response.
type LogResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Service name the log is from
        ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
        // Instance ID the log is from
        InstanceId string `protobuf:"bytes,2,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
        // Timestamp of the log (RFC 3339 format)
        Timestamp string `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        // Contents of the log line
        Content string `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty"`
        // Stream (stdout or stderr)
        Stream string `protobuf:"bytes,5,opt,name=stream,proto3" json:"stream,omitempty"`
        // Status code for control messages
        Status *Status `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *LogResponse) Reset() <span class="cov0" title="0">{
        *x = LogResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_logs_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LogResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_logs_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogResponse.ProtoReflect.Descriptor instead.
func (*LogResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_logs_proto_rawDescGZIP(), []int{1}
}</span>

func (x *LogResponse) GetServiceName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServiceName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogResponse) GetInstanceId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.InstanceId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogResponse) GetTimestamp() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogResponse) GetContent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Content
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogResponse) GetStream() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Stream
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogResponse) GetStatus() *Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_pkg_api_proto_logs_proto protoreflect.FileDescriptor

var file_pkg_api_proto_logs_proto_rawDesc = []byte{
        0x0a, 0x18, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f,
        0x6c, 0x6f, 0x67, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08, 0x72, 0x75, 0x6e, 0x65,
        0x2e, 0x61, 0x70, 0x69, 0x1a, 0x1a, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x22, 0xb7, 0x02, 0x0a, 0x0a, 0x4c, 0x6f, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x23, 0x0a, 0x0c, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x4e, 0x61, 0x6d, 0x65, 0x12, 0x21, 0x0a, 0x0b, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65,
        0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x0a, 0x69, 0x6e, 0x73,
        0x74, 0x61, 0x6e, 0x63, 0x65, 0x49, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73,
        0x70, 0x61, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65,
        0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x12, 0x12, 0x0a,
        0x04, 0x74, 0x61, 0x69, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x74, 0x61, 0x69,
        0x6c, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x75, 0x6e, 0x74, 0x69, 0x6c,
        0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x75, 0x6e, 0x74, 0x69, 0x6c, 0x12, 0x1e, 0x0a,
        0x0a, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28,
        0x08, 0x52, 0x0a, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x73, 0x12, 0x16, 0x0a,
        0x06, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x66,
        0x69, 0x6c, 0x74, 0x65, 0x72, 0x12, 0x29, 0x0a, 0x10, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
        0x65, 0x72, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52,
        0x0f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x42, 0x08, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x22, 0xcb, 0x01, 0x0a, 0x0b, 0x4c,
        0x6f, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1f, 0x0a,
        0x0b, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x0a, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x49, 0x64, 0x12, 0x1c,
        0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x18, 0x0a, 0x07,
        0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63,
        0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d,
        0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x12, 0x28,
        0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10,
        0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
        0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x32, 0x4b, 0x0a, 0x0a, 0x4c, 0x6f, 0x67, 0x53,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x3d, 0x0a, 0x0a, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
        0x4c, 0x6f, 0x67, 0x73, 0x12, 0x14, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e,
        0x4c, 0x6f, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x15, 0x2e, 0x72, 0x75, 0x6e,
        0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x4c, 0x6f, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x28, 0x01, 0x30, 0x01, 0x42, 0x2a, 0x5a, 0x28, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e,
        0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x7a, 0x62, 0x69, 0x6c, 0x6c, 0x2f, 0x72, 0x75, 0x6e, 0x65, 0x2f,
        0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65,
        0x64, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_pkg_api_proto_logs_proto_rawDescOnce sync.Once
        file_pkg_api_proto_logs_proto_rawDescData = file_pkg_api_proto_logs_proto_rawDesc
)

func file_pkg_api_proto_logs_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_pkg_api_proto_logs_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_pkg_api_proto_logs_proto_rawDescData = protoimpl.X.CompressGZIP(file_pkg_api_proto_logs_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_pkg_api_proto_logs_proto_rawDescData</span>
}

var file_pkg_api_proto_logs_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_pkg_api_proto_logs_proto_goTypes = []interface{}{
        (*LogRequest)(nil),  // 0: rune.api.LogRequest
        (*LogResponse)(nil), // 1: rune.api.LogResponse
        (*Status)(nil),      // 2: rune.api.Status
}
var file_pkg_api_proto_logs_proto_depIdxs = []int32{
        2, // 0: rune.api.LogResponse.status:type_name -&gt; rune.api.Status
        0, // 1: rune.api.LogService.StreamLogs:input_type -&gt; rune.api.LogRequest
        1, // 2: rune.api.LogService.StreamLogs:output_type -&gt; rune.api.LogResponse
        2, // [2:3] is the sub-list for method output_type
        1, // [1:2] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_pkg_api_proto_logs_proto_init() }</span>
func file_pkg_api_proto_logs_proto_init() <span class="cov8" title="1">{
        if File_pkg_api_proto_logs_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_pkg_api_proto_common_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_pkg_api_proto_logs_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LogRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_logs_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LogResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_pkg_api_proto_logs_proto_msgTypes[0].OneofWrappers = []interface{}{
                (*LogRequest_ServiceName)(nil),
                (*LogRequest_InstanceId)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_pkg_api_proto_logs_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_pkg_api_proto_logs_proto_goTypes,
                DependencyIndexes: file_pkg_api_proto_logs_proto_depIdxs,
                MessageInfos:      file_pkg_api_proto_logs_proto_msgTypes,
        }.Build()
        File_pkg_api_proto_logs_proto = out.File
        file_pkg_api_proto_logs_proto_rawDesc = nil
        file_pkg_api_proto_logs_proto_goTypes = nil
        file_pkg_api_proto_logs_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: pkg/api/proto/logs.proto

/*
Package generated is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package generated

import (
        "context"
        "io"
        "net/http"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/v2/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = metadata.Join

func request_LogService_StreamLogs_0(ctx context.Context, marshaler runtime.Marshaler, client LogServiceClient, req *http.Request, pathParams map[string]string) (LogService_StreamLogsClient, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var metadata runtime.ServerMetadata
        stream, err := client.StreamLogs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                grpclog.Infof("Failed to start streaming: %v", err)
                return nil, metadata, err
        }</span>
        <span class="cov0" title="0">dec := marshaler.NewDecoder(req.Body)
        handleSend := func() error </span><span class="cov0" title="0">{
                var protoReq LogRequest
                err := dec.Decode(&amp;protoReq)
                if err == io.EOF </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        grpclog.Infof("Failed to decode request: %v", err)
                        return err
                }</span>
                <span class="cov0" title="0">if err := stream.Send(&amp;protoReq); err != nil </span><span class="cov0" title="0">{
                        grpclog.Infof("Failed to send request: %v", err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        if err := handleSend(); err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">if err := stream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                        grpclog.Infof("Failed to terminate client stream: %v", err)
                }</span>
        }()
        <span class="cov0" title="0">header, err := stream.Header()
        if err != nil </span><span class="cov0" title="0">{
                grpclog.Infof("Failed to get header from client: %v", err)
                return nil, metadata, err
        }</span>
        <span class="cov0" title="0">metadata.HeaderMD = header
        return stream, metadata, nil</span>
}

// RegisterLogServiceHandlerServer registers the http handlers for service LogService to "mux".
// UnaryRPC     :call LogServiceServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterLogServiceHandlerFromEndpoint instead.
func RegisterLogServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server LogServiceServer) error <span class="cov0" title="0">{

        mux.Handle("POST", pattern_LogService_StreamLogs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                err := status.Error(codes.Unimplemented, "streaming calls are not yet supported in the in-process transport")
                _, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                return
        }</span>)

        <span class="cov0" title="0">return nil</span>
}

// RegisterLogServiceHandlerFromEndpoint is same as RegisterLogServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterLogServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.DialContext(ctx, endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterLogServiceHandler(ctx, mux, conn)</span>
}

// RegisterLogServiceHandler registers the http handlers for service LogService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterLogServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterLogServiceHandlerClient(ctx, mux, NewLogServiceClient(conn))
}</span>

// RegisterLogServiceHandlerClient registers the http handlers for service LogService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "LogServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "LogServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "LogServiceClient" to call the correct interceptors.
func RegisterLogServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client LogServiceClient) error <span class="cov0" title="0">{

        mux.Handle("POST", pattern_LogService_StreamLogs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.LogService/StreamLogs", runtime.WithHTTPPathPattern("/rune.api.LogService/StreamLogs"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_LogService_StreamLogs_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_LogService_StreamLogs_0(annotatedContext, mux, outboundMarshaler, w, req, func() (proto.Message, error) </span><span class="cov0" title="0">{ return resp.Recv() }</span>, mux.GetForwardResponseOptions()...)

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_LogService_StreamLogs_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.LogService", "StreamLogs"}, ""))
)

var (
        forward_LogService_StreamLogs_0 = runtime.ForwardResponseStream
)
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.29.3
// source: pkg/api/proto/logs.proto

package generated

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LogServiceClient is the client API for LogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogServiceClient interface {
        // StreamLogs provides bidirectional streaming for logs.
        // Clients can stream parameter updates, server streams log content.
        StreamLogs(ctx context.Context, opts ...grpc.CallOption) (LogService_StreamLogsClient, error)
}

type logServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewLogServiceClient(cc grpc.ClientConnInterface) LogServiceClient <span class="cov0" title="0">{
        return &amp;logServiceClient{cc}
}</span>

func (c *logServiceClient) StreamLogs(ctx context.Context, opts ...grpc.CallOption) (LogService_StreamLogsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;LogService_ServiceDesc.Streams[0], "/rune.api.LogService/StreamLogs", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;logServiceStreamLogsClient{stream}
        return x, nil</span>
}

type LogService_StreamLogsClient interface {
        Send(*LogRequest) error
        Recv() (*LogResponse, error)
        grpc.ClientStream
}

type logServiceStreamLogsClient struct {
        grpc.ClientStream
}

func (x *logServiceStreamLogsClient) Send(m *LogRequest) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *logServiceStreamLogsClient) Recv() (*LogResponse, error) <span class="cov0" title="0">{
        m := new(LogResponse)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// LogServiceServer is the server API for LogService service.
// All implementations must embed UnimplementedLogServiceServer
// for forward compatibility
type LogServiceServer interface {
        // StreamLogs provides bidirectional streaming for logs.
        // Clients can stream parameter updates, server streams log content.
        StreamLogs(LogService_StreamLogsServer) error
        mustEmbedUnimplementedLogServiceServer()
}

// UnimplementedLogServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLogServiceServer struct {
}

func (UnimplementedLogServiceServer) StreamLogs(LogService_StreamLogsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method StreamLogs not implemented")
}</span>
func (UnimplementedLogServiceServer) mustEmbedUnimplementedLogServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeLogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogServiceServer will
// result in compilation errors.
type UnsafeLogServiceServer interface {
        mustEmbedUnimplementedLogServiceServer()
}

func RegisterLogServiceServer(s grpc.ServiceRegistrar, srv LogServiceServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;LogService_ServiceDesc, srv)
}</span>

func _LogService_StreamLogs_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(LogServiceServer).StreamLogs(&amp;logServiceStreamLogsServer{stream})
}</span>

type LogService_StreamLogsServer interface {
        Send(*LogResponse) error
        Recv() (*LogRequest, error)
        grpc.ServerStream
}

type logServiceStreamLogsServer struct {
        grpc.ServerStream
}

func (x *logServiceStreamLogsServer) Send(m *LogResponse) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *logServiceStreamLogsServer) Recv() (*LogRequest, error) <span class="cov0" title="0">{
        m := new(LogRequest)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// LogService_ServiceDesc is the grpc.ServiceDesc for LogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LogService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "rune.api.LogService",
        HandlerType: (*LogServiceServer)(nil),
        Methods:     []grpc.MethodDesc{},
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "StreamLogs",
                        Handler:       _LogService_StreamLogs_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
        },
        Metadata: "pkg/api/proto/logs.proto",
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v5.29.3
// source: pkg/api/proto/service.proto

package generated

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ServiceStatus represents the current status of a service.
type ServiceStatus int32

const (
        ServiceStatus_SERVICE_STATUS_UNSPECIFIED ServiceStatus = 0
        ServiceStatus_SERVICE_STATUS_PENDING     ServiceStatus = 1 // Service is being created
        ServiceStatus_SERVICE_STATUS_RUNNING     ServiceStatus = 2 // Service is running
        ServiceStatus_SERVICE_STATUS_UPDATING    ServiceStatus = 3 // Service is being updated
        ServiceStatus_SERVICE_STATUS_FAILED      ServiceStatus = 4 // Service failed to deploy or run
)

// Enum value maps for ServiceStatus.
var (
        ServiceStatus_name = map[int32]string{
                0: "SERVICE_STATUS_UNSPECIFIED",
                1: "SERVICE_STATUS_PENDING",
                2: "SERVICE_STATUS_RUNNING",
                3: "SERVICE_STATUS_UPDATING",
                4: "SERVICE_STATUS_FAILED",
        }
        ServiceStatus_value = map[string]int32{
                "SERVICE_STATUS_UNSPECIFIED": 0,
                "SERVICE_STATUS_PENDING":     1,
                "SERVICE_STATUS_RUNNING":     2,
                "SERVICE_STATUS_UPDATING":    3,
                "SERVICE_STATUS_FAILED":      4,
        }
)

func (x ServiceStatus) Enum() *ServiceStatus <span class="cov0" title="0">{
        p := new(ServiceStatus)
        *p = x
        return p
}</span>

func (x ServiceStatus) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (ServiceStatus) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_enumTypes[0].Descriptor()
}</span>

func (ServiceStatus) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_pkg_api_proto_service_proto_enumTypes[0]
}</span>

func (x ServiceStatus) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use ServiceStatus.Descriptor instead.
func (ServiceStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{0}
}</span>

// Service represents a deployable application or workload.
type Service struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Unique identifier for the service
        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        // Human-readable name for the service
        Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        // Namespace the service belongs to
        Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Labels for the service
        Labels map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Container image for the service
        Image string `protobuf:"bytes,5,opt,name=image,proto3" json:"image,omitempty"`
        // Command to run in the container
        Command string `protobuf:"bytes,6,opt,name=command,proto3" json:"command,omitempty"`
        // Arguments to the command
        Args []string `protobuf:"bytes,7,rep,name=args,proto3" json:"args,omitempty"`
        // Environment variables for the service
        Env map[string]string `protobuf:"bytes,8,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Number of instances to run
        Scale int32 `protobuf:"varint,9,opt,name=scale,proto3" json:"scale,omitempty"`
        // Ports exposed by the service
        Ports []*ServicePort `protobuf:"bytes,10,rep,name=ports,proto3" json:"ports,omitempty"`
        // Resource requirements for each instance
        Resources *Resources `protobuf:"bytes,11,opt,name=resources,proto3" json:"resources,omitempty"`
        // Health checks for the service
        Health *HealthCheck `protobuf:"bytes,12,opt,name=health,proto3" json:"health,omitempty"`
        // Status of the service
        Status ServiceStatus `protobuf:"varint,13,opt,name=status,proto3,enum=rune.api.ServiceStatus" json:"status,omitempty"`
        // Creation timestamp (in RFC 3339 format)
        CreatedAt string `protobuf:"bytes,14,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        // Last update timestamp (in RFC 3339 format)
        UpdatedAt string `protobuf:"bytes,15,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
        // Runtime for the service ("container" or "process")
        Runtime string `protobuf:"bytes,16,opt,name=runtime,proto3" json:"runtime,omitempty"`
        // Process-specific configuration (when Runtime="process")
        Process *ProcessSpec `protobuf:"bytes,17,opt,name=process,proto3" json:"process,omitempty"`
        // Restart policy for the service
        RestartPolicy RestartPolicy `protobuf:"varint,18,opt,name=restart_policy,json=restartPolicy,proto3,enum=rune.api.RestartPolicy" json:"restart_policy,omitempty"`
}

func (x *Service) Reset() <span class="cov0" title="0">{
        *x = Service{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_service_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Service) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Service) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Service) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_service_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Service.ProtoReflect.Descriptor instead.
func (*Service) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Service) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Service) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Service) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Service) GetLabels() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Labels
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Service) GetImage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Image
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Service) GetCommand() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Command
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Service) GetArgs() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Args
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Service) GetEnv() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Env
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Service) GetScale() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scale
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Service) GetPorts() []*ServicePort <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ports
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Service) GetResources() *Resources <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Resources
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Service) GetHealth() *HealthCheck <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Health
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Service) GetStatus() ServiceStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ServiceStatus_SERVICE_STATUS_UNSPECIFIED</span>
}

func (x *Service) GetCreatedAt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Service) GetUpdatedAt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Service) GetRuntime() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Runtime
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Service) GetProcess() *ProcessSpec <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Process
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Service) GetRestartPolicy() RestartPolicy <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RestartPolicy
        }</span>
        <span class="cov0" title="0">return RestartPolicy_RESTART_POLICY_UNSPECIFIED</span>
}

// CreateServiceRequest represents a request to create a new service.
type CreateServiceRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Service to create
        Service *Service `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
        // Optional deployment tag
        DeploymentTag string `protobuf:"bytes,2,opt,name=deployment_tag,json=deploymentTag,proto3" json:"deployment_tag,omitempty"`
}

func (x *CreateServiceRequest) Reset() <span class="cov0" title="0">{
        *x = CreateServiceRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_service_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateServiceRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateServiceRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateServiceRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_service_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateServiceRequest.ProtoReflect.Descriptor instead.
func (*CreateServiceRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateServiceRequest) GetService() *Service <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Service
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CreateServiceRequest) GetDeploymentTag() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DeploymentTag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ServiceResponse returns a service or status.
type ServiceResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The service, if successful
        Service *Service `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
        // Status message
        Status *Status `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *ServiceResponse) Reset() <span class="cov0" title="0">{
        *x = ServiceResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_service_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ServiceResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ServiceResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ServiceResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_service_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ServiceResponse.ProtoReflect.Descriptor instead.
func (*ServiceResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{2}
}</span>

func (x *ServiceResponse) GetService() *Service <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Service
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ServiceResponse) GetStatus() *Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetServiceRequest requests a specific service.
type GetServiceRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the service
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Namespace of the service (optional, default: "default")
        Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (x *GetServiceRequest) Reset() <span class="cov0" title="0">{
        *x = GetServiceRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_service_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetServiceRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetServiceRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetServiceRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_service_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetServiceRequest.ProtoReflect.Descriptor instead.
func (*GetServiceRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetServiceRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetServiceRequest) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ListServicesRequest requests a list of services.
type ListServicesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Namespace to list services from (optional, default: "default")
        Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Filter services by label
        LabelSelector map[string]string `protobuf:"bytes,2,rep,name=label_selector,json=labelSelector,proto3" json:"label_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Filter services by field
        FieldSelector map[string]string `protobuf:"bytes,3,rep,name=field_selector,json=fieldSelector,proto3" json:"field_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Paging parameters
        Paging *PagingParams `protobuf:"bytes,4,opt,name=paging,proto3" json:"paging,omitempty"`
}

func (x *ListServicesRequest) Reset() <span class="cov0" title="0">{
        *x = ListServicesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_service_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListServicesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListServicesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListServicesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_service_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListServicesRequest.ProtoReflect.Descriptor instead.
func (*ListServicesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{4}
}</span>

func (x *ListServicesRequest) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ListServicesRequest) GetLabelSelector() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LabelSelector
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListServicesRequest) GetFieldSelector() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FieldSelector
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListServicesRequest) GetPaging() *PagingParams <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Paging
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ListServicesResponse returns a list of services.
type ListServicesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // List of services
        Services []*Service `protobuf:"bytes,1,rep,name=services,proto3" json:"services,omitempty"`
        // Status message
        Status *Status `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
        // Paging information for continuation
        Paging *PagingParams `protobuf:"bytes,3,opt,name=paging,proto3" json:"paging,omitempty"`
}

func (x *ListServicesResponse) Reset() <span class="cov0" title="0">{
        *x = ListServicesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_service_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListServicesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListServicesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListServicesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_service_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListServicesResponse.ProtoReflect.Descriptor instead.
func (*ListServicesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{5}
}</span>

func (x *ListServicesResponse) GetServices() []*Service <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Services
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListServicesResponse) GetStatus() *Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListServicesResponse) GetPaging() *PagingParams <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Paging
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WatchServicesRequest requests to watch services for changes.
type WatchServicesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Namespace to watch services from (optional, default: "default", use "*" for all namespaces)
        Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Filter services by label
        LabelSelector map[string]string `protobuf:"bytes,2,rep,name=label_selector,json=labelSelector,proto3" json:"label_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Filter services by field
        FieldSelector map[string]string `protobuf:"bytes,3,rep,name=field_selector,json=fieldSelector,proto3" json:"field_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *WatchServicesRequest) Reset() <span class="cov0" title="0">{
        *x = WatchServicesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_service_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *WatchServicesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WatchServicesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WatchServicesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_service_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WatchServicesRequest.ProtoReflect.Descriptor instead.
func (*WatchServicesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{6}
}</span>

func (x *WatchServicesRequest) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *WatchServicesRequest) GetLabelSelector() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LabelSelector
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *WatchServicesRequest) GetFieldSelector() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FieldSelector
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WatchServicesResponse returns service change events.
type WatchServicesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The service that changed
        Service *Service `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
        // Type of event (added, modified, deleted)
        EventType EventType `protobuf:"varint,2,opt,name=event_type,json=eventType,proto3,enum=rune.api.EventType" json:"event_type,omitempty"`
        // Status message
        Status *Status `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *WatchServicesResponse) Reset() <span class="cov0" title="0">{
        *x = WatchServicesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_service_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *WatchServicesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WatchServicesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WatchServicesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_service_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WatchServicesResponse.ProtoReflect.Descriptor instead.
func (*WatchServicesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{7}
}</span>

func (x *WatchServicesResponse) GetService() *Service <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Service
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *WatchServicesResponse) GetEventType() EventType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EventType
        }</span>
        <span class="cov0" title="0">return EventType_EVENT_TYPE_UNSPECIFIED</span>
}

func (x *WatchServicesResponse) GetStatus() *Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateServiceRequest requests an update to a service.
type UpdateServiceRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Updated service definition
        Service *Service `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
        // Optional deployment tag
        DeploymentTag string `protobuf:"bytes,2,opt,name=deployment_tag,json=deploymentTag,proto3" json:"deployment_tag,omitempty"`
}

func (x *UpdateServiceRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateServiceRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_service_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateServiceRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateServiceRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateServiceRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_service_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateServiceRequest.ProtoReflect.Descriptor instead.
func (*UpdateServiceRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{8}
}</span>

func (x *UpdateServiceRequest) GetService() *Service <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Service
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UpdateServiceRequest) GetDeploymentTag() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DeploymentTag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// DeleteServiceRequest requests deletion of a service.
type DeleteServiceRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the service to delete
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Namespace of the service (optional, default: "default")
        Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Force deletion even if instances are running
        Force bool `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
}

func (x *DeleteServiceRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteServiceRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_service_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteServiceRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteServiceRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteServiceRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_service_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteServiceRequest.ProtoReflect.Descriptor instead.
func (*DeleteServiceRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{9}
}</span>

func (x *DeleteServiceRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DeleteServiceRequest) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DeleteServiceRequest) GetForce() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Force
        }</span>
        <span class="cov0" title="0">return false</span>
}

// DeleteServiceResponse returns the result of a service deletion.
type DeleteServiceResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Status message
        Status *Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *DeleteServiceResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteServiceResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_service_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteServiceResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteServiceResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteServiceResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_service_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteServiceResponse.ProtoReflect.Descriptor instead.
func (*DeleteServiceResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{10}
}</span>

func (x *DeleteServiceResponse) GetStatus() *Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ScaleServiceRequest requests a change in service scale.
type ScaleServiceRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the service to scale
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Namespace of the service (optional, default: "default")
        Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Number of instances to scale to
        Scale int32 `protobuf:"varint,3,opt,name=scale,proto3" json:"scale,omitempty"`
}

func (x *ScaleServiceRequest) Reset() <span class="cov0" title="0">{
        *x = ScaleServiceRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_pkg_api_proto_service_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ScaleServiceRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ScaleServiceRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ScaleServiceRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_api_proto_service_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ScaleServiceRequest.ProtoReflect.Descriptor instead.
func (*ScaleServiceRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_api_proto_service_proto_rawDescGZIP(), []int{11}
}</span>

func (x *ScaleServiceRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ScaleServiceRequest) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ScaleServiceRequest) GetScale() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scale
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_pkg_api_proto_service_proto protoreflect.FileDescriptor

var file_pkg_api_proto_service_proto_rawDesc = []byte{
        0x0a, 0x1b, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08, 0x72,
        0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x1a, 0x1a, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69,
        0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x22, 0x86, 0x06, 0x0a, 0x07, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12,
        0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12,
        0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e,
        0x61, 0x6d, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63,
        0x65, 0x12, 0x35, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x1d, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72,
        0x76, 0x69, 0x63, 0x65, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79,
        0x52, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67,
        0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x18,
        0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x61, 0x72, 0x67, 0x73,
        0x18, 0x07, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x61, 0x72, 0x67, 0x73, 0x12, 0x2c, 0x0a, 0x03,
        0x65, 0x6e, 0x76, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x72, 0x75, 0x6e, 0x65,
        0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x45, 0x6e, 0x76,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x03, 0x65, 0x6e, 0x76, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x63,
        0x61, 0x6c, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x73, 0x63, 0x61, 0x6c, 0x65,
        0x12, 0x2b, 0x0a, 0x05, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x15, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x05, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x31, 0x0a,
        0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x13, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x52, 0x65, 0x73, 0x6f,
        0x75, 0x72, 0x63, 0x65, 0x73, 0x52, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73,
        0x12, 0x2d, 0x0a, 0x06, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x15, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x48, 0x65, 0x61, 0x6c,
        0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x06, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x12,
        0x2f, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0e, 0x32,
        0x17, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
        0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x0e,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12,
        0x1d, 0x0a, 0x0a, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x0f, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x18,
        0x0a, 0x07, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x10, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x07, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x2f, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x63,
        0x65, 0x73, 0x73, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x72, 0x75, 0x6e, 0x65,
        0x2e, 0x61, 0x70, 0x69, 0x2e, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x53, 0x70, 0x65, 0x63,
        0x52, 0x07, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x12, 0x3e, 0x0a, 0x0e, 0x72, 0x65, 0x73,
        0x74, 0x61, 0x72, 0x74, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x12, 0x20, 0x01, 0x28,
        0x0e, 0x32, 0x17, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x52, 0x65, 0x73,
        0x74, 0x61, 0x72, 0x74, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x0d, 0x72, 0x65, 0x73, 0x74,
        0x61, 0x72, 0x74, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x1a, 0x39, 0x0a, 0x0b, 0x4c, 0x61, 0x62,
        0x65, 0x6c, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x1a, 0x36, 0x0a, 0x08, 0x45, 0x6e, 0x76, 0x45, 0x6e, 0x74, 0x72, 0x79,
        0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b,
        0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x6a, 0x0a, 0x14,
        0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x2b, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69,
        0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x12, 0x25, 0x0a, 0x0e, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f,
        0x74, 0x61, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x64, 0x65, 0x70, 0x6c, 0x6f,
        0x79, 0x6d, 0x65, 0x6e, 0x74, 0x54, 0x61, 0x67, 0x22, 0x68, 0x0a, 0x0f, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2b, 0x0a, 0x07, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x72,
        0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52,
        0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x28, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74,
        0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e,
        0x61, 0x70, 0x69, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74,
        0x75, 0x73, 0x22, 0x45, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6e,
        0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
        0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x22, 0x99, 0x03, 0x0a, 0x13, 0x4c, 0x69,
        0x73, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12,
        0x57, 0x0a, 0x0e, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
        0x72, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61,
        0x70, 0x69, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x65, 0x6c, 0x65,
        0x63, 0x74, 0x6f, 0x72, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0d, 0x6c, 0x61, 0x62, 0x65, 0x6c,
        0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x57, 0x0a, 0x0e, 0x66, 0x69, 0x65, 0x6c,
        0x64, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x30, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x4c, 0x69, 0x73, 0x74,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e,
        0x46, 0x69, 0x65, 0x6c, 0x64, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x45, 0x6e, 0x74,
        0x72, 0x79, 0x52, 0x0d, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
        0x72, 0x12, 0x2e, 0x0a, 0x06, 0x70, 0x61, 0x67, 0x69, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x16, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x50, 0x61, 0x67,
        0x69, 0x6e, 0x67, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x52, 0x06, 0x70, 0x61, 0x67, 0x69, 0x6e,
        0x67, 0x1a, 0x40, 0x0a, 0x12, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,
        0x02, 0x38, 0x01, 0x1a, 0x40, 0x0a, 0x12, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x53, 0x65, 0x6c, 0x65,
        0x63, 0x74, 0x6f, 0x72, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x9f, 0x01, 0x0a, 0x14, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2d,
        0x0a, 0x08, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x11, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x52, 0x08, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x12, 0x28, 0x0a,
        0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e,
        0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52,
        0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x2e, 0x0a, 0x06, 0x70, 0x61, 0x67, 0x69, 0x6e,
        0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61,
        0x70, 0x69, 0x2e, 0x50, 0x61, 0x67, 0x69, 0x6e, 0x67, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x52,
        0x06, 0x70, 0x61, 0x67, 0x69, 0x6e, 0x67, 0x22, 0xec, 0x02, 0x0a, 0x14, 0x57, 0x61, 0x74, 0x63,
        0x68, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x58,
        0x0a, 0x0e, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72,
        0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70,
        0x69, 0x2e, 0x57, 0x61, 0x74, 0x63, 0x68, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x65, 0x6c, 0x65,
        0x63, 0x74, 0x6f, 0x72, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0d, 0x6c, 0x61, 0x62, 0x65, 0x6c,
        0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x58, 0x0a, 0x0e, 0x66, 0x69, 0x65, 0x6c,
        0x64, 0x5f, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x31, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x57, 0x61, 0x74, 0x63,
        0x68, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x2e, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x45, 0x6e,
        0x74, 0x72, 0x79, 0x52, 0x0d, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x1a, 0x40, 0x0a, 0x12, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x65, 0x6c, 0x65, 0x63,
        0x74, 0x6f, 0x72, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x1a, 0x40, 0x0a, 0x12, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x53, 0x65, 0x6c,
        0x65, 0x63, 0x74, 0x6f, 0x72, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65,
        0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xa2, 0x01, 0x0a, 0x15, 0x57, 0x61, 0x74, 0x63, 0x68,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x2b, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x11, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72,
        0x76, 0x69, 0x63, 0x65, 0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x32, 0x0a,
        0x0a, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0e, 0x32, 0x13, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x45, 0x76, 0x65,
        0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x09, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70,
        0x65, 0x12, 0x28, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x10, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x74, 0x61,
        0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x6a, 0x0a, 0x14, 0x55,
        0x70, 0x64, 0x61, 0x74, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x2b, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x12, 0x25, 0x0a, 0x0e, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x74,
        0x61, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79,
        0x6d, 0x65, 0x6e, 0x74, 0x54, 0x61, 0x67, 0x22, 0x5e, 0x0a, 0x14, 0x44, 0x65, 0x6c, 0x65, 0x74,
        0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e,
        0x61, 0x6d, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63,
        0x65, 0x12, 0x14, 0x0a, 0x05, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08,
        0x52, 0x05, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x22, 0x41, 0x0a, 0x15, 0x44, 0x65, 0x6c, 0x65, 0x74,
        0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x28, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x10, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x74, 0x61, 0x74,
        0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x5d, 0x0a, 0x13, 0x53, 0x63,
        0x61, 0x6c, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61,
        0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70,
        0x61, 0x63, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x05, 0x52, 0x05, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2a, 0x9f, 0x01, 0x0a, 0x0d, 0x53, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1e, 0x0a, 0x1a, 0x53,
        0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x4e,
        0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16, 0x53,
        0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x50, 0x45,
        0x4e, 0x44, 0x49, 0x4e, 0x47, 0x10, 0x01, 0x12, 0x1a, 0x0a, 0x16, 0x53, 0x45, 0x52, 0x56, 0x49,
        0x43, 0x45, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x52, 0x55, 0x4e, 0x4e, 0x49, 0x4e,
        0x47, 0x10, 0x02, 0x12, 0x1b, 0x0a, 0x17, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x53,
        0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x49, 0x4e, 0x47, 0x10, 0x03,
        0x12, 0x19, 0x0a, 0x15, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x53, 0x54, 0x41, 0x54,
        0x55, 0x53, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x04, 0x32, 0xad, 0x04, 0x0a, 0x0e,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x4a,
        0x0a, 0x0d, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12,
        0x1e, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74,
        0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x19, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x44, 0x0a, 0x0a, 0x47, 0x65,
        0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x1b, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e,
        0x61, 0x70, 0x69, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x19, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69,
        0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x4d, 0x0a, 0x0c, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73,
        0x12, 0x1d, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x4c, 0x69, 0x73, 0x74,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x1e, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x53,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x52, 0x0a, 0x0d, 0x57, 0x61, 0x74, 0x63, 0x68, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73,
        0x12, 0x1e, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x57, 0x61, 0x74, 0x63,
        0x68, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x1f, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x57, 0x61, 0x74, 0x63,
        0x68, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x30, 0x01, 0x12, 0x4a, 0x0a, 0x0d, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x53, 0x65, 0x72,
        0x76, 0x69, 0x63, 0x65, 0x12, 0x1e, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e,
        0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x19, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x50, 0x0a, 0x0d, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x12, 0x1e, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x44, 0x65, 0x6c, 0x65,
        0x74, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x1f, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x44, 0x65, 0x6c, 0x65,
        0x74, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x48, 0x0a, 0x0c, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x12, 0x1d, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x63, 0x61,
        0x6c, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x19, 0x2e, 0x72, 0x75, 0x6e, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x2a, 0x5a, 0x28, 0x67,
        0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x7a, 0x62, 0x69, 0x6c, 0x6c,
        0x2f, 0x72, 0x75, 0x6e, 0x65, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x67, 0x65,
        0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_pkg_api_proto_service_proto_rawDescOnce sync.Once
        file_pkg_api_proto_service_proto_rawDescData = file_pkg_api_proto_service_proto_rawDesc
)

func file_pkg_api_proto_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_pkg_api_proto_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_pkg_api_proto_service_proto_rawDescData = protoimpl.X.CompressGZIP(file_pkg_api_proto_service_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_pkg_api_proto_service_proto_rawDescData</span>
}

var file_pkg_api_proto_service_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_pkg_api_proto_service_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_pkg_api_proto_service_proto_goTypes = []interface{}{
        (ServiceStatus)(0),            // 0: rune.api.ServiceStatus
        (*Service)(nil),               // 1: rune.api.Service
        (*CreateServiceRequest)(nil),  // 2: rune.api.CreateServiceRequest
        (*ServiceResponse)(nil),       // 3: rune.api.ServiceResponse
        (*GetServiceRequest)(nil),     // 4: rune.api.GetServiceRequest
        (*ListServicesRequest)(nil),   // 5: rune.api.ListServicesRequest
        (*ListServicesResponse)(nil),  // 6: rune.api.ListServicesResponse
        (*WatchServicesRequest)(nil),  // 7: rune.api.WatchServicesRequest
        (*WatchServicesResponse)(nil), // 8: rune.api.WatchServicesResponse
        (*UpdateServiceRequest)(nil),  // 9: rune.api.UpdateServiceRequest
        (*DeleteServiceRequest)(nil),  // 10: rune.api.DeleteServiceRequest
        (*DeleteServiceResponse)(nil), // 11: rune.api.DeleteServiceResponse
        (*ScaleServiceRequest)(nil),   // 12: rune.api.ScaleServiceRequest
        nil,                           // 13: rune.api.Service.LabelsEntry
        nil,                           // 14: rune.api.Service.EnvEntry
        nil,                           // 15: rune.api.ListServicesRequest.LabelSelectorEntry
        nil,                           // 16: rune.api.ListServicesRequest.FieldSelectorEntry
        nil,                           // 17: rune.api.WatchServicesRequest.LabelSelectorEntry
        nil,                           // 18: rune.api.WatchServicesRequest.FieldSelectorEntry
        (*ServicePort)(nil),           // 19: rune.api.ServicePort
        (*Resources)(nil),             // 20: rune.api.Resources
        (*HealthCheck)(nil),           // 21: rune.api.HealthCheck
        (*ProcessSpec)(nil),           // 22: rune.api.ProcessSpec
        (RestartPolicy)(0),            // 23: rune.api.RestartPolicy
        (*Status)(nil),                // 24: rune.api.Status
        (*PagingParams)(nil),          // 25: rune.api.PagingParams
        (EventType)(0),                // 26: rune.api.EventType
}
var file_pkg_api_proto_service_proto_depIdxs = []int32{
        13, // 0: rune.api.Service.labels:type_name -&gt; rune.api.Service.LabelsEntry
        14, // 1: rune.api.Service.env:type_name -&gt; rune.api.Service.EnvEntry
        19, // 2: rune.api.Service.ports:type_name -&gt; rune.api.ServicePort
        20, // 3: rune.api.Service.resources:type_name -&gt; rune.api.Resources
        21, // 4: rune.api.Service.health:type_name -&gt; rune.api.HealthCheck
        0,  // 5: rune.api.Service.status:type_name -&gt; rune.api.ServiceStatus
        22, // 6: rune.api.Service.process:type_name -&gt; rune.api.ProcessSpec
        23, // 7: rune.api.Service.restart_policy:type_name -&gt; rune.api.RestartPolicy
        1,  // 8: rune.api.CreateServiceRequest.service:type_name -&gt; rune.api.Service
        1,  // 9: rune.api.ServiceResponse.service:type_name -&gt; rune.api.Service
        24, // 10: rune.api.ServiceResponse.status:type_name -&gt; rune.api.Status
        15, // 11: rune.api.ListServicesRequest.label_selector:type_name -&gt; rune.api.ListServicesRequest.LabelSelectorEntry
        16, // 12: rune.api.ListServicesRequest.field_selector:type_name -&gt; rune.api.ListServicesRequest.FieldSelectorEntry
        25, // 13: rune.api.ListServicesRequest.paging:type_name -&gt; rune.api.PagingParams
        1,  // 14: rune.api.ListServicesResponse.services:type_name -&gt; rune.api.Service
        24, // 15: rune.api.ListServicesResponse.status:type_name -&gt; rune.api.Status
        25, // 16: rune.api.ListServicesResponse.paging:type_name -&gt; rune.api.PagingParams
        17, // 17: rune.api.WatchServicesRequest.label_selector:type_name -&gt; rune.api.WatchServicesRequest.LabelSelectorEntry
        18, // 18: rune.api.WatchServicesRequest.field_selector:type_name -&gt; rune.api.WatchServicesRequest.FieldSelectorEntry
        1,  // 19: rune.api.WatchServicesResponse.service:type_name -&gt; rune.api.Service
        26, // 20: rune.api.WatchServicesResponse.event_type:type_name -&gt; rune.api.EventType
        24, // 21: rune.api.WatchServicesResponse.status:type_name -&gt; rune.api.Status
        1,  // 22: rune.api.UpdateServiceRequest.service:type_name -&gt; rune.api.Service
        24, // 23: rune.api.DeleteServiceResponse.status:type_name -&gt; rune.api.Status
        2,  // 24: rune.api.ServiceService.CreateService:input_type -&gt; rune.api.CreateServiceRequest
        4,  // 25: rune.api.ServiceService.GetService:input_type -&gt; rune.api.GetServiceRequest
        5,  // 26: rune.api.ServiceService.ListServices:input_type -&gt; rune.api.ListServicesRequest
        7,  // 27: rune.api.ServiceService.WatchServices:input_type -&gt; rune.api.WatchServicesRequest
        9,  // 28: rune.api.ServiceService.UpdateService:input_type -&gt; rune.api.UpdateServiceRequest
        10, // 29: rune.api.ServiceService.DeleteService:input_type -&gt; rune.api.DeleteServiceRequest
        12, // 30: rune.api.ServiceService.ScaleService:input_type -&gt; rune.api.ScaleServiceRequest
        3,  // 31: rune.api.ServiceService.CreateService:output_type -&gt; rune.api.ServiceResponse
        3,  // 32: rune.api.ServiceService.GetService:output_type -&gt; rune.api.ServiceResponse
        6,  // 33: rune.api.ServiceService.ListServices:output_type -&gt; rune.api.ListServicesResponse
        8,  // 34: rune.api.ServiceService.WatchServices:output_type -&gt; rune.api.WatchServicesResponse
        3,  // 35: rune.api.ServiceService.UpdateService:output_type -&gt; rune.api.ServiceResponse
        11, // 36: rune.api.ServiceService.DeleteService:output_type -&gt; rune.api.DeleteServiceResponse
        3,  // 37: rune.api.ServiceService.ScaleService:output_type -&gt; rune.api.ServiceResponse
        31, // [31:38] is the sub-list for method output_type
        24, // [24:31] is the sub-list for method input_type
        24, // [24:24] is the sub-list for extension type_name
        24, // [24:24] is the sub-list for extension extendee
        0,  // [0:24] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_pkg_api_proto_service_proto_init() }</span>
func file_pkg_api_proto_service_proto_init() <span class="cov8" title="1">{
        if File_pkg_api_proto_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_pkg_api_proto_common_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_pkg_api_proto_service_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Service); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_service_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CreateServiceRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_service_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ServiceResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_service_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetServiceRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_service_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListServicesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_service_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListServicesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_service_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*WatchServicesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_service_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*WatchServicesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_service_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateServiceRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_service_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteServiceRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_service_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteServiceResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_pkg_api_proto_service_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ScaleServiceRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_pkg_api_proto_service_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   18,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_pkg_api_proto_service_proto_goTypes,
                DependencyIndexes: file_pkg_api_proto_service_proto_depIdxs,
                EnumInfos:         file_pkg_api_proto_service_proto_enumTypes,
                MessageInfos:      file_pkg_api_proto_service_proto_msgTypes,
        }.Build()
        File_pkg_api_proto_service_proto = out.File
        file_pkg_api_proto_service_proto_rawDesc = nil
        file_pkg_api_proto_service_proto_goTypes = nil
        file_pkg_api_proto_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: pkg/api/proto/service.proto

/*
Package generated is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package generated

import (
        "context"
        "io"
        "net/http"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/v2/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = metadata.Join

func request_ServiceService_CreateService_0(ctx context.Context, marshaler runtime.Marshaler, client ServiceServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq CreateServiceRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.CreateService(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_ServiceService_CreateService_0(ctx context.Context, marshaler runtime.Marshaler, server ServiceServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq CreateServiceRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.CreateService(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_ServiceService_GetService_0(ctx context.Context, marshaler runtime.Marshaler, client ServiceServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq GetServiceRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.GetService(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_ServiceService_GetService_0(ctx context.Context, marshaler runtime.Marshaler, server ServiceServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq GetServiceRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.GetService(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_ServiceService_ListServices_0(ctx context.Context, marshaler runtime.Marshaler, client ServiceServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ListServicesRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.ListServices(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_ServiceService_ListServices_0(ctx context.Context, marshaler runtime.Marshaler, server ServiceServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ListServicesRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.ListServices(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_ServiceService_WatchServices_0(ctx context.Context, marshaler runtime.Marshaler, client ServiceServiceClient, req *http.Request, pathParams map[string]string) (ServiceService_WatchServicesClient, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq WatchServicesRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">stream, err := client.WatchServices(ctx, &amp;protoReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, err
        }</span>
        <span class="cov0" title="0">header, err := stream.Header()
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, err
        }</span>
        <span class="cov0" title="0">metadata.HeaderMD = header
        return stream, metadata, nil</span>

}

func request_ServiceService_UpdateService_0(ctx context.Context, marshaler runtime.Marshaler, client ServiceServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq UpdateServiceRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.UpdateService(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_ServiceService_UpdateService_0(ctx context.Context, marshaler runtime.Marshaler, server ServiceServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq UpdateServiceRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.UpdateService(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_ServiceService_DeleteService_0(ctx context.Context, marshaler runtime.Marshaler, client ServiceServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq DeleteServiceRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.DeleteService(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_ServiceService_DeleteService_0(ctx context.Context, marshaler runtime.Marshaler, server ServiceServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq DeleteServiceRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.DeleteService(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_ServiceService_ScaleService_0(ctx context.Context, marshaler runtime.Marshaler, client ServiceServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ScaleServiceRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.ScaleService(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_ServiceService_ScaleService_0(ctx context.Context, marshaler runtime.Marshaler, server ServiceServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ScaleServiceRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.ScaleService(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

// RegisterServiceServiceHandlerServer registers the http handlers for service ServiceService to "mux".
// UnaryRPC     :call ServiceServiceServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterServiceServiceHandlerFromEndpoint instead.
func RegisterServiceServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ServiceServiceServer) error <span class="cov0" title="0">{

        mux.Handle("POST", pattern_ServiceService_CreateService_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/rune.api.ServiceService/CreateService", runtime.WithHTTPPathPattern("/rune.api.ServiceService/CreateService"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_ServiceService_CreateService_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_CreateService_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("POST", pattern_ServiceService_GetService_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/rune.api.ServiceService/GetService", runtime.WithHTTPPathPattern("/rune.api.ServiceService/GetService"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_ServiceService_GetService_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_GetService_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("POST", pattern_ServiceService_ListServices_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/rune.api.ServiceService/ListServices", runtime.WithHTTPPathPattern("/rune.api.ServiceService/ListServices"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_ServiceService_ListServices_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_ListServices_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("POST", pattern_ServiceService_WatchServices_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                err := status.Error(codes.Unimplemented, "streaming calls are not yet supported in the in-process transport")
                _, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                return
        }</span>)

        <span class="cov0" title="0">mux.Handle("POST", pattern_ServiceService_UpdateService_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/rune.api.ServiceService/UpdateService", runtime.WithHTTPPathPattern("/rune.api.ServiceService/UpdateService"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_ServiceService_UpdateService_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_UpdateService_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("POST", pattern_ServiceService_DeleteService_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/rune.api.ServiceService/DeleteService", runtime.WithHTTPPathPattern("/rune.api.ServiceService/DeleteService"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_ServiceService_DeleteService_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_DeleteService_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("POST", pattern_ServiceService_ScaleService_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/rune.api.ServiceService/ScaleService", runtime.WithHTTPPathPattern("/rune.api.ServiceService/ScaleService"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_ServiceService_ScaleService_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_ScaleService_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterServiceServiceHandlerFromEndpoint is same as RegisterServiceServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterServiceServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov8" title="1">{
        conn, err := grpc.DialContext(ctx, endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov8" title="1">return RegisterServiceServiceHandler(ctx, mux, conn)</span>
}

// RegisterServiceServiceHandler registers the http handlers for service ServiceService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterServiceServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov8" title="1">{
        return RegisterServiceServiceHandlerClient(ctx, mux, NewServiceServiceClient(conn))
}</span>

// RegisterServiceServiceHandlerClient registers the http handlers for service ServiceService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ServiceServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ServiceServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ServiceServiceClient" to call the correct interceptors.
func RegisterServiceServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ServiceServiceClient) error <span class="cov8" title="1">{

        mux.Handle("POST", pattern_ServiceService_CreateService_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.ServiceService/CreateService", runtime.WithHTTPPathPattern("/rune.api.ServiceService/CreateService"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_ServiceService_CreateService_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_CreateService_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov8" title="1">mux.Handle("POST", pattern_ServiceService_GetService_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.ServiceService/GetService", runtime.WithHTTPPathPattern("/rune.api.ServiceService/GetService"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_ServiceService_GetService_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_GetService_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov8" title="1">mux.Handle("POST", pattern_ServiceService_ListServices_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.ServiceService/ListServices", runtime.WithHTTPPathPattern("/rune.api.ServiceService/ListServices"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_ServiceService_ListServices_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_ListServices_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov8" title="1">mux.Handle("POST", pattern_ServiceService_WatchServices_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.ServiceService/WatchServices", runtime.WithHTTPPathPattern("/rune.api.ServiceService/WatchServices"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_ServiceService_WatchServices_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_WatchServices_0(annotatedContext, mux, outboundMarshaler, w, req, func() (proto.Message, error) </span><span class="cov0" title="0">{ return resp.Recv() }</span>, mux.GetForwardResponseOptions()...)

        })

        <span class="cov8" title="1">mux.Handle("POST", pattern_ServiceService_UpdateService_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.ServiceService/UpdateService", runtime.WithHTTPPathPattern("/rune.api.ServiceService/UpdateService"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_ServiceService_UpdateService_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_UpdateService_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov8" title="1">mux.Handle("POST", pattern_ServiceService_DeleteService_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.ServiceService/DeleteService", runtime.WithHTTPPathPattern("/rune.api.ServiceService/DeleteService"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_ServiceService_DeleteService_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_DeleteService_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov8" title="1">mux.Handle("POST", pattern_ServiceService_ScaleService_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/rune.api.ServiceService/ScaleService", runtime.WithHTTPPathPattern("/rune.api.ServiceService/ScaleService"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_ServiceService_ScaleService_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_ServiceService_ScaleService_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov8" title="1">return nil</span>
}

var (
        pattern_ServiceService_CreateService_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.ServiceService", "CreateService"}, ""))

        pattern_ServiceService_GetService_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.ServiceService", "GetService"}, ""))

        pattern_ServiceService_ListServices_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.ServiceService", "ListServices"}, ""))

        pattern_ServiceService_WatchServices_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.ServiceService", "WatchServices"}, ""))

        pattern_ServiceService_UpdateService_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.ServiceService", "UpdateService"}, ""))

        pattern_ServiceService_DeleteService_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.ServiceService", "DeleteService"}, ""))

        pattern_ServiceService_ScaleService_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"rune.api.ServiceService", "ScaleService"}, ""))
)

var (
        forward_ServiceService_CreateService_0 = runtime.ForwardResponseMessage

        forward_ServiceService_GetService_0 = runtime.ForwardResponseMessage

        forward_ServiceService_ListServices_0 = runtime.ForwardResponseMessage

        forward_ServiceService_WatchServices_0 = runtime.ForwardResponseStream

        forward_ServiceService_UpdateService_0 = runtime.ForwardResponseMessage

        forward_ServiceService_DeleteService_0 = runtime.ForwardResponseMessage

        forward_ServiceService_ScaleService_0 = runtime.ForwardResponseMessage
)
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.29.3
// source: pkg/api/proto/service.proto

package generated

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ServiceServiceClient is the client API for ServiceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServiceServiceClient interface {
        // CreateService creates a new service.
        CreateService(ctx context.Context, in *CreateServiceRequest, opts ...grpc.CallOption) (*ServiceResponse, error)
        // GetService retrieves a service by name.
        GetService(ctx context.Context, in *GetServiceRequest, opts ...grpc.CallOption) (*ServiceResponse, error)
        // ListServices lists services with optional filtering.
        ListServices(ctx context.Context, in *ListServicesRequest, opts ...grpc.CallOption) (*ListServicesResponse, error)
        // WatchServices watches services for changes.
        WatchServices(ctx context.Context, in *WatchServicesRequest, opts ...grpc.CallOption) (ServiceService_WatchServicesClient, error)
        // UpdateService updates an existing service.
        UpdateService(ctx context.Context, in *UpdateServiceRequest, opts ...grpc.CallOption) (*ServiceResponse, error)
        // DeleteService removes a service.
        DeleteService(ctx context.Context, in *DeleteServiceRequest, opts ...grpc.CallOption) (*DeleteServiceResponse, error)
        // ScaleService changes the scale of a service.
        ScaleService(ctx context.Context, in *ScaleServiceRequest, opts ...grpc.CallOption) (*ServiceResponse, error)
}

type serviceServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewServiceServiceClient(cc grpc.ClientConnInterface) ServiceServiceClient <span class="cov8" title="1">{
        return &amp;serviceServiceClient{cc}
}</span>

func (c *serviceServiceClient) CreateService(ctx context.Context, in *CreateServiceRequest, opts ...grpc.CallOption) (*ServiceResponse, error) <span class="cov0" title="0">{
        out := new(ServiceResponse)
        err := c.cc.Invoke(ctx, "/rune.api.ServiceService/CreateService", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *serviceServiceClient) GetService(ctx context.Context, in *GetServiceRequest, opts ...grpc.CallOption) (*ServiceResponse, error) <span class="cov0" title="0">{
        out := new(ServiceResponse)
        err := c.cc.Invoke(ctx, "/rune.api.ServiceService/GetService", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *serviceServiceClient) ListServices(ctx context.Context, in *ListServicesRequest, opts ...grpc.CallOption) (*ListServicesResponse, error) <span class="cov0" title="0">{
        out := new(ListServicesResponse)
        err := c.cc.Invoke(ctx, "/rune.api.ServiceService/ListServices", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *serviceServiceClient) WatchServices(ctx context.Context, in *WatchServicesRequest, opts ...grpc.CallOption) (ServiceService_WatchServicesClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;ServiceService_ServiceDesc.Streams[0], "/rune.api.ServiceService/WatchServices", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;serviceServiceWatchServicesClient{stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

type ServiceService_WatchServicesClient interface {
        Recv() (*WatchServicesResponse, error)
        grpc.ClientStream
}

type serviceServiceWatchServicesClient struct {
        grpc.ClientStream
}

func (x *serviceServiceWatchServicesClient) Recv() (*WatchServicesResponse, error) <span class="cov0" title="0">{
        m := new(WatchServicesResponse)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *serviceServiceClient) UpdateService(ctx context.Context, in *UpdateServiceRequest, opts ...grpc.CallOption) (*ServiceResponse, error) <span class="cov0" title="0">{
        out := new(ServiceResponse)
        err := c.cc.Invoke(ctx, "/rune.api.ServiceService/UpdateService", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *serviceServiceClient) DeleteService(ctx context.Context, in *DeleteServiceRequest, opts ...grpc.CallOption) (*DeleteServiceResponse, error) <span class="cov0" title="0">{
        out := new(DeleteServiceResponse)
        err := c.cc.Invoke(ctx, "/rune.api.ServiceService/DeleteService", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *serviceServiceClient) ScaleService(ctx context.Context, in *ScaleServiceRequest, opts ...grpc.CallOption) (*ServiceResponse, error) <span class="cov0" title="0">{
        out := new(ServiceResponse)
        err := c.cc.Invoke(ctx, "/rune.api.ServiceService/ScaleService", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ServiceServiceServer is the server API for ServiceService service.
// All implementations must embed UnimplementedServiceServiceServer
// for forward compatibility
type ServiceServiceServer interface {
        // CreateService creates a new service.
        CreateService(context.Context, *CreateServiceRequest) (*ServiceResponse, error)
        // GetService retrieves a service by name.
        GetService(context.Context, *GetServiceRequest) (*ServiceResponse, error)
        // ListServices lists services with optional filtering.
        ListServices(context.Context, *ListServicesRequest) (*ListServicesResponse, error)
        // WatchServices watches services for changes.
        WatchServices(*WatchServicesRequest, ServiceService_WatchServicesServer) error
        // UpdateService updates an existing service.
        UpdateService(context.Context, *UpdateServiceRequest) (*ServiceResponse, error)
        // DeleteService removes a service.
        DeleteService(context.Context, *DeleteServiceRequest) (*DeleteServiceResponse, error)
        // ScaleService changes the scale of a service.
        ScaleService(context.Context, *ScaleServiceRequest) (*ServiceResponse, error)
        mustEmbedUnimplementedServiceServiceServer()
}

// UnimplementedServiceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedServiceServiceServer struct {
}

func (UnimplementedServiceServiceServer) CreateService(context.Context, *CreateServiceRequest) (*ServiceResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateService not implemented")
}</span>
func (UnimplementedServiceServiceServer) GetService(context.Context, *GetServiceRequest) (*ServiceResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetService not implemented")
}</span>
func (UnimplementedServiceServiceServer) ListServices(context.Context, *ListServicesRequest) (*ListServicesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListServices not implemented")
}</span>
func (UnimplementedServiceServiceServer) WatchServices(*WatchServicesRequest, ServiceService_WatchServicesServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method WatchServices not implemented")
}</span>
func (UnimplementedServiceServiceServer) UpdateService(context.Context, *UpdateServiceRequest) (*ServiceResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateService not implemented")
}</span>
func (UnimplementedServiceServiceServer) DeleteService(context.Context, *DeleteServiceRequest) (*DeleteServiceResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteService not implemented")
}</span>
func (UnimplementedServiceServiceServer) ScaleService(context.Context, *ScaleServiceRequest) (*ServiceResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ScaleService not implemented")
}</span>
func (UnimplementedServiceServiceServer) mustEmbedUnimplementedServiceServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeServiceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceServiceServer will
// result in compilation errors.
type UnsafeServiceServiceServer interface {
        mustEmbedUnimplementedServiceServiceServer()
}

func RegisterServiceServiceServer(s grpc.ServiceRegistrar, srv ServiceServiceServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;ServiceService_ServiceDesc, srv)
}</span>

func _ServiceService_CreateService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateServiceRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ServiceServiceServer).CreateService(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/rune.api.ServiceService/CreateService",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServiceServiceServer).CreateService(ctx, req.(*CreateServiceRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ServiceService_GetService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetServiceRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ServiceServiceServer).GetService(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/rune.api.ServiceService/GetService",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServiceServiceServer).GetService(ctx, req.(*GetServiceRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ServiceService_ListServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListServicesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ServiceServiceServer).ListServices(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/rune.api.ServiceService/ListServices",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServiceServiceServer).ListServices(ctx, req.(*ListServicesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ServiceService_WatchServices_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(WatchServicesRequest)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(ServiceServiceServer).WatchServices(m, &amp;serviceServiceWatchServicesServer{stream})</span>
}

type ServiceService_WatchServicesServer interface {
        Send(*WatchServicesResponse) error
        grpc.ServerStream
}

type serviceServiceWatchServicesServer struct {
        grpc.ServerStream
}

func (x *serviceServiceWatchServicesServer) Send(m *WatchServicesResponse) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func _ServiceService_UpdateService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateServiceRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ServiceServiceServer).UpdateService(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/rune.api.ServiceService/UpdateService",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServiceServiceServer).UpdateService(ctx, req.(*UpdateServiceRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ServiceService_DeleteService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteServiceRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ServiceServiceServer).DeleteService(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/rune.api.ServiceService/DeleteService",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServiceServiceServer).DeleteService(ctx, req.(*DeleteServiceRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ServiceService_ScaleService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ScaleServiceRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ServiceServiceServer).ScaleService(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/rune.api.ServiceService/ScaleService",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServiceServiceServer).ScaleService(ctx, req.(*ScaleServiceRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// ServiceService_ServiceDesc is the grpc.ServiceDesc for ServiceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServiceService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "rune.api.ServiceService",
        HandlerType: (*ServiceServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateService",
                        Handler:    _ServiceService_CreateService_Handler,
                },
                {
                        MethodName: "GetService",
                        Handler:    _ServiceService_GetService_Handler,
                },
                {
                        MethodName: "ListServices",
                        Handler:    _ServiceService_ListServices_Handler,
                },
                {
                        MethodName: "UpdateService",
                        Handler:    _ServiceService_UpdateService_Handler,
                },
                {
                        MethodName: "DeleteService",
                        Handler:    _ServiceService_DeleteService_Handler,
                },
                {
                        MethodName: "ScaleService",
                        Handler:    _ServiceService_ScaleService_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "WatchServices",
                        Handler:       _ServiceService_WatchServices_Handler,
                        ServerStreams: true,
                },
        },
        Metadata: "pkg/api/proto/service.proto",
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package rest

import (
        "context"
        "net/http"
        "strings"
        "time"

        "github.com/rzbill/rune/pkg/log"
)

// Middleware is a function that wraps an http.Handler.
type Middleware func(http.Handler) http.Handler

// Chain combines multiple middleware into a single middleware.
func Chain(middlewares ...Middleware) Middleware <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        next = middlewares[i](next)
                }</span>
                <span class="cov0" title="0">return next</span>
        }
}

// Logger returns a middleware that logs HTTP requests.
func Logger(logger log.Logger) Middleware <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        start := time.Now()

                        // Create a response wrapper to capture the status code
                        wrapper := &amp;responseWrapper{ResponseWriter: w, status: http.StatusOK}

                        // Process the request
                        next.ServeHTTP(wrapper, r)

                        // Log the request
                        duration := time.Since(start)
                        logger.Info("HTTP Request",
                                log.Str("method", r.Method),
                                log.Str("path", r.URL.Path),
                                log.Int("status", wrapper.status),
                                log.Duration("duration", duration),
                                log.Str("remote_addr", r.RemoteAddr),
                                log.Str("user_agent", r.UserAgent()),
                        )
                }</span>)
        }
}

// APIKey returns a middleware that checks for a valid API key.
func APIKey(apiKeys []string, logger log.Logger) Middleware <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Skip auth check if API keys are empty
                        if len(apiKeys) == 0 </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Get the Authorization header
                        <span class="cov0" title="0">authHeader := r.Header.Get("Authorization")
                        if authHeader == "" </span><span class="cov0" title="0">{
                                logger.Warn("Missing Authorization header")
                                http.Error(w, "Unauthorized: Missing API key", http.StatusUnauthorized)
                                return
                        }</span>

                        // Check that it's a Bearer token
                        <span class="cov0" title="0">if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                                logger.Warn("Invalid Authorization header format")
                                http.Error(w, "Unauthorized: Invalid Authorization format", http.StatusUnauthorized)
                                return
                        }</span>

                        // Extract the API key
                        <span class="cov0" title="0">apiKey := strings.TrimPrefix(authHeader, "Bearer ")

                        // Validate the API key
                        valid := false
                        for _, key := range apiKeys </span><span class="cov0" title="0">{
                                if apiKey == key </span><span class="cov0" title="0">{
                                        valid = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                                logger.Warn("Invalid API key")
                                http.Error(w, "Unauthorized: Invalid API key", http.StatusUnauthorized)
                                return
                        }</span>

                        // API key is valid, proceed
                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// CORS returns a middleware that adds CORS headers to the response.
func CORS() Middleware <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Set CORS headers
                        w.Header().Set("Access-Control-Allow-Origin", "*")
                        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                        // Handle preflight requests
                        if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusOK)
                                return
                        }</span>

                        // Process the request
                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// Recovery returns a middleware that recovers from panics.
func Recovery(logger log.Logger) Middleware <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if err := recover(); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("Panic recovered", log.Any("error", err))
                                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                                }</span>
                        }()

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// Timeout returns a middleware that adds a timeout to the request context.
func Timeout(timeout time.Duration) Middleware <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(r.Context(), timeout)
                        defer cancel()

                        r = r.WithContext(ctx)
                        next.ServeHTTP(w, r)
                }</span>)
        }
}

// responseWrapper is a wrapper for http.ResponseWriter that captures the status code.
type responseWrapper struct {
        http.ResponseWriter
        status int
}

// WriteHeader captures the status code and passes it to the wrapped ResponseWriter.
func (rw *responseWrapper) WriteHeader(status int) <span class="cov0" title="0">{
        rw.status = status
        rw.ResponseWriter.WriteHeader(status)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package server

import (
        "context"
        "strings"

        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/auth"
        "github.com/rzbill/rune/pkg/log"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

const (
        // AuthorizationHeader is the header key for API key authentication.
        AuthorizationHeader = "authorization"

        // APIKeyPrefix is the prefix for API key values in the Authorization header.
        APIKeyPrefix = "Bearer "
)

// authFunc is the authentication function for gRPC requests.
func (s *APIServer) authFunc(ctx context.Context) (context.Context, error) <span class="cov0" title="0">{
        // If auth is disabled, no need to check auth
        if !s.options.EnableAuth </span><span class="cov0" title="0">{
                return ctx, nil
        }</span>

        // Extract API key from metadata
        <span class="cov0" title="0">token, err := auth.AuthFromMD(ctx, "bearer")
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Missing API key in request")
                return nil, status.Errorf(codes.Unauthenticated, "missing API key: %v", err)
        }</span>

        // Validate API key
        <span class="cov0" title="0">if !s.validateAPIKey(token) </span><span class="cov0" title="0">{
                s.logger.Warn("Invalid API key", log.Str("key", token))
                return nil, status.Errorf(codes.Unauthenticated, "invalid API key")
        }</span>

        // API key is valid, add it to the context
        <span class="cov0" title="0">return ctx, nil</span>
}

// validateAPIKey checks if the given API key is valid.
func (s *APIServer) validateAPIKey(key string) bool <span class="cov0" title="0">{
        // For demonstration purposes, we'll just do a simple comparison
        for _, validKey := range s.options.APIKeys </span><span class="cov0" title="0">{
                if key == validKey </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// extractAPIKey extracts the API key from the Authorization header.
func extractAPIKey(header string) (string, error) <span class="cov0" title="0">{
        if !strings.HasPrefix(header, APIKeyPrefix) </span><span class="cov0" title="0">{
                return "", status.Errorf(codes.Unauthenticated, "bad authorization string")
        }</span>
        <span class="cov0" title="0">return strings.TrimPrefix(header, APIKeyPrefix), nil</span>
}

// authInterceptor returns a unary interceptor for authentication.
func (s *APIServer) authInterceptor() grpc.UnaryServerInterceptor <span class="cov8" title="1">{
        return auth.UnaryServerInterceptor(s.authFunc)
}</span>

// authStreamInterceptor returns a stream interceptor for authentication.
func (s *APIServer) authStreamInterceptor() grpc.StreamServerInterceptor <span class="cov8" title="1">{
        return auth.StreamServerInterceptor(s.authFunc)
}</span>

// TODO: This function is currently unused - intended for future HTTP authentication implementation
// extractAPIKeyFromHTTPRequest extracts the API key from an HTTP request.
func extractAPIKeyFromHTTPRequest(ctx context.Context) (string, error) <span class="cov0" title="0">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return "", status.Errorf(codes.Unauthenticated, "no metadata in context")
        }</span>

        <span class="cov0" title="0">authHeader := md.Get(AuthorizationHeader)
        if len(authHeader) == 0 </span><span class="cov0" title="0">{
                return "", status.Errorf(codes.Unauthenticated, "no authorization header")
        }</span>

        <span class="cov0" title="0">return extractAPIKey(authHeader[0])</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package server

import (
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/orchestrator"
        "github.com/rzbill/rune/pkg/runner"
        "github.com/rzbill/rune/pkg/runner/manager"
        "github.com/rzbill/rune/pkg/store"
)

// Options defines the options for the API server.
type Options struct {
        // Server addresses
        GRPCAddr string
        HTTPAddr string

        // TLS configuration
        EnableTLS   bool
        TLSCertFile string
        TLSKeyFile  string

        // Authentication
        EnableAuth bool
        APIKeys    []string

        // Logging
        Logger log.Logger

        // State store
        Store store.Store

        // Runner manager
        RunnerManager *manager.RunnerManager

        // Orchestrator
        Orchestrator orchestrator.Orchestrator
}

// Option is a function that configures options.
type Option func(*Options)

// DefaultOptions returns the default options.
func DefaultOptions() *Options <span class="cov8" title="1">{
        return &amp;Options{
                GRPCAddr:  ":8080",
                HTTPAddr:  ":8081",
                EnableTLS: false,
        }
}</span>

// WithGRPCAddr sets the gRPC address.
func WithGRPCAddr(addr string) Option <span class="cov8" title="1">{
        return func(opts *Options) </span><span class="cov8" title="1">{
                opts.GRPCAddr = addr
        }</span>
}

// WithHTTPAddr sets the HTTP address.
func WithHTTPAddr(addr string) Option <span class="cov8" title="1">{
        return func(opts *Options) </span><span class="cov8" title="1">{
                opts.HTTPAddr = addr
        }</span>
}

// WithTLS enables TLS with the given certificate and key files.
func WithTLS(certFile, keyFile string) Option <span class="cov0" title="0">{
        return func(o *Options) </span><span class="cov0" title="0">{
                o.TLSCertFile = certFile
                o.TLSKeyFile = keyFile
                o.EnableTLS = true
        }</span>
}

// WithAuth enables authentication with the given API keys.
func WithAuth(apiKeys []string) Option <span class="cov0" title="0">{
        return func(o *Options) </span><span class="cov0" title="0">{
                o.APIKeys = apiKeys
                o.EnableAuth = true
        }</span>
}

// WithStore sets the state store.
func WithStore(store store.Store) Option <span class="cov8" title="1">{
        return func(opts *Options) </span><span class="cov8" title="1">{
                opts.Store = store
        }</span>
}

// WithDockerRunner sets the Docker runner.
func WithDockerRunner(runner runner.Runner) Option <span class="cov0" title="0">{
        return func(opts *Options) </span>{<span class="cov0" title="0">
                // No longer needed - runner is handled by orchestrator
        }</span>
}

// WithProcessRunner sets the process runner.
func WithProcessRunner(runner runner.Runner) Option <span class="cov0" title="0">{
        return func(opts *Options) </span>{<span class="cov0" title="0">
                // No longer needed - runner is handled by orchestrator
        }</span>
}

// WithLogger sets the logger.
func WithLogger(logger log.Logger) Option <span class="cov8" title="1">{
        return func(opts *Options) </span><span class="cov8" title="1">{
                opts.Logger = logger
        }</span>
}

// WithOrchestrator sets the orchestrator.
func WithOrchestrator(orchestrator orchestrator.Orchestrator) Option <span class="cov0" title="0">{
        return func(opts *Options) </span><span class="cov0" title="0">{
                opts.Orchestrator = orchestrator
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package server

import (
        "context"
        "fmt"
        "net"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/recovery"
        grpc_validator "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/validator"
        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "github.com/rzbill/rune/pkg/api/generated"
        "github.com/rzbill/rune/pkg/api/service"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/orchestrator"
        "github.com/rzbill/rune/pkg/runner/manager"
        "github.com/rzbill/rune/pkg/store"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/reflection"
)

// APIServer represents the gRPC API server for Rune.
type APIServer struct {
        options *Options
        logger  log.Logger

        // Core services
        serviceService  *service.ServiceService
        instanceService *service.InstanceService
        logService      *service.LogService
        execService     *service.ExecService
        healthService   *service.HealthService

        // gRPC server
        grpcServer *grpc.Server

        // HTTP server for REST gateway
        httpServer *http.Server

        // State store
        store store.Store

        // Orchestrator
        orchestrator orchestrator.Orchestrator

        // Shutdown channel
        shutdownCh chan struct{}

        // Wait group for server goroutines
        wg sync.WaitGroup

        // Runner manager
        runnerManager *manager.RunnerManager
}

// New creates a new API server with the given options.
func New(opts ...Option) (*APIServer, error) <span class="cov8" title="1">{
        options := DefaultOptions()
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(options)
        }</span>

        <span class="cov8" title="1">logger := options.Logger
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.GetDefaultLogger().WithComponent("api-server")
        }</span>

        <span class="cov8" title="1">runnerManager := options.RunnerManager
        if runnerManager == nil </span><span class="cov8" title="1">{
                runnerManager = manager.NewRunnerManager(logger)
        }</span>

        // Initialize the basic server with options
        <span class="cov8" title="1">server := &amp;APIServer{
                options:       options,
                logger:        logger,
                store:         options.Store,
                orchestrator:  options.Orchestrator,
                shutdownCh:    make(chan struct{}),
                runnerManager: runnerManager,
        }

        return server, nil</span>
}

// Start starts the API server.
func (s *APIServer) Start() error <span class="cov8" title="1">{
        // Ensure we have required dependencies
        if s.store == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("state store is required")
        }</span>

        <span class="cov8" title="1">s.logger.Info("Starting Rune Server")

        // Initialize the runner manager
        if err := s.runnerManager.Initialize(); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Error initializing runners", log.Err(err))
        }</span>

        // Initialize orchestrator if not provided
        <span class="cov8" title="1">if s.orchestrator == nil </span><span class="cov8" title="1">{
                var err error

                // Use the default orchestrator creation which handles all component setup internally
                s.orchestrator, err = orchestrator.NewDefaultOrchestrator(s.store, s.logger, s.runnerManager)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create default orchestrator: %w", err)
                }</span>
        }

        // Start the orchestrator
        <span class="cov8" title="1">if err := s.orchestrator.Start(context.Background()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start orchestrator: %w", err)
        }</span>

        // Create service implementations
        <span class="cov8" title="1">s.serviceService = service.NewServiceService(s.store, s.logger)
        s.instanceService = service.NewInstanceService(s.store, s.runnerManager, s.logger)
        s.logService = service.NewLogService(s.store, s.logger, s.orchestrator)
        s.execService = service.NewExecService(s.store, s.logger, s.orchestrator)
        s.healthService = service.NewHealthService(s.store, s.logger)

        // Start gRPC server
        if err := s.startGRPCServer(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start gRPC server: %w", err)
        }</span>

        // Start REST gateway
        <span class="cov8" title="1">if err := s.startRESTGateway(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start REST gateway: %w", err)
        }</span>

        // Handle signals for graceful shutdown
        <span class="cov8" title="1">go s.handleSignals()

        return nil</span>
}

// startGRPCServer starts the gRPC server.
func (s *APIServer) startGRPCServer() error <span class="cov8" title="1">{
        // Create listener
        lis, err := net.Listen("tcp", s.options.GRPCAddr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on %s: %w", s.options.GRPCAddr, err)
        }</span>

        // Set up server options
        <span class="cov8" title="1">var opts []grpc.ServerOption

        // Add TLS if enabled
        if s.options.EnableTLS </span><span class="cov0" title="0">{
                creds, err := credentials.NewServerTLSFromFile(s.options.TLSCertFile, s.options.TLSKeyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load TLS credentials: %w", err)
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.Creds(creds))</span>
        }

        // Add middleware
        <span class="cov8" title="1">opts = append(opts, grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
                s.logUnaryInterceptor(),
                s.authInterceptor(),
                grpc_recovery.UnaryServerInterceptor(),
                grpc_validator.UnaryServerInterceptor(),
        )))

        opts = append(opts, grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
                s.logStreamInterceptor(),
                s.authStreamInterceptor(),
                grpc_recovery.StreamServerInterceptor(),
                grpc_validator.StreamServerInterceptor(),
        )))

        // Create gRPC server
        s.grpcServer = grpc.NewServer(opts...)

        // Register services
        generated.RegisterServiceServiceServer(s.grpcServer, s.serviceService)
        generated.RegisterInstanceServiceServer(s.grpcServer, s.instanceService)
        generated.RegisterLogServiceServer(s.grpcServer, s.logService)
        generated.RegisterExecServiceServer(s.grpcServer, s.execService)
        generated.RegisterHealthServiceServer(s.grpcServer, s.healthService)

        // Register reflection service for grpcurl/development
        reflection.Register(s.grpcServer)

        // Start server in a goroutine
        s.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer s.wg.Done()
                s.logger.Info("Starting gRPC server", log.Str("address", s.options.GRPCAddr))
                if err := s.grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("gRPC server error", log.Err(err))
                }</span>
        }()

        <span class="cov8" title="1">return nil</span>
}

// startRESTGateway starts the REST gateway.
func (s *APIServer) startRESTGateway() error <span class="cov8" title="1">{
        // Create HTTP mux
        mux := runtime.NewServeMux()

        // Set up dial options
        var dialOpts []grpc.DialOption
        if s.options.EnableTLS </span><span class="cov0" title="0">{
                creds, err := credentials.NewClientTLSFromFile(s.options.TLSCertFile, "")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load TLS credentials: %w", err)
                }</span>
                <span class="cov0" title="0">dialOpts = append(dialOpts, grpc.WithTransportCredentials(creds))</span>
        } else<span class="cov8" title="1"> {
                dialOpts = append(dialOpts, grpc.WithTransportCredentials(insecure.NewCredentials()))
        }</span>

        // Register handlers
        <span class="cov8" title="1">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Get the gRPC server endpoint
        endpoint := s.options.GRPCAddr

        // Register service handlers
        if err := generated.RegisterServiceServiceHandlerFromEndpoint(ctx, mux, endpoint, dialOpts); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register service handler: %w", err)
        }</span>

        <span class="cov8" title="1">if err := generated.RegisterInstanceServiceHandlerFromEndpoint(ctx, mux, endpoint, dialOpts); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register instance handler: %w", err)
        }</span>

        <span class="cov8" title="1">if err := generated.RegisterHealthServiceHandlerFromEndpoint(ctx, mux, endpoint, dialOpts); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register health handler: %w", err)
        }</span>

        // Create HTTP server
        <span class="cov8" title="1">s.httpServer = &amp;http.Server{
                Addr:    s.options.HTTPAddr,
                Handler: mux,
        }

        // Start HTTP server in a goroutine
        s.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer s.wg.Done()
                s.logger.Info("Starting REST gateway", log.Str("address", s.options.HTTPAddr))
                var err error
                if s.options.EnableTLS </span><span class="cov0" title="0">{
                        err = s.httpServer.ListenAndServeTLS(s.options.TLSCertFile, s.options.TLSKeyFile)
                }</span> else<span class="cov8" title="1"> {
                        err = s.httpServer.ListenAndServe()
                }</span>
                <span class="cov8" title="1">if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.Error("REST gateway error", log.Err(err))
                }</span>
        }()

        <span class="cov8" title="1">return nil</span>
}

// Stop stops the API server gracefully.
func (s *APIServer) Stop() error <span class="cov8" title="1">{
        s.logger.Info("Stopping Rune Server")

        // Stop the orchestrator first
        if s.orchestrator != nil </span><span class="cov8" title="1">{
                s.logger.Info("Stopping orchestrator")
                if err := s.orchestrator.Stop(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Error stopping orchestrator", log.Err(err))
                }</span>
        }

        // Ensure we only close the channel once
        <span class="cov8" title="1">select </span>{
        case &lt;-s.shutdownCh:<span class="cov8" title="1"></span>
                // Channel is already closed, nothing to do
        default:<span class="cov8" title="1">
                close(s.shutdownCh)</span>
        }

        // Stop gRPC server
        <span class="cov8" title="1">if s.grpcServer != nil </span><span class="cov8" title="1">{
                s.logger.Info("Stopping gRPC server")
                s.grpcServer.GracefulStop()
        }</span>

        // Stop HTTP server
        <span class="cov8" title="1">if s.httpServer != nil </span><span class="cov8" title="1">{
                s.logger.Info("Stopping REST gateway")
                ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()
                if err := s.httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Error shutting down REST gateway", log.Err(err))
                }</span>
        }

        // Wait for all goroutines to finish
        <span class="cov8" title="1">s.wg.Wait()
        s.logger.Info("Rune Server stopped")

        return nil</span>
}

// handleSignals handles OS signals for graceful shutdown.
func (s *APIServer) handleSignals() <span class="cov8" title="1">{
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

        select </span>{
        case sig := &lt;-sigCh:<span class="cov0" title="0">
                s.logger.Info("Received signal", log.Str("signal", sig.String()))
                _ = s.Stop()</span>
        case &lt;-s.shutdownCh:<span class="cov8" title="1">
                return</span>
        }
}

// logUnaryInterceptor returns a unary interceptor for logging.
func (s *APIServer) logUnaryInterceptor() grpc.UnaryServerInterceptor <span class="cov8" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                start := time.Now()
                s.logger.Debug("gRPC request", log.Str("method", info.FullMethod))

                resp, err := handler(ctx, req)

                duration := time.Since(start)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("gRPC error",
                                log.Str("method", info.FullMethod),
                                log.Err(err),
                                log.Duration("duration", duration))
                }</span> else<span class="cov0" title="0"> {
                        s.logger.Debug("gRPC response",
                                log.Str("method", info.FullMethod),
                                log.Duration("duration", duration))
                }</span>

                <span class="cov0" title="0">return resp, err</span>
        }
}

// logStreamInterceptor returns a stream interceptor for logging.
func (s *APIServer) logStreamInterceptor() grpc.StreamServerInterceptor <span class="cov8" title="1">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                start := time.Now()
                s.logger.Debug("gRPC stream request", log.Str("method", info.FullMethod))

                err := handler(srv, ss)

                duration := time.Since(start)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("gRPC stream error",
                                log.Str("method", info.FullMethod),
                                log.Err(err),
                                log.Duration("duration", duration))
                }</span> else<span class="cov0" title="0"> {
                        s.logger.Debug("gRPC stream complete",
                                log.Str("method", info.FullMethod),
                                log.Duration("duration", duration))
                }</span>

                <span class="cov0" title="0">return err</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package service

import (
        "context"
        "fmt"
        "io"
        "time"

        "github.com/rzbill/rune/pkg/api/generated"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/orchestrator"
        "github.com/rzbill/rune/pkg/store"
        "github.com/rzbill/rune/pkg/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// ExecService implements the gRPC ExecService.
type ExecService struct {
        generated.UnimplementedExecServiceServer

        store        store.Store
        logger       log.Logger
        orchestrator orchestrator.Orchestrator
}

// NewExecService creates a new ExecService with the given runners, store, and logger.
func NewExecService(store store.Store, logger log.Logger, orchestrator orchestrator.Orchestrator) *ExecService <span class="cov8" title="1">{
        return &amp;ExecService{
                store:        store,
                logger:       logger.WithComponent("exec-service"),
                orchestrator: orchestrator,
        }
}</span>

// getTargetInstance resolves an instance from an init request, handling both service-based and instance-based targeting
func (s *ExecService) getTargetInstance(ctx context.Context, initReq *generated.ExecInitRequest) (*types.Instance, error) <span class="cov0" title="0">{
        namespace := initReq.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = DefaultNamespace
        }</span>

        <span class="cov0" title="0">if initReq.GetServiceName() != "" </span><span class="cov0" title="0">{
                // Target is a service - need to select an instance
                serviceName := initReq.GetServiceName()

                // Get the service from the store
                var service types.Service
                if err := s.store.Get(ctx, ResourceTypeService, namespace, serviceName, &amp;service); err != nil </span><span class="cov0" title="0">{
                        if IsNotFound(err) </span><span class="cov0" title="0">{
                                return nil, status.Errorf(codes.NotFound, "service not found: %s", serviceName)
                        }</span>
                        <span class="cov0" title="0">s.logger.Error("Failed to get service", log.Err(err))
                        return nil, status.Errorf(codes.Internal, "failed to get service: %v", err)</span>
                }

                // Get all instances for the service
                <span class="cov0" title="0">var instances []types.Instance
                err := s.store.List(ctx, ResourceTypeInstance, namespace, &amp;instances)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to list instances", log.Err(err))
                        return nil, status.Errorf(codes.Internal, "failed to list instances: %v", err)
                }</span>

                // Filter instances by service ID and running status
                <span class="cov0" title="0">var runningInstances []string
                for _, instance := range instances </span><span class="cov0" title="0">{
                        if instance.ServiceID != serviceName </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if instance.Status == types.InstanceStatusRunning </span><span class="cov0" title="0">{
                                runningInstances = append(runningInstances, instance.ID)
                        }</span>
                }

                <span class="cov0" title="0">if len(runningInstances) == 0 </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.NotFound, "no running instances found for service: %s", serviceName)
                }</span>

                // Just pick the first running instance for simplicity
                <span class="cov0" title="0">instanceID := runningInstances[0]

                // Get the full instance details
                var instance types.Instance
                if err := s.store.Get(ctx, ResourceTypeInstance, namespace, instanceID, &amp;instance); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to get instance", log.Err(err))
                        return nil, status.Errorf(codes.Internal, "failed to get instance: %v", err)
                }</span>

                <span class="cov0" title="0">return &amp;instance, nil</span>
        } else<span class="cov0" title="0"> {
                // Target is a specific instance
                instanceID := initReq.GetInstanceId()

                // Get the instance details
                var instance types.Instance
                if err := s.store.Get(ctx, ResourceTypeInstance, namespace, instanceID, &amp;instance); err != nil </span><span class="cov0" title="0">{
                        if IsNotFound(err) </span><span class="cov0" title="0">{
                                return nil, status.Errorf(codes.NotFound, "instance not found: %s", instanceID)
                        }</span>
                        <span class="cov0" title="0">s.logger.Error("Failed to get instance", log.Err(err))
                        return nil, status.Errorf(codes.Internal, "failed to get instance: %v", err)</span>
                }

                // Check if the instance is running
                <span class="cov0" title="0">if instance.Status != types.InstanceStatusRunning </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.FailedPrecondition, "instance is not running, status: %s", instance.Status)
                }</span>

                <span class="cov0" title="0">return &amp;instance, nil</span>
        }
}

// StreamExec provides bidirectional streaming for exec operations.
func (s *ExecService) StreamExec(stream generated.ExecService_StreamExecServer) error <span class="cov8" title="1">{
        // Get the initial request
        req, err := stream.Recv()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to receive initial exec request", log.Err(err))
                return status.Errorf(codes.Internal, "failed to receive initial request: %v", err)
        }</span>

        // Validate the request
        <span class="cov8" title="1">if err := s.validateExecRequest(req); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Invalid exec request", log.Err(err))
                return status.Errorf(codes.InvalidArgument, "invalid exec request: %v", err)
        }</span>

        // Get the init request from the oneof
        <span class="cov8" title="1">initReq := req.GetInit()
        if initReq == nil </span><span class="cov0" title="0">{
                return status.Errorf(codes.InvalidArgument, "first request must be an init request")
        }</span>

        // Set up context with cancel
        <span class="cov8" title="1">ctx, cancel := context.WithCancel(stream.Context())
        defer cancel()

        namespace := initReq.Namespace
        if namespace == "" </span><span class="cov8" title="1">{
                namespace = DefaultNamespace
        }</span>

        // Convert gRPC options to orchestrator options
        <span class="cov8" title="1">execOptions := orchestrator.ExecOptions{
                Command:        initReq.Command,
                Env:            initReq.Env,
                WorkingDir:     initReq.WorkingDir,
                TTY:            initReq.Tty,
                TerminalWidth:  initReq.TerminalSize.GetWidth(),
                TerminalHeight: initReq.TerminalSize.GetHeight(),
        }

        // Use orchestrator to execute the command
        var execStream orchestrator.ExecStream
        var instanceID string

        if initReq.GetServiceName() != "" </span><span class="cov0" title="0">{
                // Target is a service - use ExecInService
                serviceName := initReq.GetServiceName()
                execStream, err = s.orchestrator.ExecInService(ctx, namespace, serviceName, execOptions)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to exec in service",
                                log.Str("service", serviceName),
                                log.Err(err))
                        return status.Errorf(codes.Internal, "failed to exec in service: %v", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // Target is a specific instance
                instanceID = initReq.GetInstanceId()

                // Need to determine service ID for the instance
                var instance types.Instance
                if err := s.store.Get(ctx, ResourceTypeInstance, namespace, instanceID, &amp;instance); err != nil </span><span class="cov0" title="0">{
                        if IsNotFound(err) </span><span class="cov0" title="0">{
                                return status.Errorf(codes.NotFound, "instance not found: %s", instanceID)
                        }</span>
                        <span class="cov0" title="0">s.logger.Error("Failed to get instance", log.Err(err))
                        return status.Errorf(codes.Internal, "failed to get instance: %v", err)</span>
                }

                <span class="cov8" title="1">serviceName := instance.ServiceID
                execStream, err = s.orchestrator.ExecInInstance(ctx, namespace, serviceName, instanceID, execOptions)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Error("Failed to exec in instance",
                                log.Str("instance", instanceID),
                                log.Err(err))
                        return status.Errorf(codes.Internal, "failed to exec in instance: %v", err)
                }</span>
                <span class="cov0" title="0">instanceID = instance.ID</span>
        }

        <span class="cov0" title="0">if execStream == nil </span><span class="cov0" title="0">{
                return status.Errorf(codes.Internal, "failed to create exec stream")
        }</span>
        <span class="cov0" title="0">defer execStream.Close()

        // Send a status message to indicate successful connection
        if err := stream.Send(&amp;generated.ExecResponse{
                Response: &amp;generated.ExecResponse_Status{
                        Status: &amp;generated.Status{
                                Code:    int32(codes.OK),
                                Message: fmt.Sprintf("Connected to instance %s", instanceID),
                        },
                },
        }); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to send status response", log.Err(err))
                return status.Errorf(codes.Internal, "failed to send status response: %v", err)
        }</span>

        // Channel to coordinate between stdin and stdout/stderr streams
        <span class="cov0" title="0">doneCh := make(chan error, 1)
        errorCh := make(chan error, 2)

        // Handle stdin from client to stream
        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        // Signal that stdin processing is done
                        doneCh &lt;- nil
                }</span>()

                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        req, err := stream.Recv()
                        if err == io.EOF </span><span class="cov0" title="0">{
                                // Client closed the stream
                                return
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to receive exec request", log.Err(err))
                                errorCh &lt;- fmt.Errorf("failed to receive exec request: %w", err)
                                return
                        }</span>

                        // Process request based on type
                        <span class="cov0" title="0">switch </span>{
                        case req.GetStdin() != nil:<span class="cov0" title="0">
                                // Write stdin data to the exec stream
                                _, err := execStream.Write(req.GetStdin())
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("Failed to write to exec stream", log.Err(err))
                                        errorCh &lt;- fmt.Errorf("failed to write to exec stream: %w", err)
                                        return
                                }</span>

                        case req.GetResize() != nil:<span class="cov0" title="0">
                                // Resize terminal
                                resize := req.GetResize()
                                err := execStream.ResizeTerminal(resize.Width, resize.Height)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Warn("Failed to resize terminal", log.Err(err))
                                        // Don't fail on resize errors, just log them
                                }</span>

                        case req.GetSignal() != nil:<span class="cov0" title="0">
                                // Send signal to process
                                signal := req.GetSignal()
                                err := execStream.Signal(signal.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Warn("Failed to send signal", log.Str("signal", signal.Name), log.Err(err))
                                        // Don't fail on signal errors, just log them
                                }</span>

                        default:<span class="cov0" title="0">
                                // Ignore unknown request types
                                s.logger.Warn("Received unknown exec request type")</span>
                        }

                        // Check if context is cancelled
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0"></span>
                                // Continue
                        }
                }
        }()

        // Handle stdout from stream to client
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                buf := make([]byte, 4096)
                for </span><span class="cov0" title="0">{
                        n, err := execStream.Read(buf)
                        if err == io.EOF </span><span class="cov0" title="0">{
                                // End of stream
                                return
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to read from exec stream", log.Err(err))
                                errorCh &lt;- fmt.Errorf("failed to read from exec stream: %w", err)
                                return
                        }</span>

                        <span class="cov0" title="0">if n &gt; 0 </span><span class="cov0" title="0">{
                                // Send stdout data to client
                                if err := stream.Send(&amp;generated.ExecResponse{
                                        Response: &amp;generated.ExecResponse_Stdout{
                                                Stdout: buf[:n],
                                        },
                                }); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("Failed to send stdout", log.Err(err))
                                        errorCh &lt;- fmt.Errorf("failed to send stdout: %w", err)
                                        return
                                }</span>
                        }

                        // Check if context is cancelled
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0"></span>
                                // Continue
                        }
                }
        }()

        // Handle stderr from stream to client
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                stderrReader := execStream.Stderr()
                buf := make([]byte, 4096)
                for </span><span class="cov0" title="0">{
                        n, err := stderrReader.Read(buf)
                        if err == io.EOF </span><span class="cov0" title="0">{
                                // End of stream
                                return
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to read from stderr", log.Err(err))
                                errorCh &lt;- fmt.Errorf("failed to read from stderr: %w", err)
                                return
                        }</span>

                        <span class="cov0" title="0">if n &gt; 0 </span><span class="cov0" title="0">{
                                // Send stderr data to client
                                if err := stream.Send(&amp;generated.ExecResponse{
                                        Response: &amp;generated.ExecResponse_Stderr{
                                                Stderr: buf[:n],
                                        },
                                }); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("Failed to send stderr", log.Err(err))
                                        errorCh &lt;- fmt.Errorf("failed to send stderr: %w", err)
                                        return
                                }</span>
                        }

                        // Check if context is cancelled
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0"></span>
                                // Continue
                        }
                }
        }()

        // Wait for completion or error
        <span class="cov0" title="0">var finalErr error
        select </span>{
        case err := &lt;-errorCh:<span class="cov0" title="0">
                finalErr = err
                cancel()</span> // Cancel context to stop other goroutines
        case &lt;-doneCh:<span class="cov0" title="0">
                // Client closed the stream, wait for process to complete
                // or for context to be cancelled
                select </span>{
                case err := &lt;-errorCh:<span class="cov0" title="0">
                        finalErr = err</span>
                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                        // Context cancelled
                case &lt;-time.After(500 * time.Millisecond):<span class="cov0" title="0"></span>
                        // Give a small grace period for exit code
                }
        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                // Context cancelled
        }

        // Get exit code
        <span class="cov0" title="0">exitCode, err := execStream.ExitCode()
        if err == nil </span><span class="cov0" title="0">{
                // Send exit info
                if sendErr := stream.Send(&amp;generated.ExecResponse{
                        Response: &amp;generated.ExecResponse_Exit{
                                Exit: &amp;generated.ExitInfo{
                                        Code:     int32(exitCode),
                                        Signaled: exitCode &gt; 128, // A common way to check if process was terminated by signal
                                },
                        },
                }); sendErr != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to send exit info", log.Err(sendErr))
                        if finalErr == nil </span><span class="cov0" title="0">{
                                finalErr = sendErr
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                s.logger.Warn("Failed to get exit code", log.Err(err))
        }</span>

        <span class="cov0" title="0">return finalErr</span>
}

// validateExecRequest validates an exec request.
func (s *ExecService) validateExecRequest(req *generated.ExecRequest) error <span class="cov8" title="1">{
        // First request must be an init request
        initReq := req.GetInit()
        if initReq == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("first request must be an init request")
        }</span>

        // Must specify either service name or instance ID
        <span class="cov8" title="1">if initReq.GetServiceName() == "" &amp;&amp; initReq.GetInstanceId() == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("must specify either service_name or instance_id")
        }</span>

        // Can't specify both service name and instance ID
        <span class="cov8" title="1">if initReq.GetServiceName() != "" &amp;&amp; initReq.GetInstanceId() != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot specify both service_name and instance_id")
        }</span>

        // Command must be specified
        <span class="cov8" title="1">if len(initReq.Command) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("command is required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "github.com/rzbill/rune/pkg/api/generated"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/store"
        "github.com/rzbill/rune/pkg/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// HealthService implements the gRPC HealthService.
type HealthService struct {
        generated.UnimplementedHealthServiceServer

        store  store.Store
        logger log.Logger
}

// NewHealthService creates a new HealthService with the given store and logger.
func NewHealthService(store store.Store, logger log.Logger) *HealthService <span class="cov0" title="0">{
        return &amp;HealthService{
                store:  store,
                logger: logger.WithComponent("health-service"),
        }
}</span>

// GetHealth retrieves health status of platform components.
func (s *HealthService) GetHealth(ctx context.Context, req *generated.GetHealthRequest) (*generated.GetHealthResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("GetHealth called", log.Str("component", req.ComponentType))

        // If no component type specified, default to API server health
        if req.ComponentType == "" </span><span class="cov0" title="0">{
                return s.getAPIServerHealth(ctx, req)
        }</span>

        // Handle based on component type
        <span class="cov0" title="0">switch req.ComponentType </span>{
        case "service":<span class="cov0" title="0">
                return s.getServiceHealth(ctx, req)</span>
        case "instance":<span class="cov0" title="0">
                return s.getInstanceHealth(ctx, req)</span>
        case "node":<span class="cov0" title="0">
                return s.getNodeHealth(ctx, req)</span>
        case "api-server":<span class="cov0" title="0">
                return s.getAPIServerHealth(ctx, req)</span>
        default:<span class="cov0" title="0">
                return nil, status.Errorf(codes.InvalidArgument, "unknown component type: %s", req.ComponentType)</span>
        }
}

// getServiceHealth retrieves health for a service or services.
func (s *HealthService) getServiceHealth(ctx context.Context, req *generated.GetHealthRequest) (*generated.GetHealthResponse, error) <span class="cov0" title="0">{
        namespace := req.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = DefaultNamespace
        }</span>

        <span class="cov0" title="0">var components []*generated.ComponentHealth

        if req.Name != "" </span><span class="cov0" title="0">{
                // Get health for a specific service
                var service types.Service
                if err := s.store.Get(ctx, ResourceTypeService, namespace, req.Name, &amp;service); err != nil </span><span class="cov0" title="0">{
                        if IsNotFound(err) </span><span class="cov0" title="0">{
                                return nil, status.Errorf(codes.NotFound, "service not found: %s", req.Name)
                        }</span>
                        <span class="cov0" title="0">s.logger.Error("Failed to get service", log.Err(err))
                        return nil, status.Errorf(codes.Internal, "failed to get service: %v", err)</span>
                }

                // Get instances for this service
                <span class="cov0" title="0">healthStatus, healthMessage := s.computeServiceHealthFromInstances(ctx, service.Name, namespace)

                component := &amp;generated.ComponentHealth{
                        ComponentType: "service",
                        Id:            service.ID,
                        Name:          service.Name,
                        Namespace:     namespace,
                        Status:        healthStatus,
                        Message:       healthMessage,
                        Timestamp:     time.Now().Format(time.RFC3339),
                }

                if req.IncludeChecks </span><span class="cov0" title="0">{
                        // Include detailed check results if requested
                        // This would extract from service.Health definitions and actual check results
                        component.CheckResults = generateMockHealthCheckResults()
                }</span>

                <span class="cov0" title="0">components = append(components, component)</span>
        } else<span class="cov0" title="0"> {
                // Get health for all services in the namespace
                var services []types.Service
                err := s.store.List(ctx, ResourceTypeService, namespace, &amp;services)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to list services", log.Err(err))
                        return nil, status.Errorf(codes.Internal, "failed to list services: %v", err)
                }</span>

                <span class="cov0" title="0">for _, service := range services </span><span class="cov0" title="0">{

                        healthStatus, healthMessage := s.computeServiceHealthFromInstances(ctx, service.Name, namespace)

                        component := &amp;generated.ComponentHealth{
                                ComponentType: "service",
                                Id:            service.ID,
                                Name:          service.Name,
                                Namespace:     namespace,
                                Status:        healthStatus,
                                Message:       healthMessage,
                                Timestamp:     time.Now().Format(time.RFC3339),
                        }

                        if req.IncludeChecks </span><span class="cov0" title="0">{
                                // Include detailed check results if requested
                                component.CheckResults = generateMockHealthCheckResults()
                        }</span>

                        <span class="cov0" title="0">components = append(components, component)</span>
                }
        }

        <span class="cov0" title="0">return &amp;generated.GetHealthResponse{
                Components: components,
                Status: &amp;generated.Status{
                        Code:    int32(codes.OK),
                        Message: fmt.Sprintf("Retrieved health for %d services", len(components)),
                },
        }, nil</span>
}

// getInstanceHealth retrieves health for an instance or instances.
func (s *HealthService) getInstanceHealth(ctx context.Context, req *generated.GetHealthRequest) (*generated.GetHealthResponse, error) <span class="cov0" title="0">{
        // For now, we'll just return a mock response
        // In a real implementation, we would query the runners for instance health

        var components []*generated.ComponentHealth

        component := &amp;generated.ComponentHealth{
                ComponentType: "instance",
                Id:            req.Name, // Using name as ID
                Name:          req.Name,
                Namespace:     req.Namespace,
                Status:        generated.HealthStatus_HEALTH_STATUS_HEALTHY,
                Message:       "Instance is running normally",
                Timestamp:     time.Now().Format(time.RFC3339),
        }

        if req.IncludeChecks </span><span class="cov0" title="0">{
                component.CheckResults = generateMockHealthCheckResults()
        }</span>

        <span class="cov0" title="0">components = append(components, component)

        return &amp;generated.GetHealthResponse{
                Components: components,
                Status: &amp;generated.Status{
                        Code:    int32(codes.OK),
                        Message: fmt.Sprintf("Retrieved health for %d instances", len(components)),
                },
        }, nil</span>
}

// getNodeHealth retrieves health for a node or nodes.
func (s *HealthService) getNodeHealth(ctx context.Context, req *generated.GetHealthRequest) (*generated.GetHealthResponse, error) <span class="cov0" title="0">{
        // For now, we'll just return a mock response
        // In a real implementation, we would query agents for node health

        var components []*generated.ComponentHealth

        component := &amp;generated.ComponentHealth{
                ComponentType: "node",
                Id:            req.Name, // Using name as ID
                Name:          req.Name,
                Status:        generated.HealthStatus_HEALTH_STATUS_HEALTHY,
                Message:       "Node is operating normally",
                Timestamp:     time.Now().Format(time.RFC3339),
        }

        if req.IncludeChecks </span><span class="cov0" title="0">{
                component.CheckResults = []*generated.HealthCheckResult{
                        {
                                Type:                 generated.HealthCheckType_HEALTH_CHECK_TYPE_LIVENESS,
                                Status:               generated.HealthStatus_HEALTH_STATUS_HEALTHY,
                                Message:              "Node is reachable",
                                Timestamp:            time.Now().Format(time.RFC3339),
                                ConsecutiveSuccesses: 10,
                                ConsecutiveFailures:  0,
                        },
                        {
                                Type:                 generated.HealthCheckType_HEALTH_CHECK_TYPE_READINESS,
                                Status:               generated.HealthStatus_HEALTH_STATUS_HEALTHY,
                                Message:              "Node has available resources",
                                Timestamp:            time.Now().Format(time.RFC3339),
                                ConsecutiveSuccesses: 5,
                                ConsecutiveFailures:  0,
                        },
                }
        }</span>

        <span class="cov0" title="0">components = append(components, component)

        return &amp;generated.GetHealthResponse{
                Components: components,
                Status: &amp;generated.Status{
                        Code:    int32(codes.OK),
                        Message: fmt.Sprintf("Retrieved health for %d nodes", len(components)),
                },
        }, nil</span>
}

// getAPIServerHealth retrieves health for the API server.
func (s *HealthService) getAPIServerHealth(ctx context.Context, req *generated.GetHealthRequest) (*generated.GetHealthResponse, error) <span class="cov0" title="0">{
        // API server is always healthy if we're here to respond
        component := &amp;generated.ComponentHealth{
                ComponentType: "api-server",
                Id:            "api-server",
                Name:          "api-server",
                Status:        generated.HealthStatus_HEALTH_STATUS_HEALTHY,
                Message:       "API server is operating normally",
                Timestamp:     time.Now().Format(time.RFC3339),
        }

        if req.IncludeChecks </span><span class="cov0" title="0">{
                component.CheckResults = []*generated.HealthCheckResult{
                        {
                                Type:                 generated.HealthCheckType_HEALTH_CHECK_TYPE_LIVENESS,
                                Status:               generated.HealthStatus_HEALTH_STATUS_HEALTHY,
                                Message:              "API server is responding to requests",
                                Timestamp:            time.Now().Format(time.RFC3339),
                                ConsecutiveSuccesses: 100,
                                ConsecutiveFailures:  0,
                        },
                        {
                                Type:                 generated.HealthCheckType_HEALTH_CHECK_TYPE_READINESS,
                                Status:               generated.HealthStatus_HEALTH_STATUS_HEALTHY,
                                Message:              "API server is ready to process requests",
                                Timestamp:            time.Now().Format(time.RFC3339),
                                ConsecutiveSuccesses: 100,
                                ConsecutiveFailures:  0,
                        },
                }
        }</span>

        <span class="cov0" title="0">return &amp;generated.GetHealthResponse{
                Components: []*generated.ComponentHealth{component},
                Status: &amp;generated.Status{
                        Code:    int32(codes.OK),
                        Message: "API server is healthy",
                },
        }, nil</span>
}

// computeServiceHealthFromInstances computes the health status of a service from its instances.
func (s *HealthService) computeServiceHealthFromInstances(ctx context.Context, serviceName, namespace string) (generated.HealthStatus, string) <span class="cov0" title="0">{
        // Get all instances for the service
        var instances []types.Instance
        err := s.store.List(ctx, ResourceTypeInstance, namespace, &amp;instances)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to list instances", log.Err(err))
                return generated.HealthStatus_HEALTH_STATUS_UNKNOWN, "Failed to retrieve instance data"
        }</span>

        // Count instances by status
        <span class="cov0" title="0">var totalInstances, runningInstances, failedInstances int
        for _, instance := range instances </span><span class="cov0" title="0">{
                if instance.ServiceID != serviceName </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">totalInstances++
                if instance.Status == types.InstanceStatusRunning </span><span class="cov0" title="0">{
                        runningInstances++
                }</span> else<span class="cov0" title="0"> if instance.Status == types.InstanceStatusFailed </span><span class="cov0" title="0">{
                        failedInstances++
                }</span>
        }

        // Determine overall health
        <span class="cov0" title="0">if totalInstances == 0 </span><span class="cov0" title="0">{
                return generated.HealthStatus_HEALTH_STATUS_UNKNOWN, "No instances found"
        }</span>

        <span class="cov0" title="0">if runningInstances == totalInstances </span><span class="cov0" title="0">{
                return generated.HealthStatus_HEALTH_STATUS_HEALTHY, fmt.Sprintf("All %d instances are running", totalInstances)
        }</span>

        <span class="cov0" title="0">if failedInstances == totalInstances </span><span class="cov0" title="0">{
                return generated.HealthStatus_HEALTH_STATUS_UNHEALTHY, fmt.Sprintf("All %d instances have failed", totalInstances)
        }</span>

        <span class="cov0" title="0">if runningInstances &gt; 0 </span><span class="cov0" title="0">{
                return generated.HealthStatus_HEALTH_STATUS_DEGRADED,
                        fmt.Sprintf("%d/%d instances are running", runningInstances, totalInstances)
        }</span>

        <span class="cov0" title="0">return generated.HealthStatus_HEALTH_STATUS_UNHEALTHY,
                fmt.Sprintf("No instances are running, %d/%d instances have failed", failedInstances, totalInstances)</span>
}

// generateMockHealthCheckResults generates mock health check results for demonstration.
func generateMockHealthCheckResults() []*generated.HealthCheckResult <span class="cov0" title="0">{
        now := time.Now().Format(time.RFC3339)

        return []*generated.HealthCheckResult{
                {
                        Type:                 generated.HealthCheckType_HEALTH_CHECK_TYPE_LIVENESS,
                        Status:               generated.HealthStatus_HEALTH_STATUS_HEALTHY,
                        Message:              "Health check passed",
                        Timestamp:            now,
                        ConsecutiveSuccesses: 5,
                        ConsecutiveFailures:  0,
                },
                {
                        Type:                 generated.HealthCheckType_HEALTH_CHECK_TYPE_READINESS,
                        Status:               generated.HealthStatus_HEALTH_STATUS_HEALTHY,
                        Message:              "Ready to serve traffic",
                        Timestamp:            now,
                        ConsecutiveSuccesses: 3,
                        ConsecutiveFailures:  0,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "github.com/rzbill/rune/pkg/api/generated"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner/manager"
        "github.com/rzbill/rune/pkg/store"
        "github.com/rzbill/rune/pkg/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

const (
        // ResourceTypeInstance is the resource type for instances.
        ResourceTypeInstance = "instances"
)

// InstanceService implements the gRPC InstanceService.
type InstanceService struct {
        generated.UnimplementedInstanceServiceServer

        store         store.Store
        runnerManager manager.IRunnerManager
        logger        log.Logger
}

// NewInstanceService creates a new InstanceService with the given store, runners, and logger.
func NewInstanceService(store store.Store, runnerManager manager.IRunnerManager, logger log.Logger) *InstanceService <span class="cov0" title="0">{
        return &amp;InstanceService{
                store:         store,
                runnerManager: runnerManager,
                logger:        logger.WithComponent("instance-service"),
        }
}</span>

// GetInstance retrieves an instance by ID.
func (s *InstanceService) GetInstance(ctx context.Context, req *generated.GetInstanceRequest) (*generated.InstanceResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("GetInstance called", log.Str("id", req.Id))

        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "instance ID is required")
        }</span>

        <span class="cov0" title="0">if req.Namespace == "" </span><span class="cov0" title="0">{
                req.Namespace = DefaultNamespace
        }</span>

        <span class="cov0" title="0">var instance *types.Instance
        err := s.store.Get(ctx, ResourceTypeInstance, req.Namespace, req.Id, &amp;instance)
        if err != nil </span><span class="cov0" title="0">{
                // Handle error case
                return nil, status.Errorf(codes.Internal, "failed to get instance: %v", err)
        }</span>

        // Get instance status from the appropriate runner
        <span class="cov0" title="0">var status types.InstanceStatus
        var statusErr error

        runnerToUse, err := s.runnerManager.GetInstanceRunner(instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">status, statusErr = runnerToUse.Status(ctx, instance)

        if statusErr != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get instance status", log.Str("id", req.Id), log.Err(statusErr))
                // We'll continue with the stored status, just log the error
        }</span> else<span class="cov0" title="0"> {
                // Update the instance status in our response
                instance.Status = status
        }</span>

        // Convert to protobuf message
        <span class="cov0" title="0">protoInstance, err := s.instanceModelToProto(instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert instance to proto: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;generated.InstanceResponse{
                Instance: protoInstance,
                Status: &amp;generated.Status{
                        Code:    int32(codes.OK),
                        Message: "Instance retrieved successfully",
                },
        }, nil</span>
}

// ListInstances lists instances with optional filtering.
func (s *InstanceService) ListInstances(ctx context.Context, req *generated.ListInstancesRequest) (*generated.ListInstancesResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("ListInstances called")

        namespace := req.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = DefaultNamespace
        }</span>

        // Get instances from the store
        <span class="cov0" title="0">var storeInstances []types.Instance
        err := s.store.List(ctx, ResourceTypeInstance, namespace, &amp;storeInstances)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to list instances", log.Err(err))
                return nil, status.Errorf(codes.Internal, "failed to list instances: %v", err)
        }</span>

        // Convert to domain model instances
        <span class="cov0" title="0">instances := make([]*types.Instance, 0, len(storeInstances))
        for _, instance := range storeInstances </span><span class="cov0" title="0">{

                // Apply service name filter if provided
                if req.ServiceName != "" &amp;&amp; instance.ServiceID != req.ServiceName </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Apply node ID filter if provided
                <span class="cov0" title="0">if req.NodeId != "" &amp;&amp; instance.NodeID != req.NodeId </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Apply status filter if provided
                <span class="cov0" title="0">if req.Status != generated.InstanceStatus_INSTANCE_STATUS_UNSPECIFIED </span><span class="cov0" title="0">{
                        protoStatus := s.instanceStatusToProto(instance.Status)
                        if protoStatus != req.Status </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">instances = append(instances, &amp;instance)</span>
        }

        // Convert to protobuf messages
        <span class="cov0" title="0">protoInstances := make([]*generated.Instance, 0, len(instances))
        for _, instance := range instances </span><span class="cov0" title="0">{
                // Get instance status from the appropriate runner
                var status types.InstanceStatus
                var statusErr error

                runnerToUse, err := s.runnerManager.GetInstanceRunner(instance)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">status, statusErr = runnerToUse.Status(ctx, instance)

                if statusErr == nil </span><span class="cov0" title="0">{
                        // Update the instance status
                        instance.Status = status
                }</span>

                <span class="cov0" title="0">protoInstance, err := s.instanceModelToProto(instance)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to convert instance to proto", log.Err(err))
                        continue</span>
                }

                <span class="cov0" title="0">protoInstances = append(protoInstances, protoInstance)</span>
        }

        <span class="cov0" title="0">return &amp;generated.ListInstancesResponse{
                Instances: protoInstances,
                Status: &amp;generated.Status{
                        Code:    int32(codes.OK),
                        Message: fmt.Sprintf("Found %d instances", len(protoInstances)),
                },
                Paging: &amp;generated.PagingParams{
                        Limit:  int32(len(protoInstances)),
                        Offset: 0,
                },
        }, nil</span>
}

// StartInstance starts an instance.
func (s *InstanceService) StartInstance(ctx context.Context, req *generated.InstanceActionRequest) (*generated.InstanceResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("StartInstance called", log.Str("id", req.Id))

        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "instance ID is required")
        }</span>

        // Get the instance
        <span class="cov0" title="0">instanceResp, err := s.GetInstance(ctx, &amp;generated.GetInstanceRequest{Id: req.Id})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine the appropriate runner
        <span class="cov0" title="0">instance, err := s.ProtoInstanceToInstanceModel(instanceResp.Instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">runnerToUse, err := s.runnerManager.GetInstanceRunner(instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Start the instance
        <span class="cov0" title="0">if err := runnerToUse.Start(ctx, instance); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to start instance", log.Str("id", req.Id), log.Err(err))
                return nil, status.Errorf(codes.Internal, "failed to start instance: %v", err)
        }</span>

        // Get the updated instance
        <span class="cov0" title="0">return s.GetInstance(ctx, &amp;generated.GetInstanceRequest{Id: req.Id})</span>
}

// StopInstance stops an instance.
func (s *InstanceService) StopInstance(ctx context.Context, req *generated.InstanceActionRequest) (*generated.InstanceResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("StopInstance called", log.Str("id", req.Id))

        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "instance ID is required")
        }</span>

        // Get the instance
        <span class="cov0" title="0">instanceResp, err := s.GetInstance(ctx, &amp;generated.GetInstanceRequest{Id: req.Id})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine the appropriate runner
        <span class="cov0" title="0">instance, err := s.ProtoInstanceToInstanceModel(instanceResp.Instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">runnerToUse, err := s.runnerManager.GetInstanceRunner(instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set timeout
        <span class="cov0" title="0">timeout := time.Duration(30) * time.Second
        if req.TimeoutSeconds &gt; 0 </span><span class="cov0" title="0">{
                timeout = time.Duration(req.TimeoutSeconds) * time.Second
        }</span>

        // Stop the instance
        <span class="cov0" title="0">if err := runnerToUse.Stop(ctx, instance, timeout); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to stop instance", log.Str("id", req.Id), log.Err(err))
                return nil, status.Errorf(codes.Internal, "failed to stop instance: %v", err)
        }</span>

        // Get the updated instance
        <span class="cov0" title="0">return s.GetInstance(ctx, &amp;generated.GetInstanceRequest{Id: req.Id})</span>
}

// RestartInstance restarts an instance.
func (s *InstanceService) RestartInstance(ctx context.Context, req *generated.InstanceActionRequest) (*generated.InstanceResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("RestartInstance called", log.Str("id", req.Id))

        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "instance ID is required")
        }</span>

        // First stop the instance
        <span class="cov0" title="0">_, err := s.StopInstance(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Then start it again
        <span class="cov0" title="0">return s.StartInstance(ctx, req)</span>
}

// ProtoInstanceToInstanceModel converts a protobuf message to a domain model instance.
func (s *InstanceService) ProtoInstanceToInstanceModel(protoInstance *generated.Instance) (*types.Instance, error) <span class="cov0" title="0">{
        if protoInstance == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("proto instance is nil")
        }</span>

        // Create a new Instance with basic fields
        <span class="cov0" title="0">instance := &amp;types.Instance{
                ID:            protoInstance.Id,
                Name:          protoInstance.Name,
                Namespace:     protoInstance.Namespace,
                ServiceID:     protoInstance.ServiceId,
                NodeID:        protoInstance.NodeId,
                IP:            protoInstance.Ip,
                StatusMessage: protoInstance.StatusMessage,
                ContainerID:   protoInstance.ContainerId,
        }

        // Convert PID (int32 -&gt; int)
        if protoInstance.Pid &gt; 0 </span><span class="cov0" title="0">{
                instance.PID = int(protoInstance.Pid)
        }</span>

        // Parse timestamps
        <span class="cov0" title="0">if protoInstance.CreatedAt != "" </span><span class="cov0" title="0">{
                createdAt, err := time.Parse(time.RFC3339, protoInstance.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid created_at timestamp: %w", err)
                }</span>
                <span class="cov0" title="0">instance.CreatedAt = createdAt</span>
        } else<span class="cov0" title="0"> {
                instance.CreatedAt = time.Now() // Default to current time if not provided
        }</span>

        <span class="cov0" title="0">if protoInstance.UpdatedAt != "" </span><span class="cov0" title="0">{
                updatedAt, err := time.Parse(time.RFC3339, protoInstance.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid updated_at timestamp: %w", err)
                }</span>
                <span class="cov0" title="0">instance.UpdatedAt = updatedAt</span>
        } else<span class="cov0" title="0"> {
                instance.UpdatedAt = instance.CreatedAt // Default to created time if not provided
        }</span>

        // Convert status
        <span class="cov0" title="0">instance.Status = s.protoStatusToInstanceStatus(protoInstance.Status)

        // Convert resources if provided
        if protoInstance.Resources != nil </span><span class="cov0" title="0">{
                instance.Resources = &amp;types.Resources{}

                if protoInstance.Resources.Cpu != nil </span><span class="cov0" title="0">{
                        instance.Resources.CPU = types.ResourceLimit{
                                Request: protoInstance.Resources.Cpu.Request,
                                Limit:   protoInstance.Resources.Cpu.Limit,
                        }
                }</span>

                <span class="cov0" title="0">if protoInstance.Resources.Memory != nil </span><span class="cov0" title="0">{
                        instance.Resources.Memory = types.ResourceLimit{
                                Request: protoInstance.Resources.Memory.Request,
                                Limit:   protoInstance.Resources.Memory.Limit,
                        }
                }</span>
        }

        // Validate the instance
        <span class="cov0" title="0">if err := instance.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid instance: %w", err)
        }</span>

        <span class="cov0" title="0">return instance, nil</span>
}

// Convert proto status enum to domain model status
func (s *InstanceService) protoStatusToInstanceStatus(status generated.InstanceStatus) types.InstanceStatus <span class="cov0" title="0">{
        switch status </span>{
        case generated.InstanceStatus_INSTANCE_STATUS_PENDING:<span class="cov0" title="0">
                return types.InstanceStatusPending</span>
        case generated.InstanceStatus_INSTANCE_STATUS_CREATED:<span class="cov0" title="0">
                return types.InstanceStatusCreated</span>
        case generated.InstanceStatus_INSTANCE_STATUS_STARTING:<span class="cov0" title="0">
                return types.InstanceStatusStarting</span>
        case generated.InstanceStatus_INSTANCE_STATUS_RUNNING:<span class="cov0" title="0">
                return types.InstanceStatusRunning</span>
        case generated.InstanceStatus_INSTANCE_STATUS_STOPPED:<span class="cov0" title="0">
                return types.InstanceStatusStopped</span>
        case generated.InstanceStatus_INSTANCE_STATUS_FAILED:<span class="cov0" title="0">
                return types.InstanceStatusFailed</span>
        case generated.InstanceStatus_INSTANCE_STATUS_EXITED:<span class="cov0" title="0">
                return types.InstanceStatusExited</span>
        default:<span class="cov0" title="0">
                return types.InstanceStatusPending</span> // Default to pending if unspecified
        }
}

// instanceModelToProto converts a domain model instance to a protobuf message.
func (s *InstanceService) instanceModelToProto(instance *types.Instance) (*generated.Instance, error) <span class="cov0" title="0">{
        if instance == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance is nil")
        }</span>

        <span class="cov0" title="0">protoInstance := &amp;generated.Instance{
                Id:            instance.ID,
                Runner:        string(instance.Runner),
                Namespace:     instance.Namespace,
                Name:          instance.Name,
                ServiceId:     instance.ServiceID,
                ServiceName:   instance.ServiceName,
                NodeId:        instance.NodeID,
                Ip:            instance.IP,
                StatusMessage: instance.StatusMessage,
                ContainerId:   instance.ContainerID,
                Pid:           int32(instance.PID),
                CreatedAt:     instance.CreatedAt.Format(time.RFC3339),
                UpdatedAt:     instance.UpdatedAt.Format(time.RFC3339),
        }

        // Convert status
        protoInstance.Status = s.instanceStatusToProto(instance.Status)

        // Convert resources
        if instance.Resources != nil </span><span class="cov0" title="0">{
                protoInstance.Resources = &amp;generated.Resources{
                        Cpu: &amp;generated.ResourceLimit{
                                Request: instance.Resources.CPU.Request,
                                Limit:   instance.Resources.CPU.Limit,
                        },
                        Memory: &amp;generated.ResourceLimit{
                                Request: instance.Resources.Memory.Request,
                                Limit:   instance.Resources.Memory.Limit,
                        },
                }
        }</span>

        <span class="cov0" title="0">return protoInstance, nil</span>
}

// instanceStatusToProto converts a domain model instance status to a protobuf enum value.
func (s *InstanceService) instanceStatusToProto(status types.InstanceStatus) generated.InstanceStatus <span class="cov0" title="0">{
        switch status </span>{
        case types.InstanceStatusPending:<span class="cov0" title="0">
                return generated.InstanceStatus_INSTANCE_STATUS_PENDING</span>
        case types.InstanceStatusCreated:<span class="cov0" title="0">
                return generated.InstanceStatus_INSTANCE_STATUS_CREATED</span>
        case types.InstanceStatusStarting:<span class="cov0" title="0">
                return generated.InstanceStatus_INSTANCE_STATUS_STARTING</span>
        case types.InstanceStatusRunning:<span class="cov0" title="0">
                return generated.InstanceStatus_INSTANCE_STATUS_RUNNING</span>
        case types.InstanceStatusStopped:<span class="cov0" title="0">
                return generated.InstanceStatus_INSTANCE_STATUS_STOPPED</span>
        case types.InstanceStatusFailed:<span class="cov0" title="0">
                return generated.InstanceStatus_INSTANCE_STATUS_FAILED</span>
        case types.InstanceStatusExited:<span class="cov0" title="0">
                return generated.InstanceStatus_INSTANCE_STATUS_EXITED</span>
        default:<span class="cov0" title="0">
                return generated.InstanceStatus_INSTANCE_STATUS_UNSPECIFIED</span>
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package service

import (
        "context"
        "fmt"
        "io"
        "time"

        "github.com/rzbill/rune/pkg/api/generated"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/orchestrator"
        "github.com/rzbill/rune/pkg/store"
        "github.com/rzbill/rune/pkg/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// LogService implements the gRPC LogService.
type LogService struct {
        generated.UnimplementedLogServiceServer

        store        store.Store
        logger       log.Logger
        orchestrator orchestrator.Orchestrator
}

// NewLogService creates a new LogService with the given runners, store, and logger.
func NewLogService(store store.Store, logger log.Logger, orchestrator orchestrator.Orchestrator) *LogService <span class="cov0" title="0">{
        return &amp;LogService{
                store:        store,
                logger:       logger.WithComponent("log-service"),
                orchestrator: orchestrator,
        }
}</span>

// StreamLogs provides bidirectional streaming for logs.
func (s *LogService) StreamLogs(stream generated.LogService_StreamLogsServer) error <span class="cov0" title="0">{
        // Get the initial request
        req, err := stream.Recv()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to receive initial log request", log.Err(err))
                return status.Errorf(codes.Internal, "failed to receive initial request: %v", err)
        }</span>

        // Validate the request
        <span class="cov0" title="0">if err := s.validateLogRequest(req); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Invalid log request", log.Err(err))
                return status.Errorf(codes.InvalidArgument, "invalid log request: %v", err)
        }</span>

        // Set up context with cancel
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(stream.Context())
        defer cancel()

        // Process request based on target (service or instance)
        var namespace string
        var serviceName string
        var instanceID string

        namespace = req.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = DefaultNamespace
        }</span>

        // Set up log options
        <span class="cov0" title="0">logOptions := orchestrator.LogOptions{
                Follow:     req.Follow,
                Tail:       int(req.Tail),
                Timestamps: req.Timestamps,
        }

        // Parse timestamps if provided
        if req.Since != "" </span><span class="cov0" title="0">{
                since, err := time.Parse(time.RFC3339, req.Since)
                if err != nil </span><span class="cov0" title="0">{
                        return status.Errorf(codes.InvalidArgument, "invalid since timestamp: %v", err)
                }</span>
                <span class="cov0" title="0">logOptions.Since = since</span>
        }

        <span class="cov0" title="0">if req.Until != "" </span><span class="cov0" title="0">{
                until, err := time.Parse(time.RFC3339, req.Until)
                if err != nil </span><span class="cov0" title="0">{
                        return status.Errorf(codes.InvalidArgument, "invalid until timestamp: %v", err)
                }</span>
                <span class="cov0" title="0">logOptions.Until = until</span>
        }

        // Channel to collect log output
        <span class="cov0" title="0">logCh := make(chan *generated.LogResponse, 100)
        defer close(logCh)

        // Error channel to propagate errors from goroutines
        errCh := make(chan error, 1)

        // Get logs based on target
        var logReader io.ReadCloser
        if req.GetServiceName() != "" </span><span class="cov0" title="0">{
                // Target is a service
                serviceName = req.GetServiceName()

                // Verify service exists
                var service types.Service
                if err := s.store.Get(ctx, ResourceTypeService, namespace, serviceName, &amp;service); err != nil </span><span class="cov0" title="0">{
                        if IsNotFound(err) </span><span class="cov0" title="0">{
                                return status.Errorf(codes.NotFound, "service not found: %s", serviceName)
                        }</span>
                        <span class="cov0" title="0">s.logger.Error("Failed to get service", log.Err(err))
                        return status.Errorf(codes.Internal, "failed to get service: %v", err)</span>
                }

                // Use orchestrator to get service logs
                <span class="cov0" title="0">logReader, err = s.orchestrator.GetServiceLogs(ctx, namespace, serviceName, logOptions)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to get service logs",
                                log.Str("service", serviceName),
                                log.Err(err))
                        return status.Errorf(codes.Internal, "failed to get service logs: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Target is a specific instance
                instanceID = req.GetInstanceId()

                // Get the instance to determine its service
                var instance types.Instance
                if err := s.store.Get(ctx, ResourceTypeInstance, namespace, instanceID, &amp;instance); err != nil </span><span class="cov0" title="0">{
                        if IsNotFound(err) </span><span class="cov0" title="0">{
                                return status.Errorf(codes.NotFound, "instance not found: %s", instanceID)
                        }</span>
                        <span class="cov0" title="0">s.logger.Error("Failed to get instance", log.Err(err))
                        return status.Errorf(codes.Internal, "failed to get instance: %v", err)</span>
                }

                <span class="cov0" title="0">serviceName = instance.ServiceID

                // Use orchestrator to get instance logs
                logReader, err = s.orchestrator.GetInstanceLogs(ctx, namespace, serviceName, instanceID, logOptions)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to get instance logs",
                                log.Str("instance", instanceID),
                                log.Err(err))
                        return status.Errorf(codes.Internal, "failed to get instance logs: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if logReader == nil </span><span class="cov0" title="0">{
                return status.Errorf(codes.Internal, "failed to create log reader")
        }</span>
        <span class="cov0" title="0">defer logReader.Close()

        // Start a goroutine to read from logReader and send to logCh
        go func() </span><span class="cov0" title="0">{
                buf := make([]byte, 4096)
                for </span><span class="cov0" title="0">{
                        n, err := logReader.Read(buf)
                        if err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        s.logger.Debug("End of logs")
                                        return
                                }</span>
                                <span class="cov0" title="0">s.logger.Error("Failed to read logs", log.Err(err))
                                errCh &lt;- fmt.Errorf("failed to read logs: %v", err)
                                return</span>
                        }

                        // Send the log chunk to the client
                        <span class="cov0" title="0">if n &gt; 0 </span><span class="cov0" title="0">{
                                logCh &lt;- &amp;generated.LogResponse{
                                        InstanceId:  instanceID,
                                        ServiceName: serviceName,
                                        Content:     string(buf[:n]),
                                        Timestamp:   time.Now().Format(time.RFC3339),
                                        Stream:      "stdout", // This is simplified - the orchestrator doesn't differentiate streams
                                }
                        }</span>

                        // Check if context is cancelled
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0"></span>
                                // Continue
                        }
                }
        }()

        // Handle parameter updates from client
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        newReq, err := stream.Recv()
                        if err == io.EOF </span><span class="cov0" title="0">{
                                // Client closed stream
                                cancel()
                                return
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to receive log request update", log.Err(err))
                                errCh &lt;- fmt.Errorf("failed to receive request update: %v", err)
                                cancel()
                                return
                        }</span>

                        // Handle parameter update
                        <span class="cov0" title="0">if newReq.ParameterUpdate </span><span class="cov0" title="0">{
                                // Cancel current loggers and start new ones with updated parameters
                                // This is a simplified approach - a real implementation would be more sophisticated
                                cancel()
                                return
                        }</span>

                        // Check if context is cancelled
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0"></span>
                                // Continue
                        }
                }
        }()

        // Stream logs to client
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case logResp, ok := &lt;-logCh:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                // Channel closed
                                return nil
                        }</span>
                        <span class="cov0" title="0">if err := stream.Send(logResp); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to send log response", log.Err(err))
                                return status.Errorf(codes.Internal, "failed to send log response: %v", err)
                        }</span>
                case err := &lt;-errCh:<span class="cov0" title="0">
                        s.logger.Error("Log streaming error", log.Err(err))
                        return status.Errorf(codes.Internal, "log streaming error: %v", err)</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        s.logger.Debug("Context cancelled")
                        return nil</span>
                }
        }
}

// validateLogRequest validates a log request.
func (s *LogService) validateLogRequest(req *generated.LogRequest) error <span class="cov0" title="0">{
        // Must specify either service name or instance ID
        if req.GetServiceName() == "" &amp;&amp; req.GetInstanceId() == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("must specify either service_name or instance_id")
        }</span>

        // Can't specify both service name and instance ID
        <span class="cov0" title="0">if req.GetServiceName() != "" &amp;&amp; req.GetInstanceId() != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot specify both service_name and instance_id")
        }</span>

        // Validate since and until timestamps
        <span class="cov0" title="0">if req.Since != "" </span><span class="cov0" title="0">{
                if _, err := time.Parse(time.RFC3339, req.Since); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid since timestamp: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if req.Until != "" </span><span class="cov0" title="0">{
                if _, err := time.Parse(time.RFC3339, req.Until); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid until timestamp: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package service

import (
        "context"

        "github.com/rzbill/rune/pkg/api/generated"
        "github.com/stretchr/testify/mock"
        "google.golang.org/grpc"
)

// MockExecServiceStream is a mock implementation of the generated.ExecService_StreamExecServer interface
type MockExecServiceStream struct {
        mock.Mock
        grpc.ServerStream
        ctx context.Context
}

// NewMockExecServiceStream creates a new MockExecServiceStream with the given context
func NewMockExecServiceStream(ctx context.Context) *MockExecServiceStream <span class="cov8" title="1">{
        return &amp;MockExecServiceStream{
                ctx: ctx,
        }
}</span>

// Send mocks the Send method
func (m *MockExecServiceStream) Send(resp *generated.ExecResponse) error <span class="cov0" title="0">{
        args := m.Called(resp)
        return args.Error(0)
}</span>

// Recv mocks the Recv method
func (m *MockExecServiceStream) Recv() (*generated.ExecRequest, error) <span class="cov8" title="1">{
        args := m.Called()
        return args.Get(0).(*generated.ExecRequest), args.Error(1)
}</span>

// Context returns the context
func (m *MockExecServiceStream) Context() context.Context <span class="cov8" title="1">{
        if m.ctx != nil </span><span class="cov8" title="1">{
                return m.ctx
        }</span>
        <span class="cov0" title="0">return context.Background()</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package service

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/rzbill/rune/pkg/api/generated"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/store"
        "github.com/rzbill/rune/pkg/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

const (
        // DefaultNamespace is the default namespace for services.
        DefaultNamespace = "default"

        // ResourceTypeService is the resource type for services.
        ResourceTypeService = "services"
)

// ServiceService implements the gRPC ServiceService.
type ServiceService struct {
        generated.UnimplementedServiceServiceServer

        store  store.Store
        logger log.Logger
}

// NewServiceService creates a new ServiceService with the given store and logger.
func NewServiceService(store store.Store, logger log.Logger) *ServiceService <span class="cov0" title="0">{
        return &amp;ServiceService{
                store:  store,
                logger: logger.WithComponent("service-service"),
        }
}</span>

// CreateService creates a new service.
func (s *ServiceService) CreateService(ctx context.Context, req *generated.CreateServiceRequest) (*generated.ServiceResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("CreateService called")

        if req.Service == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "service is required")
        }</span>

        // Convert protobuf message to domain model
        <span class="cov0" title="0">service, err := s.protoToServiceModel(req.Service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "invalid service: %v", err)
        }</span>

        // Generate service ID if not provided
        <span class="cov0" title="0">if service.ID == "" </span><span class="cov0" title="0">{
                service.ID = uuid.New().String()
        }</span>

        // Set namespace to default if not provided
        <span class="cov0" title="0">if service.Namespace == "" </span><span class="cov0" title="0">{
                service.Namespace = DefaultNamespace
        }</span>

        // Set creation time
        <span class="cov0" title="0">now := time.Now()
        service.CreatedAt = now
        service.UpdatedAt = now

        // Set initial status
        service.Status = types.ServiceStatusPending

        // Store the service
        if err := s.store.Create(ctx, ResourceTypeService, service.Namespace, service.Name, service); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create service", log.Err(err))
                return nil, status.Errorf(codes.Internal, "failed to create service: %v", err)
        }</span>

        // Convert back to protobuf message
        <span class="cov0" title="0">protoService, err := s.serviceModelToProto(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to convert service to proto: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;generated.ServiceResponse{
                Service: protoService,
                Status: &amp;generated.Status{
                        Code:    int32(codes.OK),
                        Message: "Service created successfully",
                },
        }, nil</span>
}

// GetService retrieves a service by name.
func (s *ServiceService) GetService(ctx context.Context, req *generated.GetServiceRequest) (*generated.ServiceResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("GetService called", log.Str("name", req.Name))

        if req.Name == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "service name is required")
        }</span>

        <span class="cov0" title="0">namespace := req.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = DefaultNamespace
        }</span>

        // Get the service from the store
        <span class="cov0" title="0">var service types.Service
        if err := s.store.Get(ctx, ResourceTypeService, namespace, req.Name, &amp;service); err != nil </span><span class="cov0" title="0">{
                if IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.NotFound, "service not found: %s", req.Name)
                }</span>
                <span class="cov0" title="0">s.logger.Error("Failed to get service", log.Err(err))
                return nil, status.Errorf(codes.Internal, "failed to get service: %v", err)</span>
        }

        // Convert to protobuf message
        <span class="cov0" title="0">protoService, err := s.serviceModelToProto(&amp;service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to convert service to proto: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;generated.ServiceResponse{
                Service: protoService,
                Status: &amp;generated.Status{
                        Code:    int32(codes.OK),
                        Message: "Service retrieved successfully",
                },
        }, nil</span>
}

// ListServices lists services with optional filtering.
func (s *ServiceService) ListServices(ctx context.Context, req *generated.ListServicesRequest) (*generated.ListServicesResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("ListServices called")

        namespace := req.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = DefaultNamespace
        }</span>

        <span class="cov0" title="0">var services []types.Service
        var err error

        // Check if we need to list across all namespaces
        if namespace == "*" </span><span class="cov0" title="0">{
                // For all namespaces, we need to list each namespace separately
                // Get all namespaces first (this would typically come from a namespace store)
                // TODO: For now, we'll just query all resources directly without namespace filtering
                s.logger.Debug("Listing services across all namespaces")
                err = s.store.List(ctx, ResourceTypeService, "", &amp;services)
        }</span> else<span class="cov0" title="0"> {
                // Get services from the store for a specific namespace
                err = s.store.List(ctx, ResourceTypeService, namespace, &amp;services)
        }</span>

        <span class="cov0" title="0">s.logger.Debug("======client requested========Found services", log.Json("services", services))

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to list services", log.Err(err))
                return nil, status.Errorf(codes.Internal, "failed to list services: %v", err)
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Found services", log.Int("count", len(services)))

        // Convert to protobuf messages
        protoServices := make([]*generated.Service, 0, len(services))
        for _, service := range services </span><span class="cov0" title="0">{
                // Apply selector filtering (both labels and fields)
                if !matchSelectors(&amp;service, req.LabelSelector, req.FieldSelector) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">protoService, err := s.serviceModelToProto(&amp;service)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to convert service to proto", log.Err(err))
                        continue</span>
                }

                <span class="cov0" title="0">protoServices = append(protoServices, protoService)</span>
        }

        <span class="cov0" title="0">s.logger.Debug("Found proto services", log.Int("count", len(protoServices)))

        return &amp;generated.ListServicesResponse{
                Services: protoServices,
                Status: &amp;generated.Status{
                        Code:    int32(codes.OK),
                        Message: fmt.Sprintf("Found %d services", len(protoServices)),
                },
                Paging: &amp;generated.PagingParams{
                        Limit:  int32(len(protoServices)),
                        Offset: 0,
                },
        }, nil</span>
}

// matchSelectors checks if service matches all the labels and fields in the selectors
func matchSelectors(service *types.Service, labels map[string]string, fields map[string]string) bool <span class="cov0" title="0">{
        // Check label selectors
        if len(labels) &gt; 0 </span><span class="cov0" title="0">{
                // Check if the service has all the requested labels
                for key, value := range labels </span><span class="cov0" title="0">{
                        // If service has no labels or the specific label is not found
                        if service.Labels == nil </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov0" title="0">serviceValue, exists := service.Labels[key]
                        if !exists || serviceValue != value </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }

        // Check field selectors
        <span class="cov0" title="0">for k, v := range fields </span><span class="cov0" title="0">{
                switch k </span>{
                case "name":<span class="cov0" title="0">
                        if service.Name != v </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case "namespace":<span class="cov0" title="0">
                        if service.Namespace != v </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case "status":<span class="cov0" title="0">
                        if string(service.Status) != v </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case "runtime":<span class="cov0" title="0">
                        if string(service.Runtime) != v </span><span class="cov0" title="0">{
                                return false
                        }</span>
                default:<span class="cov0" title="0">
                        // Unknown field, consider it a non-match
                        return false</span>
                }
        }

        // Match if we passed all checks
        <span class="cov0" title="0">return true</span>
}

// UpdateService updates an existing service.
func (s *ServiceService) UpdateService(ctx context.Context, req *generated.UpdateServiceRequest) (*generated.ServiceResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("UpdateService called")

        if req.Service == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "service is required")
        }</span>

        <span class="cov0" title="0">namespace := req.Service.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = DefaultNamespace
        }</span>

        // Check if the service exists
        <span class="cov0" title="0">var existingService types.Service
        err := s.store.Get(ctx, ResourceTypeService, namespace, req.Service.Name, &amp;existingService)
        if err != nil </span><span class="cov0" title="0">{
                if IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.NotFound, "service not found: %s", req.Service.Name)
                }</span>
                <span class="cov0" title="0">s.logger.Error("Failed to get service", log.Err(err))
                return nil, status.Errorf(codes.Internal, "failed to get service: %v", err)</span>
        }

        // Convert protobuf message to domain model
        <span class="cov0" title="0">updatedService, err := s.protoToServiceModel(req.Service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "invalid service: %v", err)
        }</span>

        // Preserve the ID, creation time, and other fields that shouldn't change
        <span class="cov0" title="0">updatedService.ID = existingService.ID
        updatedService.CreatedAt = existingService.CreatedAt
        updatedService.UpdatedAt = time.Now()
        updatedService.Status = types.ServiceStatusDeploying

        // Store the updated service
        if err := s.store.Update(ctx, ResourceTypeService, namespace, req.Service.Name, updatedService); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update service", log.Err(err))
                return nil, status.Errorf(codes.Internal, "failed to update service: %v", err)
        }</span>

        // Convert back to protobuf message
        <span class="cov0" title="0">protoService, err := s.serviceModelToProto(updatedService)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to convert service to proto: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;generated.ServiceResponse{
                Service: protoService,
                Status: &amp;generated.Status{
                        Code:    int32(codes.OK),
                        Message: "Service updated successfully",
                },
        }, nil</span>
}

// DeleteService removes a service.
func (s *ServiceService) DeleteService(ctx context.Context, req *generated.DeleteServiceRequest) (*generated.DeleteServiceResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("DeleteService called", log.Str("name", req.Name))

        if req.Name == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "service name is required")
        }</span>

        <span class="cov0" title="0">namespace := req.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = DefaultNamespace
        }</span>

        // Check if the service exists
        <span class="cov0" title="0">var existingService types.Service
        err := s.store.Get(ctx, ResourceTypeService, namespace, req.Name, &amp;existingService)
        if err != nil </span><span class="cov0" title="0">{
                if IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.NotFound, "service not found: %s", req.Name)
                }</span>
                <span class="cov0" title="0">s.logger.Error("Failed to get service", log.Err(err))
                return nil, status.Errorf(codes.Internal, "failed to get service: %v", err)</span>
        }

        // TODO: Check if service has instances and force parameter is provided

        // Delete the service
        <span class="cov0" title="0">if err := s.store.Delete(ctx, ResourceTypeService, namespace, req.Name); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to delete service", log.Err(err))
                return nil, status.Errorf(codes.Internal, "failed to delete service: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;generated.DeleteServiceResponse{
                Status: &amp;generated.Status{
                        Code:    int32(codes.OK),
                        Message: "Service deleted successfully",
                },
        }, nil</span>
}

// ScaleService changes the scale of a service.
func (s *ServiceService) ScaleService(ctx context.Context, req *generated.ScaleServiceRequest) (*generated.ServiceResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("ScaleService called", log.Str("name", req.Name), log.Int("scale", int(req.Scale)))

        if req.Name == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "service name is required")
        }</span>

        <span class="cov0" title="0">if req.Scale &lt; 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "scale must be a non-negative integer")
        }</span>

        <span class="cov0" title="0">namespace := req.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = DefaultNamespace
        }</span>

        // Get the service from the store
        <span class="cov0" title="0">var service types.Service
        if err := s.store.Get(ctx, ResourceTypeService, namespace, req.Name, &amp;service); err != nil </span><span class="cov0" title="0">{
                if IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.NotFound, "service not found: %s", req.Name)
                }</span>
                <span class="cov0" title="0">s.logger.Error("Failed to get service", log.Err(err))
                return nil, status.Errorf(codes.Internal, "failed to get service: %v", err)</span>
        }

        // Update the scale
        <span class="cov0" title="0">service.Scale = int(req.Scale)
        service.UpdatedAt = time.Now()

        // Store the updated service
        if err := s.store.Update(ctx, ResourceTypeService, namespace, req.Name, &amp;service); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update service scale", log.Err(err))
                return nil, status.Errorf(codes.Internal, "failed to update service scale: %v", err)
        }</span>

        // Convert to protobuf message
        <span class="cov0" title="0">protoService, err := s.serviceModelToProto(&amp;service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to convert service to proto: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;generated.ServiceResponse{
                Service: protoService,
                Status: &amp;generated.Status{
                        Code:    int32(codes.OK),
                        Message: fmt.Sprintf("Service scaled to %d instances", req.Scale),
                },
        }, nil</span>
}

// serviceModelToProto converts a domain model service to a protobuf message.
func (s *ServiceService) serviceModelToProto(service *types.Service) (*generated.Service, error) <span class="cov0" title="0">{
        if service == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service is nil")
        }</span>

        <span class="cov0" title="0">protoService := &amp;generated.Service{
                Id:        service.ID,
                Name:      service.Name,
                Namespace: service.Namespace,
                Image:     service.Image,
                Command:   service.Command,
                Scale:     int32(service.Scale),
                CreatedAt: service.CreatedAt.Format(time.RFC3339),
                UpdatedAt: service.UpdatedAt.Format(time.RFC3339),
                Runtime:   string(service.Runtime),
        }

        // Convert labels
        if len(service.Labels) &gt; 0 </span><span class="cov0" title="0">{
                protoService.Labels = make(map[string]string)
                for k, v := range service.Labels </span><span class="cov0" title="0">{
                        protoService.Labels[k] = v
                }</span>
        }

        // Convert args
        <span class="cov0" title="0">if len(service.Args) &gt; 0 </span><span class="cov0" title="0">{
                protoService.Args = make([]string, len(service.Args))
                copy(protoService.Args, service.Args)
        }</span>

        // Convert environment variables
        <span class="cov0" title="0">if len(service.Env) &gt; 0 </span><span class="cov0" title="0">{
                protoService.Env = make(map[string]string)
                for k, v := range service.Env </span><span class="cov0" title="0">{
                        protoService.Env[k] = v
                }</span>
        }

        // Convert ports
        <span class="cov0" title="0">if len(service.Ports) &gt; 0 </span><span class="cov0" title="0">{
                protoService.Ports = make([]*generated.ServicePort, len(service.Ports))
                for i, port := range service.Ports </span><span class="cov0" title="0">{
                        protoService.Ports[i] = &amp;generated.ServicePort{
                                Name:       port.Name,
                                Port:       int32(port.Port),
                                TargetPort: int32(port.TargetPort),
                                Protocol:   port.Protocol,
                        }
                }</span>
        }

        // Convert resources
        <span class="cov0" title="0">if service.Resources != (types.Resources{}) </span><span class="cov0" title="0">{
                protoService.Resources = &amp;generated.Resources{
                        Cpu: &amp;generated.ResourceLimit{
                                Request: service.Resources.CPU.Request,
                                Limit:   service.Resources.CPU.Limit,
                        },
                        Memory: &amp;generated.ResourceLimit{
                                Request: service.Resources.Memory.Request,
                                Limit:   service.Resources.Memory.Limit,
                        },
                }
        }</span>

        // Convert status
        <span class="cov0" title="0">switch service.Status </span>{
        case types.ServiceStatusPending:<span class="cov0" title="0">
                protoService.Status = generated.ServiceStatus_SERVICE_STATUS_PENDING</span>
        case types.ServiceStatusRunning:<span class="cov0" title="0">
                protoService.Status = generated.ServiceStatus_SERVICE_STATUS_RUNNING</span>
        case types.ServiceStatusDeploying:<span class="cov0" title="0">
                protoService.Status = generated.ServiceStatus_SERVICE_STATUS_UPDATING</span>
        case types.ServiceStatusFailed:<span class="cov0" title="0">
                protoService.Status = generated.ServiceStatus_SERVICE_STATUS_FAILED</span>
        default:<span class="cov0" title="0">
                protoService.Status = generated.ServiceStatus_SERVICE_STATUS_UNSPECIFIED</span>
        }

        // Convert health checks
        <span class="cov0" title="0">if service.Health != nil </span><span class="cov0" title="0">{
                protoService.Health = &amp;generated.HealthCheck{}

                if service.Health.Liveness != nil </span><span class="cov0" title="0">{
                        protoService.Health.Liveness = &amp;generated.Probe{
                                InitialDelaySeconds: int32(service.Health.Liveness.InitialDelaySeconds),
                                PeriodSeconds:       int32(service.Health.Liveness.IntervalSeconds),
                                TimeoutSeconds:      int32(service.Health.Liveness.TimeoutSeconds),
                        }

                        switch service.Health.Liveness.Type </span>{
                        case "http":<span class="cov0" title="0">
                                protoService.Health.Liveness.Type = generated.ProbeType_PROBE_TYPE_HTTP
                                protoService.Health.Liveness.Path = service.Health.Liveness.Path
                                protoService.Health.Liveness.Port = int32(service.Health.Liveness.Port)</span>
                        case "tcp":<span class="cov0" title="0">
                                protoService.Health.Liveness.Type = generated.ProbeType_PROBE_TYPE_TCP
                                protoService.Health.Liveness.Port = int32(service.Health.Liveness.Port)</span>
                        case "command":<span class="cov0" title="0">
                                protoService.Health.Liveness.Type = generated.ProbeType_PROBE_TYPE_COMMAND
                                protoService.Health.Liveness.Command = service.Health.Liveness.Command</span>
                        }
                }

                <span class="cov0" title="0">if service.Health.Readiness != nil </span><span class="cov0" title="0">{
                        protoService.Health.Readiness = &amp;generated.Probe{
                                InitialDelaySeconds: int32(service.Health.Readiness.InitialDelaySeconds),
                                PeriodSeconds:       int32(service.Health.Readiness.IntervalSeconds),
                                TimeoutSeconds:      int32(service.Health.Readiness.TimeoutSeconds),
                        }

                        switch service.Health.Readiness.Type </span>{
                        case "http":<span class="cov0" title="0">
                                protoService.Health.Readiness.Type = generated.ProbeType_PROBE_TYPE_HTTP
                                protoService.Health.Readiness.Path = service.Health.Readiness.Path
                                protoService.Health.Readiness.Port = int32(service.Health.Readiness.Port)</span>
                        case "tcp":<span class="cov0" title="0">
                                protoService.Health.Readiness.Type = generated.ProbeType_PROBE_TYPE_TCP
                                protoService.Health.Readiness.Port = int32(service.Health.Readiness.Port)</span>
                        case "command":<span class="cov0" title="0">
                                protoService.Health.Readiness.Type = generated.ProbeType_PROBE_TYPE_COMMAND
                                protoService.Health.Readiness.Command = service.Health.Readiness.Command</span>
                        }
                }
        }

        <span class="cov0" title="0">return protoService, nil</span>
}

// protoToServiceModel converts a protobuf message to a domain model service.
func (s *ServiceService) protoToServiceModel(proto *generated.Service) (*types.Service, error) <span class="cov0" title="0">{
        if proto == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("proto service is nil")
        }</span>

        <span class="cov0" title="0">service := &amp;types.Service{
                ID:        proto.Id,
                Name:      proto.Name,
                Namespace: proto.Namespace,
                Image:     proto.Image,
                Command:   proto.Command,
                Scale:     int(proto.Scale),
                Runtime:   types.RuntimeType(proto.Runtime),
        }

        // Convert labels
        if len(proto.Labels) &gt; 0 </span><span class="cov0" title="0">{
                service.Labels = make(map[string]string)
                for k, v := range proto.Labels </span><span class="cov0" title="0">{
                        service.Labels[k] = v
                }</span>
        }

        // Convert args
        <span class="cov0" title="0">if len(proto.Args) &gt; 0 </span><span class="cov0" title="0">{
                service.Args = make([]string, len(proto.Args))
                copy(service.Args, proto.Args)
        }</span>

        // Convert environment variables
        <span class="cov0" title="0">if len(proto.Env) &gt; 0 </span><span class="cov0" title="0">{
                service.Env = make(map[string]string)
                for k, v := range proto.Env </span><span class="cov0" title="0">{
                        service.Env[k] = v
                }</span>
        }

        // Convert ports
        <span class="cov0" title="0">if len(proto.Ports) &gt; 0 </span><span class="cov0" title="0">{
                service.Ports = make([]types.ServicePort, len(proto.Ports))
                for i, port := range proto.Ports </span><span class="cov0" title="0">{
                        service.Ports[i] = types.ServicePort{
                                Name:       port.Name,
                                Port:       int(port.Port),
                                TargetPort: int(port.TargetPort),
                                Protocol:   port.Protocol,
                        }
                }</span>
        }

        // Convert resources
        <span class="cov0" title="0">if proto.Resources != nil </span><span class="cov0" title="0">{
                if proto.Resources.Cpu != nil </span><span class="cov0" title="0">{
                        service.Resources.CPU = types.ResourceLimit{
                                Request: proto.Resources.Cpu.Request,
                                Limit:   proto.Resources.Cpu.Limit,
                        }
                }</span>
                <span class="cov0" title="0">if proto.Resources.Memory != nil </span><span class="cov0" title="0">{
                        service.Resources.Memory = types.ResourceLimit{
                                Request: proto.Resources.Memory.Request,
                                Limit:   proto.Resources.Memory.Limit,
                        }
                }</span>
        }

        // Convert status
        <span class="cov0" title="0">switch proto.Status </span>{
        case generated.ServiceStatus_SERVICE_STATUS_PENDING:<span class="cov0" title="0">
                service.Status = types.ServiceStatusPending</span>
        case generated.ServiceStatus_SERVICE_STATUS_RUNNING:<span class="cov0" title="0">
                service.Status = types.ServiceStatusRunning</span>
        case generated.ServiceStatus_SERVICE_STATUS_UPDATING:<span class="cov0" title="0">
                service.Status = types.ServiceStatusDeploying</span>
        case generated.ServiceStatus_SERVICE_STATUS_FAILED:<span class="cov0" title="0">
                service.Status = types.ServiceStatusFailed</span>
        default:<span class="cov0" title="0">
                service.Status = types.ServiceStatusPending</span>
        }

        // Convert health check
        <span class="cov0" title="0">if proto.Health != nil </span><span class="cov0" title="0">{
                service.Health = &amp;types.HealthCheck{}

                if proto.Health.Liveness != nil </span><span class="cov0" title="0">{
                        service.Health.Liveness = &amp;types.Probe{
                                InitialDelaySeconds: int(proto.Health.Liveness.InitialDelaySeconds),
                                IntervalSeconds:     int(proto.Health.Liveness.PeriodSeconds),
                                TimeoutSeconds:      int(proto.Health.Liveness.TimeoutSeconds),
                        }

                        switch proto.Health.Liveness.Type </span>{
                        case generated.ProbeType_PROBE_TYPE_HTTP:<span class="cov0" title="0">
                                service.Health.Liveness.Type = "http"
                                service.Health.Liveness.Path = proto.Health.Liveness.Path
                                service.Health.Liveness.Port = int(proto.Health.Liveness.Port)</span>
                        case generated.ProbeType_PROBE_TYPE_TCP:<span class="cov0" title="0">
                                service.Health.Liveness.Type = "tcp"
                                service.Health.Liveness.Port = int(proto.Health.Liveness.Port)</span>
                        case generated.ProbeType_PROBE_TYPE_COMMAND:<span class="cov0" title="0">
                                service.Health.Liveness.Type = "command"
                                service.Health.Liveness.Command = proto.Health.Liveness.Command</span>
                        }
                }

                <span class="cov0" title="0">if proto.Health.Readiness != nil </span><span class="cov0" title="0">{
                        service.Health.Readiness = &amp;types.Probe{
                                InitialDelaySeconds: int(proto.Health.Readiness.InitialDelaySeconds),
                                IntervalSeconds:     int(proto.Health.Readiness.PeriodSeconds),
                                TimeoutSeconds:      int(proto.Health.Readiness.TimeoutSeconds),
                        }

                        switch proto.Health.Readiness.Type </span>{
                        case generated.ProbeType_PROBE_TYPE_HTTP:<span class="cov0" title="0">
                                service.Health.Readiness.Type = "http"
                                service.Health.Readiness.Path = proto.Health.Readiness.Path
                                service.Health.Readiness.Port = int(proto.Health.Readiness.Port)</span>
                        case generated.ProbeType_PROBE_TYPE_TCP:<span class="cov0" title="0">
                                service.Health.Readiness.Type = "tcp"
                                service.Health.Readiness.Port = int(proto.Health.Readiness.Port)</span>
                        case generated.ProbeType_PROBE_TYPE_COMMAND:<span class="cov0" title="0">
                                service.Health.Readiness.Type = "command"
                                service.Health.Readiness.Command = proto.Health.Readiness.Command</span>
                        }
                }
        }

        <span class="cov0" title="0">return service, nil</span>
}

// IsNotFound returns true if the error is a "not found" error.
func IsNotFound(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // Check if the error message contains "not found"
        <span class="cov0" title="0">return strings.Contains(err.Error(), "not found")</span>
}

// WatchServices watches services for changes.
func (s *ServiceService) WatchServices(req *generated.WatchServicesRequest, stream generated.ServiceService_WatchServicesServer) error <span class="cov0" title="0">{
        s.logger.Debug("WatchServices called",
                log.Str("namespace", req.Namespace),
                log.Int("labelSelector", len(req.LabelSelector)),
                log.Int("fieldSelector", len(req.FieldSelector)))

        ctx := stream.Context()

        // Set default namespace if not specified
        namespace := req.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = DefaultNamespace
        }</span>

        // Start watching for service changes from the store
        <span class="cov0" title="0">watchCh, err := s.store.Watch(ctx, ResourceTypeService, namespace)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to watch services", log.Err(err))
                return status.Errorf(codes.Internal, "failed to watch services: %v", err)
        }</span>

        // Initialize with current services (simulating ADDED events for all existing services)
        <span class="cov0" title="0">var services []types.Service
        err = s.store.List(ctx, ResourceTypeService, namespace, &amp;services)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to list services", log.Err(err))
                return status.Errorf(codes.Internal, "failed to list initial services: %v", err)
        }</span>

        // Send all existing services as ADDED events
        <span class="cov0" title="0">for _, service := range services </span><span class="cov0" title="0">{

                // Apply selector filtering
                if !matchSelectors(&amp;service, req.LabelSelector, req.FieldSelector) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Convert to proto and send to client
                <span class="cov0" title="0">protoService, err := s.serviceModelToProto(&amp;service)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to convert service to proto", log.Err(err))
                        continue</span>
                }

                // Send to client
                <span class="cov0" title="0">err = stream.Send(&amp;generated.WatchServicesResponse{
                        Service:   protoService,
                        EventType: generated.EventType_EVENT_TYPE_ADDED,
                        Status:    &amp;generated.Status{Code: int32(codes.OK)},
                })
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to send initial service", log.Err(err))
                        return status.Errorf(codes.Internal, "failed to send initial service: %v", err)
                }</span>
        }

        // Watch loop - continue until client disconnects or context is cancelled
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        s.logger.Debug("Watch context cancelled")
                        return nil</span>

                case event, ok := &lt;-watchCh:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                s.logger.Debug("Watch channel closed")
                                return nil
                        }</span>

                        // Only handle events for services
                        <span class="cov0" title="0">if event.ResourceType != ResourceTypeService </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Convert to typed service
                        <span class="cov0" title="0">var service types.Service
                        if typedService, ok := event.Resource.(*types.Service); ok </span><span class="cov0" title="0">{
                                service = *typedService
                        }</span> else<span class="cov0" title="0"> {
                                // Use JSON marshaling/unmarshaling for conversion
                                rawData, err := json.Marshal(event.Resource)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Warn("Failed to marshal service data", log.Err(err))
                                        continue</span>
                                }

                                <span class="cov0" title="0">if err := json.Unmarshal(rawData, &amp;service); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Warn("Failed to unmarshal service data", log.Err(err))
                                        continue</span>
                                }
                        }

                        // Apply selector filtering
                        <span class="cov0" title="0">if !matchSelectors(&amp;service, req.LabelSelector, req.FieldSelector) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Convert to proto
                        <span class="cov0" title="0">protoService, err := s.serviceModelToProto(&amp;service)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to convert service to proto", log.Err(err))
                                continue</span>
                        }

                        // Map store event type to proto event type
                        <span class="cov0" title="0">var eventType generated.EventType
                        switch event.Type </span>{
                        case store.WatchEventCreated:<span class="cov0" title="0">
                                eventType = generated.EventType_EVENT_TYPE_ADDED</span>
                        case store.WatchEventUpdated:<span class="cov0" title="0">
                                eventType = generated.EventType_EVENT_TYPE_MODIFIED</span>
                        case store.WatchEventDeleted:<span class="cov0" title="0">
                                eventType = generated.EventType_EVENT_TYPE_DELETED</span>
                        default:<span class="cov0" title="0">
                                eventType = generated.EventType_EVENT_TYPE_UNSPECIFIED</span>
                        }

                        // Send to client
                        <span class="cov0" title="0">err = stream.Send(&amp;generated.WatchServicesResponse{
                                Service:   protoService,
                                EventType: eventType,
                                Status:    &amp;generated.Status{Code: int32(codes.OK)},
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to send watch event", log.Err(err))
                                return status.Errorf(codes.Internal, "failed to send watch event: %v", err)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package cmd

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/rzbill/rune/pkg/api/client"
        "github.com/rzbill/rune/pkg/cli/format"
        "github.com/rzbill/rune/pkg/cli/util"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/types"
        "github.com/spf13/cobra"
)

var (
        // Cast command flags
        namespace    string
        tag          string
        dryRun       bool
        detach       bool
        timeoutStr   string
        recursiveDir bool
        clientAPIKey string
        clientAddr   string
)

// castCmd represents the cast command
var castCmd = &amp;cobra.Command{
        Use:   "cast [service files or directories...]",
        Short: "Deploy a service",
        Long: `Deploy a service defined in a YAML file.
For example:
  rune cast my-service.yml
  rune cast my-service.yml --namespace=production
  rune cast my-service.yml --tag=stable
  rune cast my-directory/ --recursive
  rune cast services/*.yaml`,
        Args: cobra.MinimumNArgs(1),
        RunE: runCast,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(castCmd)

        // Local flags for the cast command
        castCmd.Flags().StringVarP(&amp;namespace, "namespace", "n", "default", "Namespace to deploy the service in")
        castCmd.Flags().StringVar(&amp;tag, "tag", "", "Tag for this deployment (e.g., 'stable', 'canary')")
        castCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Validate the service definition without deploying it")
        castCmd.Flags().BoolVar(&amp;detach, "detach", false, "Detach from the deployment and return immediately")
        castCmd.Flags().StringVar(&amp;timeoutStr, "timeout", "5m", "Timeout for the wait operation")
        castCmd.Flags().BoolVarP(&amp;recursiveDir, "recursive", "r", false, "Recursively process directories")

        // API client flags
        castCmd.Flags().StringVar(&amp;clientAPIKey, "api-key", "", "API key for authentication")
        castCmd.Flags().StringVar(&amp;clientAddr, "api-server", "", "Address of the API server")
}</span>

// runCast is the main entry point for the cast command
func runCast(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        startTime := time.Now()

        // Parse timeout duration
        timeout, err := time.ParseDuration(timeoutStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid timeout value: %w", err)
        }</span>

        // Expand file paths (including directories and glob patterns)
        <span class="cov0" title="0">filePaths, err := util.ExpandFilePaths(args, recursiveDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(filePaths) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no service files found")
        }</span>

        // Print initial cast banner
        <span class="cov0" title="0">printCastBanner(args, detach)

        // Load, categorize, and validate resources
        resourceInfo, err := processResourceFiles(filePaths, args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If dry-run is enabled, we're done here
        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                fmt.Println(" Validation successful!")
                fmt.Println(" Use without --dry-run to deploy.")
                return nil
        }</span>

        // Create API client
        <span class="cov0" title="0">apiClient, err := createAPIClient()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to API server: %w", err)
        }</span>
        <span class="cov0" title="0">defer apiClient.Close()

        // Print deployment preparation
        fmt.Println(" Preparing deployment plan...")
        fmt.Println()

        // Deploy resources
        deploymentResults, err := deployResources(apiClient, resourceInfo, timeout)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Print summary based on deployment mode
        <span class="cov0" title="0">if detach </span><span class="cov0" title="0">{
                printDetachedModeSummary(deploymentResults, startTime)
        }</span> else<span class="cov0" title="0"> {
                printWatchModeSummary(deploymentResults, startTime)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ResourceInfo holds information about resources to be deployed
type ResourceInfo struct {
        FilesByType     map[string][]string
        ServicesByFile  map[string][]*types.Service
        TotalResources  int
        SourceArguments []string
}

// processResourceFiles loads, categorizes, and validates resources from files
func processResourceFiles(filePaths []string, sourceArgs []string) (*ResourceInfo, error) <span class="cov8" title="1">{
        info := &amp;ResourceInfo{
                FilesByType:     make(map[string][]string),
                ServicesByFile:  make(map[string][]*types.Service),
                TotalResources:  0,
                SourceArguments: sourceArgs,
        }

        // Print detected resources header
        fmt.Println(" Validating specifications...")

        // First pass: load and validate services
        for _, filePath := range filePaths </span><span class="cov8" title="1">{
                fileName := filepath.Base(filePath)

                // Format the filename with fixed width padding for display
                fileNameDisplay := fmt.Sprintf("- %-20s", fileName)

                // Print filename (without newline)
                fmt.Print(fileNameDisplay)

                // Calculate and print dots
                totalWidth := 35
                dotsNeeded := totalWidth - len(fileNameDisplay)
                if dotsNeeded &lt; 3 </span><span class="cov0" title="0">{
                        dotsNeeded = 3
                }</span>
                <span class="cov8" title="1">fmt.Print(strings.Repeat(".", dotsNeeded))
                fmt.Print(" ") // Space before validation result

                // Parse the service file
                serviceFile, err := types.ParseServiceFile(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("") // Show failure
                        return nil, fmt.Errorf("failed to parse file %s: %w", filePath, err)
                }</span>

                // Get all services from the file
                <span class="cov8" title="1">serviceSpecs := serviceFile.GetServices()
                if len(serviceSpecs) == 0 </span><span class="cov0" title="0">{
                        fmt.Println(" No services") // Show warning
                        continue</span>
                }

                // Convert specs to services and validate them
                <span class="cov8" title="1">services := make([]*types.Service, 0, len(serviceSpecs))
                validationSuccessful := true

                for _, spec := range serviceSpecs </span><span class="cov8" title="1">{
                        // Validate the service spec
                        if err := spec.Validate(); err != nil </span><span class="cov8" title="1">{
                                fmt.Println("") // Show failure

                                // Try to get line number for better error reporting
                                line, ok := serviceFile.GetLineInfo(spec.Name)
                                if ok </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("validation error in %s, line %d, service %s: %w",
                                                filePath, line, spec.Name, err)
                                }</span>
                                <span class="cov0" title="0">return nil, fmt.Errorf("validation error in %s, service %s: %w",
                                        filePath, spec.Name, err)</span>
                        }

                        // Convert to service
                        <span class="cov8" title="1">service, err := spec.ToService()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println("") // Show failure
                                validationSuccessful = false
                                return nil, fmt.Errorf("failed to convert service spec: %w", err)
                        }</span>

                        <span class="cov8" title="1">services = append(services, service)</span>
                }

                // Show success checkmark if all validations passed
                <span class="cov8" title="1">if validationSuccessful </span><span class="cov8" title="1">{
                        fmt.Println("")
                }</span>

                <span class="cov8" title="1">info.ServicesByFile[filePath] = services
                info.TotalResources += len(services)

                // Categorize resources by type
                for _, service := range services </span><span class="cov8" title="1">{
                        resourceType := guessResourceTypeFromName(filePath, service.Name)
                        if _, exists := info.FilesByType[resourceType]; !exists </span><span class="cov8" title="1">{
                                info.FilesByType[resourceType] = []string{}
                        }</span>
                        <span class="cov8" title="1">if !stringSliceContains(info.FilesByType[resourceType], fileName) </span><span class="cov8" title="1">{
                                info.FilesByType[resourceType] = append(info.FilesByType[resourceType], fileName)
                        }</span>
                }
        }

        <span class="cov8" title="1">fmt.Println()

        // Print detected resources
        printResourceInfo(info)

        return info, nil</span>
}

// DeploymentResult holds results of a deployment
type DeploymentResult struct {
        SuccessfulResources map[string][]string
        FailedResources     map[string]string
}

// deployResources handles the actual deployment of services to the cluster
func deployResources(apiClient *client.Client, info *ResourceInfo, timeout time.Duration) (*DeploymentResult, error) <span class="cov0" title="0">{
        results := &amp;DeploymentResult{
                SuccessfulResources: make(map[string][]string),
                FailedResources:     make(map[string]string),
        }

        fmt.Println(" Casting resources to Rune Cluster...")

        serviceClient := client.NewServiceClient(apiClient)

        resourceCount := info.TotalResources
        resourceIndex := 0

        for filePath, services := range info.ServicesByFile </span><span class="cov0" title="0">{
                for _, service := range services </span><span class="cov0" title="0">{
                        resourceIndex++

                        // Apply namespace if not specified in the service
                        if service.Namespace == "" </span><span class="cov0" title="0">{
                                service.Namespace = namespace
                        }</span>

                        // Add deployment tag metadata if specified
                        <span class="cov0" title="0">if tag != "" </span><span class="cov0" title="0">{
                                if service.Env == nil </span><span class="cov0" title="0">{
                                        service.Env = make(map[string]string)
                                }</span>
                                <span class="cov0" title="0">service.Env["RUNE_DEPLOYMENT_TAG"] = tag</span>
                        }

                        // Determine resource type for display
                        <span class="cov0" title="0">resourceType := guessResourceTypeFromName(filePath, service.Name)

                        // Check if service already exists - determine if creating or updating
                        action := "Creating"
                        _, err := serviceClient.GetService(service.Namespace, service.Name)
                        if err == nil </span><span class="cov0" title="0">{
                                action = "Deploying"
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("  [%d/%d] %s %s \"%s\" ",
                                resourceIndex, resourceCount,
                                action,
                                resourceType,
                                format.Highlight(service.Name))

                        // Print dots for alignment
                        dotCount := 25 - len(action) - len(resourceType) - len(service.Name)
                        if dotCount &lt; 3 </span><span class="cov0" title="0">{
                                dotCount = 3
                        }</span>
                        <span class="cov0" title="0">fmt.Print(strings.Repeat(".", dotCount))

                        var deployErr error
                        if action == "Creating" </span><span class="cov0" title="0">{
                                deployErr = serviceClient.CreateService(service)
                        }</span> else<span class="cov0" title="0"> {
                                deployErr = serviceClient.UpdateService(service)
                        }</span>

                        <span class="cov0" title="0">if deployErr != nil </span><span class="cov0" title="0">{
                                fmt.Println(" ")
                                results.FailedResources[service.Name] = deployErr.Error()

                                // For error cases, show the error and stop deployment
                                fmt.Println()
                                fmt.Printf(" Failed to deploy %s \"%s\"\n", resourceType, service.Name)
                                fmt.Printf("Error: %s\n", deployErr)

                                // If we have successful resources, show them
                                if len(results.SuccessfulResources) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Println()
                                        fmt.Println(" Successfully deployed:")
                                        for rType, names := range results.SuccessfulResources </span><span class="cov0" title="0">{
                                                for _, name := range names </span><span class="cov0" title="0">{
                                                        fmt.Printf("- %s: %s\n", rType, name)
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">fmt.Println()
                                fmt.Println(" Aborted remaining deployments to maintain consistency.")
                                fmt.Printf("Hint: Fix the %s spec and re-run 'rune cast %s'\n", strings.ToLower(resourceType), info.SourceArguments[0])

                                return results, fmt.Errorf("deployment failed")</span>
                        }

                        <span class="cov0" title="0">fmt.Println(" ")

                        // Add to successful resources
                        results.SuccessfulResources[resourceType] = append(results.SuccessfulResources[resourceType], service.Name)

                        // If detach is not enabled, wait for the service to be ready
                        if !detach </span><span class="cov0" title="0">{
                                // For watch mode, we wait for each service to become ready
                                waitErr := waitForServiceReady(serviceClient, service.Namespace, service.Name, timeout)
                                if waitErr != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("      Service is still starting (timeout: %s): %s\n",
                                                timeoutStr, waitErr)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">fmt.Println()
        return results, nil</span>
}

// printCastBanner prints the initial banner for the cast command
func printCastBanner(args []string, isDetached bool) <span class="cov0" title="0">{
        if isDetached </span><span class="cov0" title="0">{
                fmt.Println("\n Rune Cast Initiated (Detached Mode)")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("\n Rune Cast Initiated")
        }</span>

        // Print source info
        <span class="cov0" title="0">fmt.Println("\n- Source:", format.Highlight(strings.Join(args, ", ")))
        fmt.Println()</span>
}

// printResourceInfo displays information about detected resources
func printResourceInfo(info *ResourceInfo) <span class="cov8" title="1">{
        // Print detected resources
        fmt.Printf("- Detected %d resources:\n", info.TotalResources)
        for resourceType, files := range info.FilesByType </span><span class="cov8" title="1">{
                for _, file := range files </span><span class="cov8" title="1">{
                        fmt.Printf("  - %s: %s\n", resourceType, file)
                }</span>
        }

        <span class="cov8" title="1">fmt.Println("- Namespace:", format.Highlight(namespace))

        // Determine target display name
        targetDisplay := "local agent"
        if clientAddr != "" </span><span class="cov0" title="0">{
                targetDisplay = clientAddr
        }</span> else<span class="cov8" title="1"> {
                // Get default address from client options
                options := client.DefaultClientOptions()
                targetDisplay = options.Address
        }</span>
        <span class="cov8" title="1">fmt.Printf("- Target: %s (%s)\n", format.Highlight(targetDisplay), targetDisplay)
        fmt.Println()

        if dryRun </span><span class="cov0" title="0">{
                fmt.Println(" Running in dry-run mode (validation only)")
        }</span>
}

// printDetachedModeSummary prints a summary for detached mode
func printDetachedModeSummary(results *DeploymentResult, startTime time.Time) <span class="cov0" title="0">{
        fmt.Println(" Deployment initiated (no watch mode).")
        fmt.Println()
        fmt.Println(" Status commands:")

        // Suggest some commands for checking status
        for resourceType, names := range results.SuccessfulResources </span><span class="cov0" title="0">{
                if resourceType == "Service" || resourceType == "Function" </span><span class="cov0" title="0">{
                        for _, name := range names </span><span class="cov0" title="0">{
                                fmt.Printf("- rune trace %s\n", name)
                        }</span>
                }
        }
        <span class="cov0" title="0">fmt.Println("- rune status")
        fmt.Println("- rune list")

        elapsedTime := time.Since(startTime).Seconds()
        fmt.Printf("\n Done in %.1fs (deployment is ongoing in background).\n", elapsedTime)</span>
}

// printWatchModeSummary prints a summary for watch mode
func printWatchModeSummary(results *DeploymentResult, startTime time.Time) <span class="cov0" title="0">{
        fmt.Println(" Successfully deployed:")

        // Show resources with endpoints where applicable
        for resourceType, names := range results.SuccessfulResources </span><span class="cov0" title="0">{
                for _, name := range names </span><span class="cov0" title="0">{
                        endpoint := ""
                        if resourceType == "Service" </span><span class="cov0" title="0">{
                                endpoint = fmt.Sprintf(" (endpoint: http://%s.%s.rune)", name, namespace)
                        }</span> else<span class="cov0" title="0"> if resourceType == "Function" </span><span class="cov0" title="0">{
                                endpoint = fmt.Sprintf(" (endpoint: http://%s.%s.rune)", name, namespace)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("- %s: %s%s\n", resourceType, name, endpoint)</span>
                }
        }

        // Show tips
        <span class="cov0" title="0">fmt.Println()
        fmt.Println(" Tips:")

        // Add service-specific tips
        for resourceType, names := range results.SuccessfulResources </span><span class="cov0" title="0">{
                if resourceType == "Service" </span><span class="cov0" title="0">{
                        for _, name := range names </span><span class="cov0" title="0">{
                                fmt.Printf("- Monitor: rune trace %s\n", name)
                                fmt.Printf("- Scale Service: rune scale %s --replicas=2\n", name)
                        }</span>
                } else<span class="cov0" title="0"> if resourceType == "Function" </span><span class="cov0" title="0">{
                        for _, name := range names </span><span class="cov0" title="0">{
                                fmt.Printf("- Function Logs: rune trace %s\n", name)
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Println("- List Resources: rune list")

        elapsedTime := time.Since(startTime).Seconds()
        fmt.Printf("\n All resources ready in %.1fs\n", elapsedTime)</span>
}

// determineResourceType guesses the resource type based on file path and name
func guessResourceTypeFromName(filePath, serviceName string) string <span class="cov8" title="1">{
        resourceType := "Service"
        if strings.Contains(filePath, "secret") || strings.Contains(serviceName, "secret") </span><span class="cov0" title="0">{
                resourceType = "Secret"
        }</span> else<span class="cov8" title="1"> if strings.Contains(filePath, "function") || strings.Contains(serviceName, "fn") </span><span class="cov0" title="0">{
                resourceType = "Function"
        }</span>
        <span class="cov8" title="1">return resourceType</span>
}

// contains checks if a string slice contains a specific value
func stringSliceContains(slice []string, value string) bool <span class="cov8" title="1">{
        for _, item := range slice </span><span class="cov8" title="1">{
                if item == value </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// createAPIClient creates an API client with the configured options.
func createAPIClient() (*client.Client, error) <span class="cov0" title="0">{
        options := client.DefaultClientOptions()

        // Override defaults with command-line flags if set
        if clientAddr != "" </span><span class="cov0" title="0">{
                options.Address = clientAddr
        }</span>

        <span class="cov0" title="0">if clientAPIKey != "" </span><span class="cov0" title="0">{
                options.APIKey = clientAPIKey
        }</span> else<span class="cov0" title="0"> {
                // Try to get API key from environment
                if apiKey, ok := os.LookupEnv("RUNE_API_KEY"); ok </span><span class="cov0" title="0">{
                        options.APIKey = apiKey
                }</span>
        }

        // Create the client
        <span class="cov0" title="0">return client.NewClient(options)</span>
}

// waitForServiceReady waits for a service to be fully deployed.
func waitForServiceReady(serviceClient *client.ServiceClient, namespace, name string, timeout time.Duration) error <span class="cov0" title="0">{
        // Create a context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // Poll interval
        pollInterval := 1 * time.Second

        // Create a ticker for polling
        ticker := time.NewTicker(pollInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // Timeout
                        return fmt.Errorf("timeout waiting for service %s to be ready", name)</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Poll the service status
                        service, err := serviceClient.GetService(namespace, name)

                        fmt.Println("service", service.Status)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debug("Error getting service status", log.Err(err))
                                continue</span>
                        }

                        // Check if the service is running
                        <span class="cov0" title="0">if service.Status == types.ServiceStatusRunning </span><span class="cov0" title="0">{
                                // Check that all instances are ready
                                allReady := true
                                readyCount := 0

                                for _, instance := range service.Instances </span><span class="cov0" title="0">{
                                        if instance.Status == "Running" || instance.Status == "Ready" </span><span class="cov0" title="0">{
                                                readyCount++
                                        }</span> else<span class="cov0" title="0"> {
                                                allReady = false
                                        }</span>
                                }

                                // If all instances are ready, or at least some are ready and the service scale is met
                                <span class="cov0" title="0">if (allReady &amp;&amp; len(service.Instances) &gt; 0) || (readyCount &gt;= service.Scale) </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package cmd

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "sort"
        "strings"

        "github.com/rzbill/rune/pkg/api/client"
        "github.com/rzbill/rune/pkg/cli/format"
        "github.com/rzbill/rune/pkg/types"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        // Get command flags
        getNamespace    string
        allNamespaces   bool
        getOutputFormat string
        watchResources  bool
        labelSelector   string
        fieldSelector   string
        sortBy          string
        showLabels      bool
        noHeaders       bool
        limit           int
        getClientAPIKey string
        getClientAddr   string
        watchTimeout    string
        getServiceName  string
)

// Resource type abbreviations
var resourceAliases = map[string]string{
        // Full names
        "service":    "service",
        "services":   "service",
        "instance":   "instance",
        "instances":  "instance",
        "namespace":  "namespace",
        "namespaces": "namespace",
        "job":        "job",
        "jobs":       "job",
        "config":     "config",
        "configs":    "config",
        "secret":     "secret",
        "secrets":    "secret",
        // Abbreviations
        "svc":  "service",
        "inst": "instance",
        "ns":   "namespace",
        "cfg":  "config",
}

// ServiceWatcher defines the interface for watching services
type ServiceWatcher interface {
        WatchServices(namespace, labelSelector, fieldSelector string) (&lt;-chan client.WatchEvent, error)
}

// InstanceWatcher defines the interface for watching instances
type InstanceWatcher interface {
        WatchInstances(namespace, serviceId, labelSelector, fieldSelector string) (&lt;-chan client.InstanceWatchEvent, error)
}

// getCmd represents the get command
var getCmd = &amp;cobra.Command{
        Use:   "get &lt;resource-type&gt; [resource-name] [flags]",
        Short: "Display one or many resources",
        Long: `Display one or many resources.
The resource types include:
  * services (svc)
  * instances (inst)
  * namespaces (ns)
  * jobs
  * configs
  * secrets`,
        Args: cobra.MinimumNArgs(1),
        RunE: runGet,
        Example: `  # List all services in the current namespace
  rune get services
  
  # List a specific service in YAML format
  rune get service my-service --output=yaml
  
  # List all services in all namespaces
  rune get services --all-namespaces
  
  # List services with real-time updates
  rune get services --watch
  
  # List services filtered by labels
  rune get services --selector=app=backend`,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(getCmd)

        // Local flags for the get command
        getCmd.Flags().StringVarP(&amp;getNamespace, "namespace", "n", "default", "Namespace to list resources from")
        getCmd.Flags().BoolVarP(&amp;allNamespaces, "all-namespaces", "A", false, "List resources across all namespaces")
        getCmd.Flags().StringVarP(&amp;getOutputFormat, "output", "o", "table", "Output format (table, json, yaml)")
        getCmd.Flags().BoolVarP(&amp;watchResources, "watch", "w", false, "Watch for changes and update in real-time")
        getCmd.Flags().StringVarP(&amp;labelSelector, "selector", "l", "", "Filter resources by label selector (e.g., app=frontend)")
        getCmd.Flags().StringVar(&amp;fieldSelector, "field-selector", "", "Filter resources by field selector (e.g., status=running)")
        getCmd.Flags().StringVar(&amp;sortBy, "sort-by", "name", "Sort resources by field (name, creationTime, status)")
        getCmd.Flags().BoolVar(&amp;showLabels, "show-labels", false, "Show labels as the last column (table output only)")
        getCmd.Flags().BoolVar(&amp;noHeaders, "no-headers", false, "Don't print headers for table output")
        getCmd.Flags().IntVar(&amp;limit, "limit", 0, "Maximum number of resources to list (0 for unlimited)")
        getCmd.Flags().StringVar(&amp;watchTimeout, "timeout", "", "Timeout for watch operations (e.g., 30s, 5m, 1h) - default is no timeout")
        getCmd.Flags().StringVar(&amp;getServiceName, "service-name", "", "Filter instances by service name")

        // API client flags
        getCmd.Flags().StringVar(&amp;getClientAPIKey, "api-key", "", "API key for authentication")
        getCmd.Flags().StringVar(&amp;getClientAddr, "api-server", "", "Address of the API server")
}</span>

// runGet is the main entry point for the get command
func runGet(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Resolve resource type from the first argument
        resourceType, err := resolveResourceType(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get resource name if provided
        <span class="cov0" title="0">var resourceName string
        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                resourceName = args[1]
        }</span>

        // Create API client
        <span class="cov0" title="0">apiClient, err := createGetAPIClient()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to API server: %w", err)
        }</span>
        <span class="cov0" title="0">defer apiClient.Close()

        // Create context
        ctx := context.Background()

        // Process the request based on resource type
        switch resourceType </span>{
        case "service":<span class="cov0" title="0">
                return handleServiceGet(ctx, cmd, apiClient, resourceName)</span>
        case "instance":<span class="cov0" title="0">
                return handleInstanceGet(ctx, cmd, apiClient, resourceName)</span>
        case "namespace":<span class="cov0" title="0">
                return handleNamespaceGet(ctx, cmd, apiClient, resourceName)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported resource type: %s", args[0])</span>
        }
}

// resolveResourceType resolves a resource type from user input to a canonical type
func resolveResourceType(input string) (string, error) <span class="cov8" title="1">{
        // Lookup the resource type alias
        if resourceType, ok := resourceAliases[input]; ok </span><span class="cov8" title="1">{
                return resourceType, nil
        }</span>

        <span class="cov8" title="1">return "", fmt.Errorf("unsupported resource type: %s", input)</span>
}

// handleServiceGet handles get operations for services
func handleServiceGet(ctx context.Context, cmd *cobra.Command, apiClient *client.Client, resourceName string) error <span class="cov0" title="0">{
        serviceClient := client.NewServiceClient(apiClient)

        // If watch mode is enabled, handle watching
        if watchResources </span><span class="cov0" title="0">{
                return watchServices(ctx, serviceClient, resourceName)
        }</span>

        // If a specific service name is provided, get that service
        <span class="cov0" title="0">if resourceName != "" </span><span class="cov0" title="0">{
                namespace := getNamespace
                service, err := serviceClient.GetService(namespace, resourceName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get service %s: %w", resourceName, err)
                }</span>

                <span class="cov0" title="0">return outputResource([]*types.Service{service}, cmd)</span>
        }

        // Otherwise, list services based on the namespace flag
        <span class="cov0" title="0">var services []*types.Service
        var err error

        if allNamespaces </span><span class="cov0" title="0">{
                // List services across all namespaces using the asterisk wildcard
                services, err = serviceClient.ListServices("*", labelSelector, fieldSelector)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list services across all namespaces: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                services, err = serviceClient.ListServices(getNamespace, labelSelector, fieldSelector)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list services: %w", err)
                }</span>
        }

        // Sort services (client-side sorting is still fine)
        <span class="cov0" title="0">sortServices(services, sortBy)

        // Apply limit if specified
        if limit &gt; 0 &amp;&amp; len(services) &gt; limit </span><span class="cov0" title="0">{
                services = services[:limit]
        }</span>

        <span class="cov0" title="0">return outputResource(services, cmd)</span>
}

// handleInstanceGet handles get operations for instances
func handleInstanceGet(ctx context.Context, cmd *cobra.Command, apiClient *client.Client, resourceName string) error <span class="cov0" title="0">{
        instanceClient := client.NewInstanceClient(apiClient)

        // If watch mode is enabled, handle watching
        if watchResources </span><span class="cov0" title="0">{
                return watchInstances(ctx, instanceClient, resourceName)
        }</span>

        // If a specific instance name is provided, get that instance
        <span class="cov0" title="0">if resourceName != "" </span><span class="cov0" title="0">{
                namespace := getNamespace
                instance, err := instanceClient.GetInstance(namespace, resourceName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get instance: %w", err)
                }</span>

                // Render a single instance
                <span class="cov0" title="0">if getOutputFormat == "" </span><span class="cov0" title="0">{
                        // Create table for a single instance
                        table := NewResourceTable()
                        table.RenderInstances([]*types.Instance{instance})
                        return nil
                }</span>

                // Handle JSON/YAML output for a single instance
                <span class="cov0" title="0">return outputResource([]*types.Instance{instance}, cmd)</span>
        }

        // Get all instances with optional filtering
        <span class="cov0" title="0">instances, err := instanceClient.ListInstances(getNamespace, getServiceName, labelSelector, fieldSelector)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list instances: %w", err)
        }</span>

        // Render the instances
        <span class="cov0" title="0">if getOutputFormat == "" </span><span class="cov0" title="0">{
                // Create table with configured options
                table := NewResourceTable()
                table.AllNamespaces = allNamespaces
                table.ShowLabels = showLabels
                table.RenderInstances(instances)
                return nil
        }</span>

        // Handle JSON/YAML output
        <span class="cov0" title="0">return outputResource(instances, cmd)</span>
}

// handleNamespaceGet handles get operations for namespaces
func handleNamespaceGet(ctx context.Context, cmd *cobra.Command, apiClient *client.Client, resourceName string) error <span class="cov0" title="0">{
        // TODO: Implement namespace listing when API client supports it
        return fmt.Errorf("namespace listing not yet implemented")
}</span>

// watchServices watches services for changes
func watchServices(ctx context.Context, serviceClient ServiceWatcher, resourceName string) error <span class="cov8" title="1">{
        // Create and configure the resource watcher
        watcher := NewResourceWatcher()
        watcher.Namespace = getNamespace
        watcher.AllNamespaces = allNamespaces
        watcher.ResourceName = resourceName
        watcher.LabelSelector = labelSelector
        watcher.FieldSelector = fieldSelector
        watcher.ShowHeaders = !noHeaders

        // Set timeout if specified
        if watchTimeout != "" </span><span class="cov0" title="0">{
                if err := watcher.SetTimeout(watchTimeout); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Use default renderers for services
        <span class="cov8" title="1">watcher.SetResourceToRowsRenderer(DefaultServiceResourceToRows)
        watcher.SetEventRenderer(DefaultServiceEventRenderer)

        // Create adapter to convert ServiceWatcher to ResourceToWatch
        adapter := &amp;ServiceWatcherAdapter{ServiceWatcher: serviceClient}

        // Start watching
        return watcher.Watch(ctx, adapter)</span>
}

// watchInstances watches instances for changes
func watchInstances(ctx context.Context, instanceClient InstanceWatcher, resourceName string) error <span class="cov0" title="0">{
        // Create and configure the resource watcher
        watcher := NewResourceWatcher()
        watcher.Namespace = getNamespace
        watcher.AllNamespaces = allNamespaces
        watcher.ResourceName = resourceName
        watcher.LabelSelector = labelSelector
        watcher.FieldSelector = fieldSelector
        watcher.ShowHeaders = !noHeaders

        // Set timeout if specified
        if watchTimeout != "" </span><span class="cov0" title="0">{
                if err := watcher.SetTimeout(watchTimeout); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Use default renderers for instances
        <span class="cov0" title="0">watcher.SetResourceToRowsRenderer(DefaultInstanceResourceToRows)
        watcher.SetEventRenderer(DefaultInstanceEventRenderer)

        // Create adapter to convert InstanceWatcher to ResourceToWatch
        adapter := &amp;InstanceWatcherAdapter{InstanceWatcher: instanceClient}

        // Start watching
        return watcher.Watch(ctx, adapter)</span>
}

// outputResource outputs a resource in the specified format
func outputResource(resources interface{}, cmd *cobra.Command) error <span class="cov0" title="0">{
        switch getOutputFormat </span>{
        case "json":<span class="cov0" title="0">
                return outputJSON(resources)</span>
        case "yaml":<span class="cov0" title="0">
                return outputYAML(resources)</span>
        case "table", "":<span class="cov0" title="0">
                return outputTable(resources)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s", getOutputFormat)</span>
        }
}

// outputJSON outputs resources in JSON format
func outputJSON(resources interface{}) error <span class="cov0" title="0">{
        jsonData, err := json.MarshalIndent(resources, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal resources to JSON: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(string(jsonData))
        return nil</span>
}

// outputYAML outputs resources in YAML format
func outputYAML(resources interface{}) error <span class="cov0" title="0">{
        yamlData, err := yaml.Marshal(resources)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal resources to YAML: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(string(yamlData))
        return nil</span>
}

// outputTable outputs resources in table format
func outputTable(resources interface{}) error <span class="cov0" title="0">{
        switch r := resources.(type) </span>{
        case []*types.Service:<span class="cov0" title="0">
                return outputServicesTable(r)</span>
        case []*types.Instance:<span class="cov0" title="0">
                return outputInstancesTable(r)</span>
        case []*types.Namespace:<span class="cov0" title="0">
                return outputNamespacesTable(r)</span>
        // TODO: Add more resource types here
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported resource type for table output")</span>
        }
}

// outputServicesTable outputs services in a formatted table
func outputServicesTable(services []*types.Service) error <span class="cov0" title="0">{
        // Create and configure the table renderer
        table := NewResourceTable()
        table.AllNamespaces = allNamespaces
        table.ShowHeaders = !noHeaders
        table.ShowLabels = showLabels

        // Render the table
        return table.RenderServices(services)
}</span>

// outputInstancesTable outputs instances in a formatted table
func outputInstancesTable(instances []*types.Instance) error <span class="cov0" title="0">{
        // Create and configure the table renderer
        table := NewResourceTable()
        table.AllNamespaces = allNamespaces
        table.ShowHeaders = !noHeaders
        table.ShowLabels = showLabels

        // Render the table
        return table.RenderInstances(instances)
}</span>

// outputNamespacesTable outputs namespaces in a formatted table
func outputNamespacesTable(namespaces []*types.Namespace) error <span class="cov0" title="0">{
        // Create and configure the table renderer
        table := NewResourceTable()
        table.ShowHeaders = !noHeaders
        table.ShowLabels = showLabels

        // Render the table
        return table.RenderNamespaces(namespaces)
}</span>

// parseSelector parses a selector string into a map of key-value pairs
func parseSelector(selector string) (map[string]string, error) <span class="cov8" title="1">{
        result := make(map[string]string)
        if selector == "" </span><span class="cov8" title="1">{
                return result, nil
        }</span>

        <span class="cov8" title="1">pairs := strings.Split(selector, ",")
        for _, pair := range pairs </span><span class="cov8" title="1">{
                parts := strings.SplitN(pair, "=", 2)
                if len(parts) != 2 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid selector format, expected key=value: %s", pair)
                }</span>
                <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])
                if key == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("empty key in selector: %s", pair)
                }</span>
                <span class="cov8" title="1">if value == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("empty value in selector: %s", pair)
                }</span>
                <span class="cov8" title="1">if strings.Contains(value, "=") </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid value format, contains additional equals sign: %s", value)
                }</span>
                <span class="cov8" title="1">result[key] = value</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// sortServices sorts services based on the specified sort field
func sortServices(services []*types.Service, sortField string) <span class="cov8" title="1">{
        switch sortField </span>{
        case "name":<span class="cov8" title="1">
                sort.Slice(services, func(i, j int) bool </span><span class="cov8" title="1">{
                        return services[i].Name &lt; services[j].Name
                }</span>)
        case "creationTime", "age":<span class="cov8" title="1">
                sort.Slice(services, func(i, j int) bool </span><span class="cov8" title="1">{
                        return services[i].CreatedAt.Before(services[j].CreatedAt)
                }</span>)
        case "status":<span class="cov8" title="1">
                sort.Slice(services, func(i, j int) bool </span><span class="cov8" title="1">{
                        return string(services[i].Status) &lt; string(services[j].Status)
                }</span>)
        }
}

// sortInstances sorts a list of instances based on the sort criteria
func sortInstances(instances []*types.Instance, sortBy string) <span class="cov0" title="0">{
        switch sortBy </span>{
        case "name":<span class="cov0" title="0">
                sort.Slice(instances, func(i, j int) bool </span><span class="cov0" title="0">{
                        return instances[i].Name &lt; instances[j].Name
                }</span>)
        case "age":<span class="cov0" title="0">
                sort.Slice(instances, func(i, j int) bool </span><span class="cov0" title="0">{
                        return instances[i].CreatedAt.Before(instances[j].CreatedAt)
                }</span>)
        case "status":<span class="cov0" title="0">
                sort.Slice(instances, func(i, j int) bool </span><span class="cov0" title="0">{
                        return string(instances[i].Status) &lt; string(instances[j].Status)
                }</span>)
        case "service":<span class="cov0" title="0">
                sort.Slice(instances, func(i, j int) bool </span><span class="cov0" title="0">{
                        return instances[i].ServiceID &lt; instances[j].ServiceID
                }</span>)
        case "node":<span class="cov0" title="0">
                sort.Slice(instances, func(i, j int) bool </span><span class="cov0" title="0">{
                        return instances[i].NodeID &lt; instances[j].NodeID
                }</span>)
        default:<span class="cov0" title="0">
                // Default to sorting by name
                sort.Slice(instances, func(i, j int) bool </span><span class="cov0" title="0">{
                        return instances[i].Name &lt; instances[j].Name
                }</span>)
        }
}

// createGetAPIClient creates an API client with the configured options.
func createGetAPIClient() (*client.Client, error) <span class="cov0" title="0">{
        options := client.DefaultClientOptions()

        // Override defaults with command-line flags if set
        if getClientAddr != "" </span><span class="cov0" title="0">{
                options.Address = getClientAddr
        }</span>

        <span class="cov0" title="0">if getClientAPIKey != "" </span><span class="cov0" title="0">{
                options.APIKey = getClientAPIKey
        }</span> else<span class="cov0" title="0"> {
                // Try to get API key from environment
                if apiKey, ok := os.LookupEnv("RUNE_API_KEY"); ok </span><span class="cov0" title="0">{
                        options.APIKey = apiKey
                }</span>
        }

        // Create the client
        <span class="cov0" title="0">return client.NewClient(options)</span>
}

// InstanceResource is a wrapper around types.Instance that implements the Resource interface
type InstanceResource struct {
        *types.Instance
}

// GetKey returns a unique identifier for the instance
func (i InstanceResource) GetKey() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s", i.Namespace, i.ID)
}</span>

// Equals checks if two instances are functionally equivalent for watch purposes
func (i InstanceResource) Equals(other Resource) bool <span class="cov0" title="0">{
        otherInstance, ok := other.(InstanceResource)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check key fields that would make an instance visibly different in the table
        <span class="cov0" title="0">return i.ID == otherInstance.ID &amp;&amp;
                i.Name == otherInstance.Name &amp;&amp;
                i.Namespace == otherInstance.Namespace &amp;&amp;
                i.ServiceID == otherInstance.ServiceID &amp;&amp;
                i.NodeID == otherInstance.NodeID &amp;&amp;
                i.Status == otherInstance.Status</span>
}

// InstanceWatcherAdapter adapts the InstanceWatcher interface to ResourceToWatch
type InstanceWatcherAdapter struct {
        InstanceWatcher
}

// Watch implements the ResourceToWatch interface
func (a InstanceWatcherAdapter) Watch(ctx context.Context, namespace, labelSelector, fieldSelector string) (&lt;-chan WatchEvent, error) <span class="cov0" title="0">{
        // Parse any service filter from fieldSelector
        serviceID := ""
        fieldSelectorMap, err := parseSelector(fieldSelector)
        if err == nil </span><span class="cov0" title="0">{
                if svc, exists := fieldSelectorMap["service"]; exists </span><span class="cov0" title="0">{
                        serviceID = svc
                        // Remove from field selector to avoid double filtering
                        delete(fieldSelectorMap, "service")
                        // Rebuild field selector string
                        var pairs []string
                        for k, v := range fieldSelectorMap </span><span class="cov0" title="0">{
                                pairs = append(pairs, fmt.Sprintf("%s=%s", k, v))
                        }</span>
                        <span class="cov0" title="0">fieldSelector = strings.Join(pairs, ",")</span>
                }
        }

        <span class="cov0" title="0">instCh, err := a.WatchInstances(namespace, serviceID, labelSelector, fieldSelector)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create a new channel and adapt the events
        <span class="cov0" title="0">eventCh := make(chan WatchEvent)
        go func() </span><span class="cov0" title="0">{
                defer close(eventCh)

                for event := range instCh </span><span class="cov0" title="0">{
                        if event.Error != nil </span><span class="cov0" title="0">{
                                eventCh &lt;- WatchEvent{
                                        Error: event.Error,
                                }
                                continue</span>
                        }

                        // Convert instance to InstanceResource
                        <span class="cov0" title="0">instResource := InstanceResource{event.Instance}

                        eventCh &lt;- WatchEvent{
                                Resource:  instResource,
                                EventType: event.EventType,
                                Error:     nil,
                        }</span>
                }
        }()

        <span class="cov0" title="0">return eventCh, nil</span>
}

// DefaultInstanceResourceToRows returns a default row renderer for instances
func DefaultInstanceResourceToRows(resources []Resource) [][]string <span class="cov0" title="0">{
        // First create a list of just the instances
        instances := make([]*types.Instance, 0, len(resources))
        for _, res := range resources </span><span class="cov0" title="0">{
                instRes, ok := res.(InstanceResource)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">instances = append(instances, instRes.Instance)</span>
        }

        // Sort instances by name
        <span class="cov0" title="0">sort.Slice(instances, func(i, j int) bool </span><span class="cov0" title="0">{
                return instances[i].Name &lt; instances[j].Name
        }</span>)

        // Build rows
        <span class="cov0" title="0">var rows [][]string

        // Add header row - but first check if we have any instances
        allNamespaces := false
        if len(instances) &gt; 0 </span><span class="cov0" title="0">{
                for _, inst := range instances </span><span class="cov0" title="0">{
                        if inst.Namespace != instances[0].Namespace </span><span class="cov0" title="0">{
                                allNamespaces = true
                                break</span>
                        }
                }
        }

        // Add header row
        <span class="cov0" title="0">if allNamespaces </span><span class="cov0" title="0">{
                rows = append(rows, []string{"NAMESPACE", "NAME", "SERVICE", "NODE", "STATUS", "RESTARTS", "AGE"})
        }</span> else<span class="cov0" title="0"> {
                rows = append(rows, []string{"NAME", "SERVICE", "NODE", "STATUS", "RESTARTS", "AGE"})
        }</span>

        // Add instance rows
        <span class="cov0" title="0">for _, instance := range instances </span><span class="cov0" title="0">{
                // Format status using the same colorizeStatus function from table.go
                status := format.PTermStatusLabel(string(instance.Status))

                // Format restarts (currently a placeholder as we don't track this yet)
                restarts := "0" // Placeholder

                // Calculate age
                age := formatAge(instance.CreatedAt)

                // Create the row
                var row []string
                if allNamespaces </span><span class="cov0" title="0">{
                        row = []string{
                                instance.Namespace,
                                instance.Name,
                                instance.ServiceID,
                                instance.NodeID,
                                status,
                                restarts,
                                age,
                        }
                }</span> else<span class="cov0" title="0"> {
                        row = []string{
                                instance.Name,
                                instance.ServiceID,
                                instance.NodeID,
                                status,
                                restarts,
                                age,
                        }
                }</span>

                <span class="cov0" title="0">rows = append(rows, row)</span>
        }

        <span class="cov0" title="0">return rows</span>
}

// DefaultInstanceEventRenderer returns a default renderer for instance events
func DefaultInstanceEventRenderer(events []Event) []string <span class="cov0" title="0">{
        var lines []string
        for _, event := range events </span><span class="cov0" title="0">{
                var symbol, color string
                var eventPrefix string

                switch event.EventType </span>{
                case "ADDED":<span class="cov0" title="0">
                        symbol = "+"
                        color = format.Green
                        eventPrefix = "ADDED"</span>
                case "MODIFIED":<span class="cov0" title="0">
                        symbol = "~"
                        color = format.Yellow
                        eventPrefix = "MODIFIED"</span>
                case "DELETED":<span class="cov0" title="0">
                        symbol = "-"
                        color = format.Red
                        eventPrefix = "DELETED"</span>
                }

                <span class="cov0" title="0">instRes, ok := event.Resource.(InstanceResource)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">eventText := fmt.Sprintf("[%s] %s instance \"%s\"",
                        format.Colorize(color, symbol),
                        eventPrefix,
                        format.Colorize(format.Bold, instRes.Name))

                lines = append(lines, eventText)</span>
        }
        <span class="cov0" title="0">return lines</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package cmd

import (
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/fatih/color"
        "github.com/rzbill/rune/pkg/cli/format"
        "github.com/rzbill/rune/pkg/types"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        strict        bool
        quiet         bool
        recursive     bool
        fileTypes     []string
        exitOnFail    bool
        autoFix       bool
        outputFormat  string
        contextLines  int
        expandContext bool
)

// Color setup for formatting
var (
        errorColor   = color.New(color.FgRed, color.Bold)
        fileColor    = color.New(color.FgCyan, color.Bold)
        lineColor    = color.New(color.FgYellow, color.Bold)
        hintColor    = color.New(color.FgGreen)
        successColor = color.New(color.FgGreen, color.Bold)
)

// lintCmd represents the lint command
var lintCmd = &amp;cobra.Command{
        Use:   "lint [file or directory]...",
        Short: "Validate YAML specifications",
        Long: `Lint and validate Rune YAML specifications for correctness.

This command checks all resource types (services, jobs, secrets, functions, etc.)
and validates their structure, required fields, and relationships.

Examples:
  # Lint a single file
  rune lint myservice.yaml

  # Lint multiple files
  rune lint service.yaml job.yaml

  # Recursively lint all YAML files in a directory
  rune lint --recursive ./manifests/

  # Strict validation mode (more warnings)
  rune lint --strict myservice.yaml

  # Only show errors, no progress or success messages
  rune lint --quiet myservice.yaml

  # Exit with non-zero code on first validation error
  rune lint --exit-on-fail myservice.yaml
  
  # Automatically fix common issues when possible
  rune lint --fix myservice.yaml
  
  # Output in JSON format for CI/CD integration
  rune lint --format json ./manifests/`,
        SilenceUsage:  true,
        SilenceErrors: true,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                if len(args) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("at least one file or directory is required")
                }</span>

                // Expand context if requested
                <span class="cov0" title="0">if expandContext </span><span class="cov0" title="0">{
                        contextLines = 3
                }</span>

                // Gather all files to lint
                <span class="cov0" title="0">var filesToLint []string
                for _, arg := range args </span><span class="cov0" title="0">{
                        info, err := os.Stat(arg)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error accessing %s: %w", arg, err)
                        }</span>

                        <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                                if recursive </span><span class="cov0" title="0">{
                                        // Recursively find all YAML files in directory
                                        err := filepath.Walk(arg, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                <span class="cov0" title="0">if !info.IsDir() &amp;&amp; hasYAMLExtension(path) </span><span class="cov0" title="0">{
                                                        filesToLint = append(filesToLint, path)
                                                }</span>
                                                <span class="cov0" title="0">return nil</span>
                                        })
                                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("error walking directory %s: %w", arg, err)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // Get only YAML files in the top level of the directory
                                        files, err := ioutil.ReadDir(arg)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("error reading directory %s: %w", arg, err)
                                        }</span>
                                        <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                                                if !f.IsDir() &amp;&amp; hasYAMLExtension(f.Name()) </span><span class="cov0" title="0">{
                                                        filesToLint = append(filesToLint, filepath.Join(arg, f.Name()))
                                                }</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                // It's a file, check if it's YAML
                                if hasYAMLExtension(arg) </span><span class="cov0" title="0">{
                                        filesToLint = append(filesToLint, arg)
                                }</span> else<span class="cov0" title="0"> {
                                        if !quiet </span><span class="cov0" title="0">{
                                                fmt.Printf("Skipping non-YAML file: %s\n", arg)
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if len(filesToLint) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no YAML files found to lint")
                }</span>

                <span class="cov0" title="0">return runLint(filesToLint)</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(lintCmd)

        // Define flags
        lintCmd.Flags().BoolVar(&amp;strict, "strict", false, "Enable stricter validation rules")
        lintCmd.Flags().BoolVar(&amp;quiet, "quiet", false, "Only show errors, no progress or success messages")
        lintCmd.Flags().BoolVarP(&amp;recursive, "recursive", "r", false, "Recursively process directories")
        lintCmd.Flags().StringSliceVar(&amp;fileTypes, "types", []string{}, "Only validate specific resource types (comma separated: service, job, secret, etc.)")
        lintCmd.Flags().BoolVar(&amp;exitOnFail, "exit-on-fail", false, "Exit on first validation failure")
        lintCmd.Flags().BoolVar(&amp;autoFix, "fix", false, "Automatically fix simple issues when possible")
        lintCmd.Flags().StringVar(&amp;outputFormat, "format", "text", "Output format (text, json)")
        lintCmd.Flags().IntVar(&amp;contextLines, "context", 1, "Number of context lines to show around errors")
        lintCmd.Flags().BoolVar(&amp;expandContext, "expand-context", false, "Show more context around errors (equivalent to --context=3)")
}</span>

// hasYAMLExtension checks if a file has a YAML extension
func hasYAMLExtension(filename string) bool <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(filename))
        return ext == ".yaml" || ext == ".yml"
}</span>

// runLint performs the actual linting of files
func runLint(files []string) error <span class="cov0" title="0">{
        hasErrors := false
        totalErrorCount := 0
        totalFixCount := 0
        startTime := time.Now()
        allErrors := []format.ValidationError{}

        for _, filename := range files </span><span class="cov0" title="0">{
                // Only show per-file progress in verbose mode
                if verbose &amp;&amp; !quiet &amp;&amp; outputFormat == "text" </span><span class="cov0" title="0">{
                        fmt.Printf("Linting %s...\n", filename)
                }</span>

                // Read file
                <span class="cov0" title="0">data, err := ioutil.ReadFile(filename)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error reading %s: %v\n", filename, err)
                        hasErrors = true
                        totalErrorCount++
                        if exitOnFail </span><span class="cov0" title="0">{
                                return fmt.Errorf("validation failed")
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Create an error formatter for this file
                <span class="cov0" title="0">formatter := format.NewErrorFormatter(filename, data)
                formatter.ContextLines = contextLines
                formatter.CanAutoFix = autoFix
                formatter.OutputFormat = outputFormat

                // Determine resource type
                resourceType, err := determineResourceType(data)
                if err != nil </span><span class="cov0" title="0">{
                        formatter.PrintErrorHeader()

                        // Extract line number if possible
                        lineNum := formatter.ExtractLineNumber(err.Error())
                        formatter.PrintError(err.Error(), lineNum)

                        // Try auto-fix if enabled
                        if autoFix </span><span class="cov0" title="0">{
                                if fixed, newData := formatter.TryAutoFix(err.Error(), lineNum); fixed </span><span class="cov0" title="0">{
                                        if !quiet &amp;&amp; outputFormat == "text" </span><span class="cov0" title="0">{
                                                format.SuccessColor.Printf("   Auto-fixed issues in %s\n", filename)
                                        }</span>
                                        // Write the fixed data back to the file
                                        <span class="cov0" title="0">if err := ioutil.WriteFile(filename, newData, 0644); err != nil </span><span class="cov0" title="0">{
                                                fmt.Printf("Error writing fixed file %s: %v\n", filename, err)
                                        }</span> else<span class="cov0" title="0"> {
                                                formatter.FixCount++
                                                totalFixCount++

                                                // Re-read the fixed file and try again
                                                data = newData
                                                resourceType, err = determineResourceType(data)
                                                // If still error, continue with normal flow
                                                if err != nil </span><span class="cov0" title="0">{
                                                        hasErrors = true
                                                        totalErrorCount++
                                                        if exitOnFail </span><span class="cov0" title="0">{
                                                                return fmt.Errorf("validation failed")
                                                        }</span>
                                                        <span class="cov0" title="0">continue</span>
                                                }
                                        }
                                } else<span class="cov0" title="0"> {
                                        // No fix was applied, count the error
                                        hasErrors = true
                                        totalErrorCount++
                                }</span>
                        } else<span class="cov0" title="0"> {
                                hasErrors = true
                                totalErrorCount++
                                if exitOnFail </span><span class="cov0" title="0">{
                                        return fmt.Errorf("validation failed")
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                }

                // Skip if we're only linting specific types and this isn't one of them
                <span class="cov0" title="0">if len(fileTypes) &gt; 0 &amp;&amp; !contains(fileTypes, resourceType) </span><span class="cov0" title="0">{
                        if !quiet &amp;&amp; outputFormat == "text" </span><span class="cov0" title="0">{
                                fmt.Printf("Skipping %s (resource type: %s)\n", filename, resourceType)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Validate based on resource type
                <span class="cov0" title="0">if err := validateResource(formatter, resourceType, data); err != nil </span><span class="cov0" title="0">{
                        hasErrors = true

                        if autoFix &amp;&amp; len(formatter.Errors) &gt; 0 </span><span class="cov0" title="0">{
                                var anyFixed bool

                                // Try to auto-fix each error
                                for _, valError := range formatter.Errors </span><span class="cov0" title="0">{
                                        if valError.AutoFixable </span><span class="cov0" title="0">{
                                                if fixed, newData := formatter.TryAutoFix(valError.Message, valError.LineNumber); fixed </span><span class="cov0" title="0">{
                                                        if !quiet &amp;&amp; outputFormat == "text" </span><span class="cov0" title="0">{
                                                                format.SuccessColor.Printf("   Auto-fixed issue at line %d in %s\n",
                                                                        valError.LineNumber, filename)
                                                        }</span>
                                                        // Write the fixed data back to the file
                                                        <span class="cov0" title="0">if err := ioutil.WriteFile(filename, newData, 0644); err != nil </span><span class="cov0" title="0">{
                                                                fmt.Printf("Error writing fixed file %s: %v\n", filename, err)
                                                        }</span> else<span class="cov0" title="0"> {
                                                                anyFixed = true
                                                                formatter.FixCount++
                                                                totalFixCount++
                                                                // Update the data for next fixes
                                                                data = newData
                                                                formatter.FileData = newData
                                                        }</span>
                                                }
                                        }
                                }

                                // If any fixes were applied, try validating again
                                <span class="cov0" title="0">if anyFixed </span><span class="cov0" title="0">{
                                        // Create a new formatter with the updated data
                                        newFormatter := format.NewErrorFormatter(filename, data)
                                        newFormatter.ContextLines = contextLines
                                        newFormatter.OutputFormat = outputFormat

                                        // Revalidate
                                        if err := validateResource(newFormatter, resourceType, data); err == nil </span><span class="cov0" title="0">{
                                                // Fixed all issues!
                                                if !quiet &amp;&amp; outputFormat == "text" </span><span class="cov0" title="0">{
                                                        format.SuccessColor.Printf("   All issues fixed in %s\n", filename)
                                                }</span>
                                                // Reset the error flag for this file
                                                <span class="cov0" title="0">hasErrors = false
                                                continue</span>
                                        } else<span class="cov0" title="0"> {
                                                // Still has errors after fixing
                                                totalErrorCount += newFormatter.ErrorCount
                                                allErrors = append(allErrors, newFormatter.Errors...)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // No fixes were applied
                                        totalErrorCount += formatter.ErrorCount
                                        allErrors = append(allErrors, formatter.Errors...)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Not auto-fixing
                                totalErrorCount += formatter.ErrorCount
                                allErrors = append(allErrors, formatter.Errors...)
                        }</span>

                        // Show error summary for this file
                        <span class="cov0" title="0">if outputFormat == "text" </span><span class="cov0" title="0">{
                                formatter.PrintErrorSummary()
                        }</span>

                        <span class="cov0" title="0">if exitOnFail </span><span class="cov0" title="0">{
                                return fmt.Errorf("validation failed")
                        }</span>
                }
        }

        // Output in JSON format if requested
        <span class="cov0" title="0">if outputFormat == "json" </span><span class="cov0" title="0">{
                // Create a combined formatter just for JSON output
                jsonFormatter := format.NewErrorFormatter("", nil)
                jsonFormatter.Errors = allErrors
                jsonFormatter.ErrorCount = totalErrorCount
                jsonFormatter.FixCount = totalFixCount
                fmt.Println(jsonFormatter.FormatAsJSON())
        }</span>

        // Print overall stats
        <span class="cov0" title="0">if outputFormat == "text" </span><span class="cov0" title="0">{
                duration := time.Since(startTime)
                format.PrintLintSummary(len(files), totalErrorCount, totalFixCount, duration)
        }</span>

        <span class="cov0" title="0">if hasErrors || totalErrorCount &gt; 0 </span><span class="cov0" title="0">{
                // Return an error to indicate failure but don't add a message
                // since the summary already showed the error count
                return fmt.Errorf("") // Empty error message
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// determineResourceType identifies the resource type from YAML data
func determineResourceType(data []byte) (string, error) <span class="cov8" title="1">{
        var m map[string]interface{}
        if err := yaml.Unmarshal(data, &amp;m); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid YAML: %w", err)
        }</span>

        // Look for known top-level keys
        <span class="cov8" title="1">if _, ok := m["service"]; ok </span><span class="cov8" title="1">{
                return "service", nil
        }</span>
        <span class="cov8" title="1">if _, ok := m["services"]; ok </span><span class="cov8" title="1">{
                return "service", nil
        }</span>
        <span class="cov8" title="1">if _, ok := m["job"]; ok </span><span class="cov8" title="1">{
                return "job", nil
        }</span>
        <span class="cov8" title="1">if _, ok := m["jobs"]; ok </span><span class="cov8" title="1">{
                return "job", nil
        }</span>
        <span class="cov8" title="1">if _, ok := m["secret"]; ok </span><span class="cov8" title="1">{
                return "secret", nil
        }</span>
        <span class="cov8" title="1">if _, ok := m["function"]; ok </span><span class="cov8" title="1">{
                return "function", nil
        }</span>
        <span class="cov8" title="1">if _, ok := m["config"]; ok </span><span class="cov8" title="1">{
                return "config", nil
        }</span>
        <span class="cov8" title="1">if _, ok := m["networkPolicy"]; ok </span><span class="cov8" title="1">{
                return "networkPolicy", nil
        }</span>

        // Check if it's a Rune global configuration file
        <span class="cov8" title="1">if _, ok := m["server"]; ok </span><span class="cov0" title="0">{
                if _, ok := m["client"]; ok </span><span class="cov0" title="0">{
                        return "rune-config", nil
                }</span>
        }

        // Check if it appears to be a partial config file
        <span class="cov8" title="1">configKeys := []string{"namespace", "auth", "resources", "logging", "plugins"}
        configKeyCount := 0

        for _, key := range configKeys </span><span class="cov8" title="1">{
                if _, ok := m[key]; ok </span><span class="cov0" title="0">{
                        configKeyCount++
                }</span>
        }

        // If it has at least two config-related keys, assume it's a configuration file
        <span class="cov8" title="1">if configKeyCount &gt;= 2 </span><span class="cov0" title="0">{
                return "rune-config", nil
        }</span>

        <span class="cov8" title="1">return "", fmt.Errorf("unrecognized resource type")</span>
}

// validateResource validates a specific resource type
func validateResource(formatter *format.ErrorFormatter, resourceType string, data []byte) error <span class="cov0" title="0">{
        var err error

        switch resourceType </span>{
        case "service":<span class="cov0" title="0">
                err = validateService(formatter, data)</span>
        case "job":<span class="cov0" title="0">
                err = validateJob(formatter, resourceType, data)</span>
        case "secret":<span class="cov0" title="0">
                err = validateSecret(formatter, resourceType, data)</span>
        case "function":<span class="cov0" title="0">
                err = validateFunction(formatter, resourceType, data)</span>
        case "config":<span class="cov0" title="0">
                err = validateConfig(formatter, resourceType, data)</span>
        case "rune-config":<span class="cov0" title="0">
                err = validateRuneConfig(formatter, data)</span>
        case "networkPolicy":<span class="cov0" title="0">
                err = validateNetworkPolicy(formatter, resourceType, data)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("validation not implemented for resource type: %s", resourceType)</span>
        }

        <span class="cov0" title="0">return err</span>
}

// validateService validates a service resource
func validateService(formatter *format.ErrorFormatter, data []byte) error <span class="cov0" title="0">{
        serviceFile, err := types.ParseServiceData(data)
        if err != nil </span><span class="cov0" title="0">{
                var yamlErr *yaml.TypeError
                if errors.As(err, &amp;yamlErr) </span><span class="cov0" title="0">{
                        formatter.PrintErrorHeader()

                        for _, e := range yamlErr.Errors </span><span class="cov0" title="0">{
                                errMsg := e
                                lineNum := formatter.ExtractLineNumber(errMsg)
                                formatter.PrintError(errMsg, lineNum)
                        }</span>
                } else<span class="cov0" title="0"> {
                        formatter.PrintErrorHeader()

                        // Try to extract line number from regular errors
                        errStr := err.Error()
                        lineNum := formatter.ExtractLineNumber(errStr)
                        formatter.PrintError(errStr, lineNum)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("validation failed in %s", formatter.FileName)</span>
        }

        <span class="cov0" title="0">hasErrors := false
        for _, service := range serviceFile.GetServices() </span><span class="cov0" title="0">{
                if err := service.Validate(); err != nil </span><span class="cov0" title="0">{
                        if !hasErrors </span><span class="cov0" title="0">{
                                formatter.PrintErrorHeader()
                        }</span>

                        <span class="cov0" title="0">hasErrors = true

                        // Get line info if available
                        var lineNum int
                        if lineInfo, ok := serviceFile.GetLineInfo(service.Name); ok </span><span class="cov0" title="0">{
                                lineNum = lineInfo
                        }</span>

                        <span class="cov0" title="0">formatter.PrintServiceError(service.Name, err.Error(), lineNum)
                        formatter.ErrorCount++</span> // Increment the error count
                }
        }

        <span class="cov0" title="0">if hasErrors </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed for services in %s", formatter.FileName)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateJob validates a job resource
func validateJob(formatter *format.ErrorFormatter, resourceType string, data []byte) error <span class="cov0" title="0">{
        // This would use the actual job parsing and validation logic
        // For now, we'll return a placeholder message
        if !quiet &amp;&amp; formatter.OutputFormat == "text" </span><span class="cov0" title="0">{
                fmt.Printf("Job validation not yet implemented for %s\n", formatter.FileName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateSecret validates a secret resource
func validateSecret(formatter *format.ErrorFormatter, resourceType string, data []byte) error <span class="cov0" title="0">{
        // This would use the actual secret parsing and validation logic
        // For now, we'll return a placeholder message
        if !quiet &amp;&amp; formatter.OutputFormat == "text" </span><span class="cov0" title="0">{
                fmt.Printf("Secret validation not yet implemented for %s\n", formatter.FileName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateFunction validates a function resource
func validateFunction(formatter *format.ErrorFormatter, resourceType string, data []byte) error <span class="cov0" title="0">{
        // This would use the actual function parsing and validation logic
        // For now, we'll return a placeholder message
        if !quiet &amp;&amp; formatter.OutputFormat == "text" </span><span class="cov0" title="0">{
                fmt.Printf("Function validation not yet implemented for %s\n", formatter.FileName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateConfig validates a config resource
func validateConfig(formatter *format.ErrorFormatter, resourceType string, data []byte) error <span class="cov0" title="0">{
        // This would use the actual config parsing and validation logic
        // For now, we'll return a placeholder message
        if !quiet &amp;&amp; formatter.OutputFormat == "text" </span><span class="cov0" title="0">{
                fmt.Printf("Config validation not yet implemented for %s\n", formatter.FileName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateNetworkPolicy validates a network policy resource
func validateNetworkPolicy(formatter *format.ErrorFormatter, resourceType string, data []byte) error <span class="cov0" title="0">{
        // This would use the actual network policy parsing and validation logic
        // For now, we'll return a placeholder message
        if !quiet &amp;&amp; formatter.OutputFormat == "text" </span><span class="cov0" title="0">{
                fmt.Printf("Network policy validation not yet implemented for %s\n", formatter.FileName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateRuneConfig validates a Rune configuration file
func validateRuneConfig(formatter *format.ErrorFormatter, data []byte) error <span class="cov0" title="0">{
        // For now, we just validate that it's valid YAML
        // In the future, we can add more specific validation
        var config map[string]interface{}
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                formatter.PrintErrorHeader()
                errStr := err.Error()
                lineNum := formatter.ExtractLineNumber(errStr)
                formatter.PrintError(errStr, lineNum)
                return fmt.Errorf("invalid Rune configuration: %w", err)
        }</span>

        <span class="cov0" title="0">if !quiet &amp;&amp; formatter.OutputFormat == "text" </span><span class="cov0" title="0">{
                format.SuccessColor.Printf(" Valid Rune configuration file: %s\n", formatter.FileName)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// contains checks if a string is present in a slice
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/rzbill/rune/pkg/version"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        cfgFile string
        verbose bool
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "rune",
        Short: "Rune - Lightweight Orchestration Platform",
        Long: `Rune is a lightweight, single-binary orchestration platform 
inspired by Kubernetes and Nomad. It is designed for developers 
who want to deploy and scale services quickly and intuitively, 
without unnecessary complexity.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // If no subcommand is specified, display the help
                if len(args) == 0 </span><span class="cov0" title="0">{
                        cmd.Help()
                        return
                }</span>
        },
        Version: version.Version,
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)

        // Here you will define your flags and configuration settings.
        rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.rune/config.yaml)")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "enable verbose output")

        // Add global environment variables
        viper.SetEnvPrefix("RUNE")
        viper.AutomaticEnv() // read in environment variables that match
}</span>

// initConfig reads in config file and ENV variables if set.
func initConfig() <span class="cov0" title="0">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                // Use config file from the flag.
                viper.SetConfigFile(cfgFile)
        }</span> else<span class="cov0" title="0"> {
                // Find home directory.
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>

                // Search config in home directory with name ".rune" (without extension).
                <span class="cov0" title="0">viper.AddConfigPath(home + "/.rune")
                viper.SetConfigName("config")
                viper.SetConfigType("yaml")</span>
        }

        // If a config file is found, read it in.
        <span class="cov0" title="0">if err := viper.ReadInConfig(); err == nil </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        fmt.Println("Using config file:", viper.ConfigFileUsed())
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package cmd

import (
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/pterm/pterm"
        "github.com/rzbill/rune/pkg/cli/format"
        "github.com/rzbill/rune/pkg/types"
)

// ResourceTable provides a generic interface for rendering tables of different resources
type ResourceTable struct {
        // Configuration
        Headers       []string
        ShowHeaders   bool
        AllNamespaces bool
        ShowLabels    bool
        MaxWidth      int

        // Rendering details
        tableRenderer *pterm.TablePrinter
        stripAnsiFunc func(string) string
}

// NewResourceTable creates a new resource table with default configuration
func NewResourceTable() *ResourceTable <span class="cov0" title="0">{
        // Create the table with custom header style
        table := pterm.DefaultTable.WithHasHeader(true)

        // Customize the header style to use BoldBlue
        headerStyle := pterm.NewStyle(pterm.FgCyan, pterm.Bold)
        table = table.WithHeaderStyle(headerStyle)

        return &amp;ResourceTable{
                ShowHeaders:   true,
                stripAnsiFunc: stripAnsiTable,
                tableRenderer: table,
                MaxWidth:      100,
        }
}</span>

// SetHeaders sets the headers for the table
func (t *ResourceTable) SetHeaders(headers []string) <span class="cov0" title="0">{
        t.Headers = headers
}</span>

// SetStripAnsiFunc sets a custom function for stripping ANSI codes
func (t *ResourceTable) SetStripAnsiFunc(fn func(string) string) <span class="cov0" title="0">{
        t.stripAnsiFunc = fn
}</span>

// RenderServices renders a table of services
func (t *ResourceTable) RenderServices(services []*types.Service) error <span class="cov0" title="0">{
        if len(services) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No services found")
                return nil
        }</span>

        // Set default headers if not provided
        <span class="cov0" title="0">if len(t.Headers) == 0 </span><span class="cov0" title="0">{
                if t.AllNamespaces </span><span class="cov0" title="0">{
                        t.Headers = []string{"NAMESPACE", "NAME", "TYPE", "STATUS", "INSTANCES", "IMAGE/COMMAND", "AGE"}
                }</span> else<span class="cov0" title="0"> {
                        t.Headers = []string{"NAME", "TYPE", "STATUS", "INSTANCES", "IMAGE/COMMAND", "AGE"}
                }</span>
        }

        // Create rows
        <span class="cov0" title="0">rows := [][]string{t.Headers} // Start with headers

        // Generate data rows
        for _, service := range services </span><span class="cov0" title="0">{
                // Determine service type
                serviceType := "container"
                if service.Runtime == "process" &amp;&amp; service.Process != nil </span><span class="cov0" title="0">{
                        serviceType = "process"
                }</span>

                // Format status - use our colorizeStatus function
                <span class="cov0" title="0">status := format.PTermStatusLabel(string(service.Status))

                // Format instances
                running := 0
                if service.Status == types.ServiceStatusRunning </span><span class="cov0" title="0">{
                        running = service.Scale
                }</span>
                <span class="cov0" title="0">instances := fmt.Sprintf("%d/%d", running, service.Scale)

                // Determine image or command
                imageOrCommand := service.Image
                if service.Runtime == "process" &amp;&amp; service.Process != nil </span><span class="cov0" title="0">{
                        imageOrCommand = service.Process.Command
                        if len(service.Process.Args) &gt; 0 </span><span class="cov0" title="0">{
                                imageOrCommand += " " + strings.Join(service.Process.Args, " ")
                        }</span>
                }

                // Truncate very long image/command strings
                <span class="cov0" title="0">if len(imageOrCommand) &gt; 60 </span><span class="cov0" title="0">{
                        imageOrCommand = imageOrCommand[:57] + "..."
                }</span>

                // Calculate age
                <span class="cov0" title="0">age := formatAgeTable(service.CreatedAt)

                // Create the row
                var row []string
                if t.AllNamespaces </span><span class="cov0" title="0">{
                        row = []string{
                                service.Namespace,
                                service.Name,
                                serviceType,
                                status,
                                instances,
                                imageOrCommand,
                                age,
                        }
                }</span> else<span class="cov0" title="0"> {
                        row = []string{
                                service.Name,
                                serviceType,
                                status,
                                instances,
                                imageOrCommand,
                                age,
                        }
                }</span>

                // Add labels if requested
                <span class="cov0" title="0">if t.ShowLabels &amp;&amp; len(service.Labels) &gt; 0 </span><span class="cov0" title="0">{
                        labelStrs := make([]string, 0, len(service.Labels))
                        for k, v := range service.Labels </span><span class="cov0" title="0">{
                                labelStrs = append(labelStrs, fmt.Sprintf("%s=%s", k, v))
                        }</span>
                        <span class="cov0" title="0">row = append(row, strings.Join(labelStrs, ","))</span>
                }

                <span class="cov0" title="0">rows = append(rows, row)</span>
        }

        // Render the table with pterm
        <span class="cov0" title="0">return t.tableRenderer.WithData(rows).Render()</span>
}

// RenderInstances renders a table of instances
func (t *ResourceTable) RenderInstances(instances []*types.Instance) error <span class="cov0" title="0">{
        if len(instances) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No instances found")
                return nil
        }</span>

        // Set default headers if not provided
        <span class="cov0" title="0">if len(t.Headers) == 0 </span><span class="cov0" title="0">{
                if t.AllNamespaces </span><span class="cov0" title="0">{
                        t.Headers = []string{"NAMESPACE", "NAME", "SERVICE", "NODE", "STATUS", "RESTARTS", "AGE"}
                }</span> else<span class="cov0" title="0"> {
                        t.Headers = []string{"NAME", "SERVICE", "NODE", "STATUS", "RESTARTS", "AGE"}
                }</span>
        }

        // Create rows
        <span class="cov0" title="0">rows := [][]string{t.Headers} // Start with headers

        // Generate data rows
        for _, instance := range instances </span><span class="cov0" title="0">{
                // Format status using PTermStatusLabel
                status := format.PTermStatusLabel(string(instance.Status))

                // Format restarts (currently a placeholder as we don't track this yet)
                restarts := "0" // Placeholder

                // Calculate age
                age := formatAgeTable(instance.CreatedAt)

                // Create the row
                var row []string
                if t.AllNamespaces </span><span class="cov0" title="0">{
                        row = []string{
                                instance.Namespace,
                                instance.Name,
                                fmt.Sprintf("%s(%s)", instance.ServiceName, instance.ServiceID),
                                instance.NodeID,
                                status,
                                restarts,
                                age,
                        }
                }</span> else<span class="cov0" title="0"> {
                        row = []string{
                                instance.Name,
                                fmt.Sprintf("%s(%s)", instance.ServiceName, instance.ServiceID),
                                instance.NodeID,
                                status,
                                restarts,
                                age,
                        }
                }</span>

                <span class="cov0" title="0">rows = append(rows, row)</span>
        }

        // Render the table with pterm
        <span class="cov0" title="0">return t.tableRenderer.WithData(rows).Render()</span>
}

// RenderNamespaces renders a table of namespaces
// Note: This is a placeholder implementation that will need to be updated
// once the Namespace type is fully defined
func (t *ResourceTable) RenderNamespaces(namespaces []*types.Namespace) error <span class="cov0" title="0">{
        if len(namespaces) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No namespaces found")
                return nil
        }</span>

        // Set default headers if not provided
        <span class="cov0" title="0">if len(t.Headers) == 0 </span><span class="cov0" title="0">{
                t.Headers = []string{"NAME", "STATUS", "AGE"}
        }</span>

        // Placeholder message
        <span class="cov0" title="0">fmt.Println("Namespace rendering not yet implemented")
        return nil</span>
}

// Helper functions with unique names to avoid conflicts

// formatAgeTable formats a time.Time as a human-readable age string
func formatAgeTable(t time.Time) string <span class="cov0" title="0">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return "Unknown"
        }</span>

        <span class="cov0" title="0">duration := time.Since(t)
        if duration &lt; time.Minute </span><span class="cov0" title="0">{
                return "Just now"
        }</span> else<span class="cov0" title="0"> if duration &lt; time.Hour </span><span class="cov0" title="0">{
                minutes := int(duration.Minutes())
                return fmt.Sprintf("%dm", minutes)
        }</span> else<span class="cov0" title="0"> if duration &lt; 24*time.Hour </span><span class="cov0" title="0">{
                hours := int(duration.Hours())
                return fmt.Sprintf("%dh", hours)
        }</span> else<span class="cov0" title="0"> if duration &lt; 30*24*time.Hour </span><span class="cov0" title="0">{
                days := int(duration.Hours() / 24)
                return fmt.Sprintf("%dd", days)
        }</span> else<span class="cov0" title="0"> if duration &lt; 365*24*time.Hour </span><span class="cov0" title="0">{
                months := int(duration.Hours() / 24 / 30)
                return fmt.Sprintf("%dmo", months)
        }</span>
        <span class="cov0" title="0">years := int(duration.Hours() / 24 / 365)
        return fmt.Sprintf("%dy", years)</span>
}

// stripAnsiTable removes ANSI color codes from a string for accurate length calculation
func stripAnsiTable(s string) string <span class="cov0" title="0">{
        // Simple regex to strip ANSI color codes
        ansiRegex := regexp.MustCompile("\x1b\\[[0-9;]*m")
        return ansiRegex.ReplaceAllString(s, "")
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

var (
        follow        bool
        tail          int
        showHealth    bool
        showResources bool
)

// traceCmd represents the trace command
var traceCmd = &amp;cobra.Command{
        Use:   "trace [service name]",
        Short: "Show logs and diagnostics for a service",
        Long: `Show logs, health status, and diagnostics for a service.
For example:
  rune trace my-service
  rune trace my-service --follow
  rune trace my-service --health
  rune trace my-service --resources`,
        Args: cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                serviceName := args[0]
                fmt.Printf("Showing information for service: %s\n", serviceName)
                fmt.Printf("Namespace: %s\n", namespace)

                if showHealth </span><span class="cov0" title="0">{
                        fmt.Println("Health information:")
                        fmt.Println("  Status: Healthy")
                        fmt.Println("  Instances: 3/3 ready")
                }</span>

                <span class="cov0" title="0">if showResources </span><span class="cov0" title="0">{
                        fmt.Println("Resource usage:")
                        fmt.Println("  CPU: 250m/500m")
                        fmt.Println("  Memory: 128Mi/256Mi")
                }</span>

                // Show logs (this would pull real logs in the actual implementation)
                <span class="cov0" title="0">fmt.Println("Logs:")
                fmt.Println("  2023-06-01 12:00:01 INFO  Service started")
                fmt.Println("  2023-06-01 12:00:02 INFO  Listening on port 8080")

                if follow </span><span class="cov0" title="0">{
                        fmt.Println("Following logs (would continue in real implementation)...")
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(traceCmd)

        // Local flags for the trace command
        traceCmd.Flags().BoolVarP(&amp;follow, "follow", "f", false, "Follow logs in real-time")
        traceCmd.Flags().IntVar(&amp;tail, "tail", 10, "Number of lines to show from the end of logs")
        traceCmd.Flags().BoolVar(&amp;showHealth, "health", false, "Show health status")
        traceCmd.Flags().BoolVar(&amp;showResources, "resources", false, "Show resource usage")
        traceCmd.Flags().StringVarP(&amp;namespace, "namespace", "n", "default", "Namespace of the service")
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package cmd

import (
        "fmt"

        "github.com/rzbill/rune/pkg/version"
        "github.com/spf13/cobra"
)

// versionCmd represents the version command
var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Show the Rune version information",
        Long:  `Display detailed version information about the Rune binary.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println(version.Info())
        }</span>,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(versionCmd)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package cmd

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "os/signal"
        "sort"
        "strconv"
        "strings"
        "syscall"
        "time"

        "github.com/pterm/pterm"
        "github.com/rzbill/rune/pkg/cli/format"
        "github.com/rzbill/rune/pkg/types"
)

// ResourceWatcher is a generic interface for resource watching
type ResourceWatcher struct {
        // Configuration
        Namespace         string
        AllNamespaces     bool
        LabelSelector     string
        FieldSelector     string
        ResourceName      string
        ShowHeaders       bool
        RefreshInterval   time.Duration
        InitialBufferTime time.Duration
        WatchTimeout      time.Duration

        // Internal state
        resources              map[string]Resource
        events                 []Event
        lastUpdateTime         time.Time
        initialSyncComplete    bool
        reconnectDelay         time.Duration
        maxReconnectDelay      time.Duration
        tableRenderer          *pterm.TablePrinter
        termWidth, termHeight  int
        maxEvents              int
        headerRenderer         func() string
        resourceToRowsRenderer func(resources []Resource) [][]string
        eventRenderer          func(events []Event) []string
}

// Resource is a generic interface that all watchable resources must implement
type Resource interface {
        // GetKey returns a unique identifier for the resource
        GetKey() string
        // Equals checks if two resources are functionally equivalent
        Equals(other Resource) bool
}

// Event represents a resource change event for display
type Event struct {
        EventType string    // "ADDED", "MODIFIED", "DELETED"
        Resource  Resource  // The resource that changed
        Timestamp time.Time // When the event occurred
}

// ResourceToWatch is a generic interface for resource watchers
type ResourceToWatch interface {
        // Watch starts watching the resource and returns a channel of events
        Watch(ctx context.Context, namespace, labelSelector, fieldSelector string) (&lt;-chan WatchEvent, error)
}

// WatchEvent represents a resource change event from the API
type WatchEvent struct {
        Resource  Resource
        EventType string // "ADDED", "MODIFIED", "DELETED"
        Error     error
}

// NewResourceWatcher creates a new watcher with default configuration
func NewResourceWatcher() *ResourceWatcher <span class="cov8" title="1">{
        w := &amp;ResourceWatcher{
                Namespace:         "default",
                AllNamespaces:     false,
                RefreshInterval:   2 * time.Second,
                InitialBufferTime: 500 * time.Millisecond,
                resources:         make(map[string]Resource),
                events:            make([]Event, 0, 10),
                maxEvents:         10,
                reconnectDelay:    1 * time.Second,
                maxReconnectDelay: 30 * time.Second,
                lastUpdateTime:    time.Now(),
        }

        // Initialize terminal size
        w.updateTerminalSize()

        return w
}</span>

// SetHeaderRenderer sets a custom function to render the header
func (w *ResourceWatcher) SetHeaderRenderer(renderer func() string) <span class="cov0" title="0">{
        w.headerRenderer = renderer
}</span>

// SetResourceToRowsRenderer sets a custom function to convert resources to table rows
func (w *ResourceWatcher) SetResourceToRowsRenderer(renderer func(resources []Resource) [][]string) <span class="cov8" title="1">{
        w.resourceToRowsRenderer = renderer
}</span>

// SetEventRenderer sets a custom function to render events
func (w *ResourceWatcher) SetEventRenderer(renderer func(events []Event) []string) <span class="cov8" title="1">{
        w.eventRenderer = renderer
}</span>

// SetTimeout sets the watch timeout duration
func (w *ResourceWatcher) SetTimeout(timeout string) error <span class="cov0" title="0">{
        if timeout == "" </span><span class="cov0" title="0">{
                w.WatchTimeout = 0
                return nil
        }</span>

        <span class="cov0" title="0">duration, err := time.ParseDuration(timeout)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid timeout value: %w", err)
        }</span>
        <span class="cov0" title="0">w.WatchTimeout = duration
        return nil</span>
}

// Watch starts watching resources using the provided watcher
func (w *ResourceWatcher) Watch(ctx context.Context, watcher ResourceToWatch) error <span class="cov8" title="1">{
        // Update the namespace if using all namespaces
        namespace := w.Namespace
        if w.AllNamespaces </span><span class="cov0" title="0">{
                namespace = "*" // Use wildcard to watch all namespaces
        }</span>

        // Set up a channel to handle OS signals for graceful termination
        <span class="cov8" title="1">sig := make(chan os.Signal, 1)
        signal.Notify(sig, os.Interrupt, syscall.SIGTERM)

        // Create context with timeout if specified
        var cancel context.CancelFunc
        if w.WatchTimeout &gt; 0 </span><span class="cov0" title="0">{
                ctx, cancel = context.WithTimeout(ctx, w.WatchTimeout)
        }</span> else<span class="cov8" title="1"> {
                // No timeout specified, create a cancellable context
                ctx, cancel = context.WithCancel(ctx)
        }</span>
        <span class="cov8" title="1">defer cancel()

        // Create a filter for a specific resource if provided
        var fieldSelectorStr string
        if w.ResourceName != "" </span><span class="cov8" title="1">{
                if w.FieldSelector != "" </span><span class="cov0" title="0">{
                        fieldSelectorStr = w.FieldSelector + ",name=" + w.ResourceName
                }</span> else<span class="cov8" title="1"> {
                        fieldSelectorStr = "name=" + w.ResourceName
                }</span>
        } else<span class="cov8" title="1"> {
                fieldSelectorStr = w.FieldSelector
        }</span>

        // Initialize timers and state
        <span class="cov8" title="1">refreshTicker := time.NewTicker(w.RefreshInterval)
        defer refreshTicker.Stop()

        initialSyncTimer := time.NewTimer(2 * time.Second)
        initialBufferingTimeout := time.NewTimer(w.InitialBufferTime)
        displayTrigger := time.NewTimer(100 * time.Millisecond)

        initialCaching := true
        firstRun := true

        // Start watching for resource changes
        watchCh, err := watcher.Watch(ctx, namespace, w.LabelSelector, fieldSelectorStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to watch resources: %w", err)
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-initialBufferingTimeout.C:<span class="cov8" title="1">
                        // Mark initial buffering as complete after timeout
                        if initialCaching </span><span class="cov8" title="1">{
                                initialCaching = false
                                // Trigger an immediate refresh to show all resources we've received so far
                                w.refreshScreen()
                                firstRun = false
                        }</span>

                case &lt;-displayTrigger.C:<span class="cov8" title="1">
                        // If we have resources and haven't displayed yet, show them now
                        if len(w.resources) &gt; 0 &amp;&amp; initialCaching </span><span class="cov8" title="1">{
                                // Reset the initial buffering timeout to give a bit more time
                                // for other resources to arrive
                                initialBufferingTimeout.Reset(150 * time.Millisecond)
                        }</span>

                case &lt;-initialSyncTimer.C:<span class="cov0" title="0">
                        // Mark initial sync as complete after the timer expires
                        w.initialSyncComplete = true</span>

                case event, ok := &lt;-watchCh:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                // Channel closed, try to reconnect
                                fmt.Println("\nWatch connection lost. Reconnecting...")
                                time.Sleep(w.reconnectDelay)

                                // Exponential backoff for reconnect attempts
                                w.reconnectDelay = min(w.reconnectDelay*2, w.maxReconnectDelay)

                                // Attempt to reestablish watch
                                watchCh, err = watcher.Watch(ctx, namespace, w.LabelSelector, fieldSelectorStr)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("\nFailed to reconnect: %v. Retrying in %v...\n", err, w.reconnectDelay)
                                        continue</span>
                                }

                                // Reset delay on successful reconnection
                                <span class="cov0" title="0">w.reconnectDelay = 1 * time.Second
                                w.lastUpdateTime = time.Now()
                                continue</span>
                        }

                        <span class="cov8" title="1">if event.Error != nil </span><span class="cov0" title="0">{
                                // Check if it's a timeout error
                                if strings.Contains(event.Error.Error(), "DeadlineExceeded") ||
                                        strings.Contains(event.Error.Error(), "context deadline exceeded") ||
                                        strings.Contains(event.Error.Error(), "transport is closing") </span><span class="cov0" title="0">{
                                        // Handle timeout by reconnecting
                                        fmt.Println("\nWatch connection timed out. Reconnecting...")
                                        time.Sleep(w.reconnectDelay)

                                        // Exponential backoff for reconnect attempts
                                        w.reconnectDelay = min(w.reconnectDelay*2, w.maxReconnectDelay)

                                        // Attempt to reestablish watch
                                        watchCh, err = watcher.Watch(ctx, namespace, w.LabelSelector, fieldSelectorStr)
                                        if err != nil </span><span class="cov0" title="0">{
                                                fmt.Printf("\nFailed to reconnect: %v. Retrying in %v...\n", err, w.reconnectDelay)
                                                continue</span>
                                        }

                                        // Reset delay on successful reconnection
                                        <span class="cov0" title="0">w.reconnectDelay = 1 * time.Second
                                        w.lastUpdateTime = time.Now()
                                        continue</span>
                                }

                                // For other errors, return the error
                                <span class="cov0" title="0">return fmt.Errorf("watch error: %w", event.Error)</span>
                        }

                        <span class="cov8" title="1">resource := event.Resource
                        resourceKey := resource.GetKey()
                        w.lastUpdateTime = time.Now()

                        // Update our local state based on event type
                        switch event.EventType </span>{
                        case "ADDED", "MODIFIED":<span class="cov8" title="1">
                                oldResource, exists := w.resources[resourceKey]
                                w.resources[resourceKey] = resource

                                // Only add event for real changes or new additions after initial sync
                                if !exists </span><span class="cov8" title="1">{
                                        if w.initialSyncComplete </span><span class="cov0" title="0">{
                                                // This is a genuinely new resource after initial sync
                                                w.events = append(w.events, Event{
                                                        EventType: "ADDED",
                                                        Resource:  resource,
                                                        Timestamp: time.Now(),
                                                })
                                        }</span>
                                } else<span class="cov8" title="1"> if event.EventType == "MODIFIED" &amp;&amp; !oldResource.Equals(resource) </span><span class="cov8" title="1">{
                                        // Always show modifications
                                        w.events = append(w.events, Event{
                                                EventType: "MODIFIED",
                                                Resource:  resource,
                                                Timestamp: time.Now(),
                                        })
                                }</span>
                        case "DELETED":<span class="cov0" title="0">
                                delete(w.resources, resourceKey)

                                // Always show deletions
                                w.events = append(w.events, Event{
                                        EventType: "DELETED",
                                        Resource:  resource,
                                        Timestamp: time.Now(),
                                })</span>
                        }

                        // Limit recent events to max events
                        <span class="cov8" title="1">if len(w.events) &gt; w.maxEvents </span><span class="cov0" title="0">{
                                w.events = w.events[len(w.events)-w.maxEvents:]
                        }</span>

                        // Only do immediate refresh if we're not in initial caching phase
                        <span class="cov8" title="1">if !initialCaching </span><span class="cov0" title="0">{
                                // If this is first actual refresh after buffering, mark firstRun as false
                                if firstRun </span><span class="cov0" title="0">{
                                        w.refreshScreen()
                                        firstRun = false
                                }</span>
                        }

                        // Reset reconnect delay on successful events
                        <span class="cov8" title="1">w.reconnectDelay = 1 * time.Second</span>

                case &lt;-refreshTicker.C:<span class="cov0" title="0">
                        // Only refresh if we've exited initial caching or if we have a good batch of resources
                        if !initialCaching || len(w.resources) &gt; 0 </span><span class="cov0" title="0">{
                                w.refreshScreen()
                                // If we were caching, mark as no longer caching
                                initialCaching = false
                                firstRun = false
                        }</span>

                case &lt;-sig:<span class="cov0" title="0">
                        fmt.Println("\nWatch interrupted")
                        return nil</span>

                case &lt;-ctx.Done():<span class="cov8" title="1">
                        if ctx.Err() == context.DeadlineExceeded </span><span class="cov8" title="1">{
                                fmt.Println("\nWatch timeout reached")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return ctx.Err()</span>
                }
        }
}

// refreshScreen clears the screen and redraws the current state
func (w *ResourceWatcher) refreshScreen() <span class="cov8" title="1">{
        // Update terminal size for proper display
        w.updateTerminalSize()

        // Clear screen without adding to scrollback
        fmt.Print("\033[1;1H\033[J")

        fmt.Println()

        // Convert map to slice for sorting and rendering
        var resourcesList []Resource
        for _, res := range w.resources </span><span class="cov8" title="1">{
                resourcesList = append(resourcesList, res)
        }</span>

        // Print table with current resource state
        <span class="cov8" title="1">if len(resourcesList) &gt; 0 </span><span class="cov8" title="1">{
                if w.resourceToRowsRenderer != nil </span><span class="cov8" title="1">{
                        rows := w.resourceToRowsRenderer(resourcesList)
                        w.renderTable(rows)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("No custom resource renderer defined")
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        } else<span class="cov0" title="0"> {
                fmt.Println("No resources found")
                fmt.Println()
        }</span>

        // Print recent events if there are any
        <span class="cov8" title="1">if len(w.events) &gt; 0 </span><span class="cov8" title="1">{
                if w.eventRenderer != nil </span><span class="cov8" title="1">{
                        eventLines := w.eventRenderer(w.events)
                        for _, line := range eventLines </span><span class="cov8" title="1">{
                                fmt.Println(line)
                        }</span>
                } else<span class="cov0" title="0"> {
                        w.printDefaultEvents()
                }</span>
        }

        <span class="cov8" title="1">fmt.Println()
        fmt.Println("Press Ctrl+C to exit.")</span>
}

// renderTable renders a table with the provided rows
func (w *ResourceWatcher) renderTable(rows [][]string) <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Create a new table if we don't have one yet
        <span class="cov8" title="1">if w.tableRenderer == nil </span><span class="cov8" title="1">{
                table := pterm.DefaultTable.WithHasHeader(!w.ShowHeaders)
                // Customize the header style to use BoldBlue
                headerStyle := pterm.NewStyle(pterm.FgCyan, pterm.Bold)
                table = table.WithHeaderStyle(headerStyle)
                w.tableRenderer = table
        }</span>

        // Calculate how many rows we can display based on terminal height
        // Account for header, footer, event display etc.
        <span class="cov8" title="1">headerLines := 3                // Header text + blank line + table header
        footerLines := 3                // Blank line + "Press Ctrl+C" + buffer
        eventLines := len(w.events) + 1 // +1 for blank line
        if eventLines == 1 </span><span class="cov0" title="0">{
                eventLines = 0 // No blank line if no events
        }</span>

        <span class="cov8" title="1">maxTableLines := w.termHeight - headerLines - footerLines - eventLines - 1
        displayRows := rows

        // Ensure maxTableLines is at least 1 to avoid slice bounds errors
        if maxTableLines &lt; 1 </span><span class="cov0" title="0">{
                maxTableLines = 1
        }</span>

        // If we have more rows than can fit, truncate and add a message
        <span class="cov8" title="1">if len(rows) &gt; maxTableLines </span><span class="cov0" title="0">{
                displayRows = rows[:maxTableLines]
                fmt.Printf("... %d more resources not shown (limited by terminal height) ...\n", len(rows)-maxTableLines)
        }</span>

        // Render the table
        <span class="cov8" title="1">err := w.tableRenderer.WithData(displayRows).Render()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error rendering table:", err)
        }</span>
}

// printDefaultEvents prints recent events in a formatted way
func (w *ResourceWatcher) printDefaultEvents() <span class="cov0" title="0">{
        for _, event := range w.events </span><span class="cov0" title="0">{
                var symbol, color string
                var eventPrefix string

                switch event.EventType </span>{
                case "ADDED":<span class="cov0" title="0">
                        symbol = "+"
                        color = format.Green
                        eventPrefix = "ADDED"</span>
                case "MODIFIED":<span class="cov0" title="0">
                        symbol = "~"
                        color = format.Yellow
                        eventPrefix = "MODIFIED"</span>
                case "DELETED":<span class="cov0" title="0">
                        symbol = "-"
                        color = format.Red
                        eventPrefix = "DELETED"</span>
                }

                <span class="cov0" title="0">eventText := fmt.Sprintf("[%s] %s resource \"%s\"",
                        format.Colorize(color, symbol),
                        eventPrefix,
                        format.Colorize(format.Bold, event.Resource.GetKey()))

                fmt.Println(eventText)</span>
        }
}

// updateTerminalSize updates the cached terminal dimensions
func (w *ResourceWatcher) updateTerminalSize() <span class="cov8" title="1">{
        width, height, err := getTerminalSize()
        if err != nil </span><span class="cov8" title="1">{
                // Default if can't determine
                width, height = 100, 24
        }</span>
        <span class="cov8" title="1">w.termWidth = width
        w.termHeight = height</span>
}

// getTerminalSize returns the dimensions of the terminal
func getTerminalSize() (width, height int, err error) <span class="cov8" title="1">{
        // Default sizes if detection fails
        width, height = 80, 24

        // Try to get actual terminal size
        cmd := exec.Command("stty", "size")
        cmd.Stdin = os.Stdin
        out, err := cmd.Output()
        if err == nil </span><span class="cov0" title="0">{
                parts := strings.Split(strings.TrimSpace(string(out)), " ")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        if h, err := strconv.Atoi(parts[0]); err == nil </span><span class="cov0" title="0">{
                                height = h
                        }</span>
                        <span class="cov0" title="0">if w, err := strconv.Atoi(parts[1]); err == nil </span><span class="cov0" title="0">{
                                width = w
                        }</span>
                }
        }

        <span class="cov8" title="1">return width, height, err</span>
}

// min returns the smaller of two time.Duration values
func min(a, b time.Duration) time.Duration <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// ServiceResource is a wrapper around types.Service that implements the Resource interface
type ServiceResource struct {
        *types.Service
}

// GetKey returns a unique identifier for the service
func (s ServiceResource) GetKey() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s", s.Namespace, s.Name)
}</span>

// Equals checks if two services are functionally equivalent for watch purposes
func (s ServiceResource) Equals(other Resource) bool <span class="cov8" title="1">{
        otherService, ok := other.(ServiceResource)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check key fields that would make a service visibly different in the table
        <span class="cov8" title="1">return s.Name == otherService.Name &amp;&amp;
                s.Namespace == otherService.Namespace &amp;&amp;
                s.Status == otherService.Status &amp;&amp;
                s.Scale == otherService.Scale &amp;&amp;
                s.Image == otherService.Image &amp;&amp;
                s.Runtime == otherService.Runtime</span>
}

// ServiceWatcherAdapter adapts the ServiceWatcher interface to ResourceToWatch
type ServiceWatcherAdapter struct {
        ServiceWatcher
}

// Watch implements the ResourceToWatch interface
func (a ServiceWatcherAdapter) Watch(ctx context.Context, namespace, labelSelector, fieldSelector string) (&lt;-chan WatchEvent, error) <span class="cov8" title="1">{
        svcCh, err := a.WatchServices(namespace, labelSelector, fieldSelector)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create a new channel and adapt the events
        <span class="cov8" title="1">eventCh := make(chan WatchEvent)
        go func() </span><span class="cov8" title="1">{
                defer close(eventCh)

                for event := range svcCh </span><span class="cov8" title="1">{
                        if event.Error != nil </span><span class="cov8" title="1">{
                                eventCh &lt;- WatchEvent{
                                        Error: event.Error,
                                }
                                continue</span>
                        }

                        // Convert service to ServiceResource
                        <span class="cov8" title="1">svcResource := ServiceResource{event.Service}

                        eventCh &lt;- WatchEvent{
                                Resource:  svcResource,
                                EventType: event.EventType,
                                Error:     nil,
                        }</span>
                }
        }()

        <span class="cov8" title="1">return eventCh, nil</span>
}

// DefaultServiceResourceToRows returns a default row renderer for services
func DefaultServiceResourceToRows(resources []Resource) [][]string <span class="cov8" title="1">{
        // First create a list of just the services
        services := make([]*types.Service, 0, len(resources))
        for _, res := range resources </span><span class="cov8" title="1">{
                svcRes, ok := res.(ServiceResource)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">services = append(services, svcRes.Service)</span>
        }

        // Sort services by name
        <span class="cov8" title="1">sort.Slice(services, func(i, j int) bool </span><span class="cov0" title="0">{
                return services[i].Name &lt; services[j].Name
        }</span>)

        // Build rows
        <span class="cov8" title="1">var rows [][]string

        // Add header row - but first check if we have any services
        allNamespaces := false
        if len(services) &gt; 0 </span><span class="cov8" title="1">{
                for _, svc := range services </span><span class="cov8" title="1">{
                        if svc.Namespace != services[0].Namespace </span><span class="cov0" title="0">{
                                allNamespaces = true
                                break</span>
                        }
                }
        }

        // Add header row
        <span class="cov8" title="1">if allNamespaces </span><span class="cov0" title="0">{
                rows = append(rows, []string{"NAMESPACE", "NAME", "TYPE", "STATUS", "INSTANCES", "IMAGE/COMMAND", "AGE"})
        }</span> else<span class="cov8" title="1"> {
                rows = append(rows, []string{"NAME", "TYPE", "STATUS", "INSTANCES", "IMAGE/COMMAND", "AGE"})
        }</span>

        // Add service rows
        <span class="cov8" title="1">for _, service := range services </span><span class="cov8" title="1">{
                // Determine service type
                serviceType := "container"
                if service.Runtime == "process" &amp;&amp; service.Process != nil </span><span class="cov0" title="0">{
                        serviceType = "process"
                }</span>

                // Format status using the same colorizeStatus function from table.go
                <span class="cov8" title="1">status := format.PTermStatusLabel(string(service.Status))

                // Format instances
                instances := fmt.Sprintf("%d/%d", countRunningInstances(service), service.Scale)

                // Determine image or command
                imageOrCommand := service.Image
                if service.Runtime == "process" &amp;&amp; service.Process != nil </span><span class="cov0" title="0">{
                        imageOrCommand = service.Process.Command
                        if len(service.Process.Args) &gt; 0 </span><span class="cov0" title="0">{
                                imageOrCommand += " " + strings.Join(service.Process.Args, " ")
                        }</span>
                }

                // Truncate very long image/command strings
                <span class="cov8" title="1">if len(imageOrCommand) &gt; 60 </span><span class="cov0" title="0">{
                        imageOrCommand = truncateString(imageOrCommand, 60)
                }</span>

                // Calculate age
                <span class="cov8" title="1">age := formatAge(service.CreatedAt)

                // Create the row
                var row []string
                if allNamespaces </span><span class="cov0" title="0">{
                        row = []string{
                                service.Namespace,
                                service.Name,
                                serviceType,
                                status,
                                instances,
                                imageOrCommand,
                                age,
                        }
                }</span> else<span class="cov8" title="1"> {
                        row = []string{
                                service.Name,
                                serviceType,
                                status,
                                instances,
                                imageOrCommand,
                                age,
                        }
                }</span>

                <span class="cov8" title="1">rows = append(rows, row)</span>
        }

        <span class="cov8" title="1">return rows</span>
}

// DefaultServiceEventRenderer returns a default renderer for service events
func DefaultServiceEventRenderer(events []Event) []string <span class="cov8" title="1">{
        var lines []string
        for _, event := range events </span><span class="cov8" title="1">{
                var symbol, color string
                var eventPrefix string

                switch event.EventType </span>{
                case "ADDED":<span class="cov0" title="0">
                        symbol = "+"
                        color = format.Green
                        eventPrefix = "ADDED"</span>
                case "MODIFIED":<span class="cov8" title="1">
                        symbol = "~"
                        color = format.Yellow
                        eventPrefix = "MODIFIED"</span>
                case "DELETED":<span class="cov0" title="0">
                        symbol = "-"
                        color = format.Red
                        eventPrefix = "DELETED"</span>
                }

                <span class="cov8" title="1">svcRes, ok := event.Resource.(ServiceResource)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">eventText := fmt.Sprintf("[%s] %s service \"%s\"",
                        format.Colorize(color, symbol),
                        eventPrefix,
                        format.Colorize(format.Bold, svcRes.Name))

                lines = append(lines, eventText)</span>
        }
        <span class="cov8" title="1">return lines</span>
}

// countRunningInstances counts running instances for a service
// This is a placeholder that should be replaced with actual instance counting logic
func countRunningInstances(service *types.Service) int <span class="cov8" title="1">{
        // This is a placeholder - in a real implementation, we would count
        // the actual running instances from the service's status
        if service.Status == types.ServiceStatusRunning </span><span class="cov0" title="0">{
                return service.Scale
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// formatAge formats a time.Time as a human-readable age string
func formatAge(t time.Time) string <span class="cov8" title="1">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return "Unknown"
        }</span>

        <span class="cov8" title="1">duration := time.Since(t)
        if duration &lt; time.Minute </span><span class="cov8" title="1">{
                return "Just now"
        }</span> else<span class="cov8" title="1"> if duration &lt; time.Hour </span><span class="cov8" title="1">{
                minutes := int(duration.Minutes())
                return fmt.Sprintf("%dm", minutes)
        }</span> else<span class="cov8" title="1"> if duration &lt; 24*time.Hour </span><span class="cov8" title="1">{
                hours := int(duration.Hours())
                return fmt.Sprintf("%dh", hours)
        }</span> else<span class="cov8" title="1"> if duration &lt; 30*24*time.Hour </span><span class="cov8" title="1">{
                days := int(duration.Hours() / 24)
                return fmt.Sprintf("%dd", days)
        }</span> else<span class="cov8" title="1"> if duration &lt; 365*24*time.Hour </span><span class="cov8" title="1">{
                months := int(duration.Hours() / 24 / 30)
                return fmt.Sprintf("%dmo", months)
        }</span>
        <span class="cov8" title="1">years := int(duration.Hours() / 24 / 365)
        return fmt.Sprintf("%dy", years)</span>
}

// truncateString truncates a string to maxLen and adds "..." if it was truncated
func truncateString(s string, maxLen int) string <span class="cov0" title="0">{
        if len(s) &lt;= maxLen </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:maxLen-3] + "..."</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package format

import (
        "fmt"
        "os"
        "runtime"
        "strings"

        "github.com/pterm/pterm"
)

// Color codes
const (
        Reset      = "\033[0m"
        Bold       = "\033[1m"
        Red        = "\033[31m"
        Green      = "\033[32m"
        Yellow     = "\033[33m"
        Blue       = "\033[34m"
        DarkBlue   = "\033[34;1m"
        Magenta    = "\033[35m"
        Cyan       = "\033[36m"
        White      = "\033[37m"
        BoldRed    = "\033[1;31m"
        BoldGreen  = "\033[1;32m"
        BoldYellow = "\033[1;33m"
        BoldBlue   = "\033[1;34m"
        BoldCyan   = "\033[1;36m"
)

var (
        // useColor determines whether to use color in output
        useColor = true
)

// init determines whether colors should be enabled by default
func init() <span class="cov8" title="1">{
        // Disable colors by default on Windows unless using a terminal that supports them
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Check if terminal supports colors (ConEmu, Windows Terminal, etc.)
                // ANSICON is set by ConEmu and other terminals that support ANSI colors
                // WT_SESSION is set by Windows Terminal
                _, hasAnsicon := os.LookupEnv("ANSICON")
                _, hasWT := os.LookupEnv("WT_SESSION")
                useColor = hasAnsicon || hasWT
        }</span>

        // If RUNE_NO_COLOR or NO_COLOR is set, disable colors
        <span class="cov8" title="1">if _, noColor := os.LookupEnv("RUNE_NO_COLOR"); noColor </span><span class="cov0" title="0">{
                useColor = false
        }</span>
        <span class="cov8" title="1">if _, noColor := os.LookupEnv("NO_COLOR"); noColor </span><span class="cov0" title="0">{
                useColor = false
        }</span>

        // If output is not a terminal, disable colors (unless forced)
        <span class="cov8" title="1">if _, forceColor := os.LookupEnv("RUNE_FORCE_COLOR"); !forceColor </span><span class="cov8" title="1">{
                fileInfo, _ := os.Stdout.Stat()
                if (fileInfo.Mode() &amp; os.ModeCharDevice) == 0 </span><span class="cov8" title="1">{
                        useColor = false
                }</span>
        }
}

// EnableColor enables or disables colored output globally
func EnableColor(enable bool) <span class="cov0" title="0">{
        useColor = enable
}</span>

// IsColorEnabled returns whether colored output is enabled
func IsColorEnabled() bool <span class="cov0" title="0">{
        return useColor
}</span>

// Colorize adds color to a string if colors are enabled
func Colorize(color, text string) string <span class="cov8" title="1">{
        if useColor </span><span class="cov0" title="0">{
                return color + text + Reset
        }</span>
        <span class="cov8" title="1">return text</span>
}

// Success formats a message as a success (green)
func Success(format string, a ...interface{}) string <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, a...)
        return Colorize(Green, msg)
}</span>

// Warning formats a message as a warning (yellow)
func Warning(format string, a ...interface{}) string <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, a...)
        return Colorize(Yellow, msg)
}</span>

// Error formats a message as an error (red)
func Error(format string, a ...interface{}) string <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, a...)
        return Colorize(Red, msg)
}</span>

// Info formats a message as info (cyan)
func Info(format string, a ...interface{}) string <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, a...)
        return Colorize(Cyan, msg)
}</span>

// Highlight formats a message as highlighted (bold cyan)
func Highlight(format string, a ...interface{}) string <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, a...)
        return Colorize(BoldCyan, msg)
}</span>

// StatusSymbol returns a colorized status symbol
func StatusSymbol(success bool) string <span class="cov0" title="0">{
        if success </span><span class="cov0" title="0">{
                return Colorize(Green, "")
        }</span>
        <span class="cov0" title="0">return Colorize(Red, "")</span>
}

// Header formats a message as a header (bold blue)
func Header(format string, a ...interface{}) string <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, a...)
        return Colorize(BoldBlue, msg)
}</span>

// Dim formats a message as dimmed (white)
func Dim(format string, a ...interface{}) string <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, a...)
        return Colorize(White, msg)
}</span>

// Label formats a key and value with a label style
func Label(key, value string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s %s", Colorize(BoldCyan, key+":"), value)
}</span>

// StatusLabel formats a status label based on the status value
func StatusLabel(status string) string <span class="cov0" title="0">{
        status = strings.ToLower(status)
        switch status </span>{
        case "running", "success", "succeeded", "healthy", "active", "ready":<span class="cov0" title="0">
                return Colorize(BoldGreen, status)</span>
        case "pending", "waiting", "starting", "initializing":<span class="cov0" title="0">
                return Colorize(BoldYellow, status)</span>
        case "failed", "error", "unhealthy", "terminated":<span class="cov0" title="0">
                return Colorize(BoldRed, status)</span>
        default:<span class="cov0" title="0">
                return Colorize(White, status)</span>
        }
}

// PTermStatusLabel applies consistent coloring to status strings based on their value
func PTermStatusLabel(status string) string <span class="cov8" title="1">{
        // Convert to lowercase for comparison
        statusLower := strings.ToLower(status)

        switch statusLower </span>{
        case "running", "success", "succeeded", "healthy", "active", "ready":<span class="cov0" title="0">
                return pterm.NewStyle(pterm.FgGreen, pterm.Bold).Sprint(status)</span>
        case "pending", "waiting", "starting", "initializing", "updating", "deploying":<span class="cov8" title="1">
                return pterm.NewStyle(pterm.FgYellow, pterm.Bold).Sprint(status)</span>
        case "failed", "error", "unhealthy", "terminated":<span class="cov0" title="0">
                return pterm.NewStyle(pterm.FgRed, pterm.Bold).Sprint(status)</span>
        default:<span class="cov0" title="0">
                return pterm.NewStyle(pterm.FgWhite).Sprint(status)</span>
        }
}

// FormatTable colorizes a table of strings based on a header row
func FormatTable(table [][]string, headerRow bool) [][]string <span class="cov0" title="0">{
        result := make([][]string, len(table))
        for i, row := range table </span><span class="cov0" title="0">{
                result[i] = make([]string, len(row))
                if i == 0 &amp;&amp; headerRow </span><span class="cov0" title="0">{
                        // Color the header row
                        for j, cell := range row </span><span class="cov0" title="0">{
                                result[i][j] = Colorize(BoldCyan, cell)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Copy the row unchanged
                        copy(result[i], row)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package format

import (
        "bufio"
        "bytes"
        "encoding/json"
        "fmt"
        "os"
        "regexp"
        "sort"
        "strconv"
        "strings"
        "time"

        "github.com/fatih/color"
        "golang.org/x/term"
)

// Error types
const (
        ErrorType   = "error"
        WarningType = "warning"
        InfoType    = "info"
)

// Error colors
var (
        ErrorColor     = color.New(color.FgRed, color.Bold)
        WarningColor   = color.New(color.FgYellow, color.Bold)
        SuccessColor   = color.New(color.FgGreen, color.Bold)
        FileColor      = color.New(color.FgCyan)
        LineColor      = color.New(color.FgHiGreen)
        CodeColor      = color.New(color.FgWhite)
        ContextColor   = color.New(color.FgHiBlack)
        HintColor      = color.New(color.FgYellow, color.Italic)
        HeadingColor   = color.New(color.FgHiWhite, color.Bold)
        HighlightColor = color.New(color.FgHiRed)
)

// ValidationError represents a structured validation error
type ValidationError struct {
        FileName     string `json:"file_name"`
        LineNumber   int    `json:"line_number"`
        Message      string `json:"message"`
        ErrorType    string `json:"error_type"`
        Hint         string `json:"hint,omitempty"`
        AutoFixable  bool   `json:"auto_fixable"`
        FixApplied   bool   `json:"fix_applied"`
        ResourceName string `json:"resource_name,omitempty"`
        ResourceType string `json:"resource_type,omitempty"`
        Context      string `json:"context,omitempty"`
}

// ErrorFormatter is used to format and print error messages
type ErrorFormatter struct {
        FileName      string
        FileData      []byte
        ContextLines  int
        CanAutoFix    bool
        OutputFormat  string
        Errors        []ValidationError
        StartTime     time.Time
        TerminalWidth int
        ErrorCount    int
        WarningCount  int
        FixCount      int
}

// ErrorCategoryMapping maps error patterns to categories
var ErrorCategoryMapping = map[string]string{
        "invalid YAML":               "YAML_SYNTAX",
        "field validation failed":    "FIELD_VALIDATION",
        "missing required field":     "MISSING_FIELD",
        "invalid value":              "INVALID_VALUE",
        "unknown field":              "UNKNOWN_FIELD",
        "duplicate field":            "DUPLICATE_FIELD",
        "unexpected format":          "FORMAT_ERROR",
        "check indentation":          "INDENTATION_ERROR",
        "reference error":            "REFERENCE_ERROR",
        "unrecognized resource type": "UNKNOWN_RESOURCE",
        "must be between":            "RANGE_ERROR",
        "cannot be negative":         "NEGATIVE_VALUE",
        "is required":                "MISSING_REQUIRED",
        "must specify":               "MISSING_SPECIFICATION",
        "must have":                  "MISSING_REQUIREMENT",
}

// Common YAML indentation error patterns
var indentationPatterns = []string{
        "mapping values are not allowed in this context",
        "did not find expected key",
        "unexpected format - check indentation",
        "block sequence entries are not allowed",
        "not enough space",
        "line contains invalid character",
        "invalid leading UTF-8 octet",
}

// Common hint templates
var hintTemplates = map[string]string{
        "YAML_SYNTAX":      "Check your YAML indentation. Each level should be indented with 2 spaces.\n       Make sure the structure follows the correct format for this resource type.",
        "FIELD_VALIDATION": "Review the field value against its expected format or constraints.\n       Common issues include incorrect types, formats, or pattern matching.",
        "MISSING_FIELD":    "Add the required field '%s' to your configuration.\n       This field is mandatory for this resource type.",
        "INVALID_VALUE":    "The value provided is not valid for field '%s'.\n       Check documentation for allowed values and formats.",
        "RANGE_ERROR":      "Values must be within the specified range. Check the min/max requirements.",
        "NEGATIVE_VALUE":   "This field cannot have a negative value. Use zero or a positive number.",
        "MISSING_REQUIRED": "Add the required field to complete the configuration.",
}

// NewErrorFormatter creates a new error formatter
func NewErrorFormatter(filename string, data []byte) *ErrorFormatter <span class="cov0" title="0">{
        width, _, err := term.GetSize(int(os.Stdout.Fd()))
        if err != nil </span><span class="cov0" title="0">{
                width = 80 // Default width if can't detect terminal
        }</span>

        <span class="cov0" title="0">return &amp;ErrorFormatter{
                FileName:      filename,
                FileData:      data,
                ContextLines:  1,
                OutputFormat:  "text",
                StartTime:     time.Now(),
                TerminalWidth: width,
                ErrorCount:    0,
                WarningCount:  0,
                FixCount:      0,
        }</span>
}

// PrintErrorHeader prints a header for errors
func (f *ErrorFormatter) PrintErrorHeader() <span class="cov0" title="0">{
        if f.OutputFormat == "json" </span><span class="cov0" title="0">{
                return
        }</span>

        // Only print once if we already have errors
        <span class="cov0" title="0">if len(f.Errors) &gt; 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fmt.Println()
        divider := strings.Repeat("", f.TerminalWidth)
        ErrorColor.Println(" VALIDATION FAILED", FileColor.Sprintf(f.FileName))
        fmt.Println(divider)
        fmt.Println()</span>
}

// ExtractLineNumber tries to extract a line number from an error message
func (f *ErrorFormatter) ExtractLineNumber(errStr string) int <span class="cov0" title="0">{
        // Try to find line number in common YAML error formats
        lineRegexes := []*regexp.Regexp{
                regexp.MustCompile(`line (\d+)`),
                regexp.MustCompile(`line: (\d+)`),
                regexp.MustCompile(`line:(\d+)`),
        }

        for _, re := range lineRegexes </span><span class="cov0" title="0">{
                matches := re.FindStringSubmatch(errStr)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        if num, err := strconv.Atoi(matches[1]); err == nil </span><span class="cov0" title="0">{
                                return num
                        }</span>
                }
        }

        <span class="cov0" title="0">return 0</span>
}

// ExtractFieldName tries to extract a field name from an error message
func (f *ErrorFormatter) ExtractFieldName(errStr string) string <span class="cov0" title="0">{
        // Try to extract field name from common patterns
        fieldRegexes := []*regexp.Regexp{
                regexp.MustCompile(`field ([a-zA-Z0-9_.-]+) is`),
                regexp.MustCompile(`field '([a-zA-Z0-9_.-]+)'`),
                regexp.MustCompile(`for field ([a-zA-Z0-9_.-]+)`),
                regexp.MustCompile(`missing required field ([a-zA-Z0-9_.-]+)`),
        }

        for _, re := range fieldRegexes </span><span class="cov0" title="0">{
                matches := re.FindStringSubmatch(errStr)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        return matches[1]
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// extractLineContext gets the line and its surrounding context
func (f *ErrorFormatter) extractLineContext(lineNum int) (string, string, string) <span class="cov0" title="0">{
        if f.FileData == nil || lineNum &lt;= 0 </span><span class="cov0" title="0">{
                return "", "", ""
        }</span>

        <span class="cov0" title="0">scanner := bufio.NewScanner(bytes.NewReader(f.FileData))
        var before []string
        var current string
        var after []string
        lineCount := 0

        // Collect lines around the error
        for scanner.Scan() </span><span class="cov0" title="0">{
                lineCount++
                if lineCount &lt; lineNum-f.ContextLines </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if lineCount == lineNum </span><span class="cov0" title="0">{
                        current = scanner.Text()
                }</span> else<span class="cov0" title="0"> if lineCount &gt; lineNum-f.ContextLines &amp;&amp; lineCount &lt; lineNum </span><span class="cov0" title="0">{
                        before = append(before, scanner.Text())
                }</span> else<span class="cov0" title="0"> if lineCount &gt; lineNum &amp;&amp; lineCount &lt;= lineNum+f.ContextLines </span><span class="cov0" title="0">{
                        after = append(after, scanner.Text())
                }</span> else<span class="cov0" title="0"> if lineCount &gt; lineNum+f.ContextLines </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Format the context
        <span class="cov0" title="0">beforeStr := ""
        if len(before) &gt; 0 </span><span class="cov0" title="0">{
                beforeStr = strings.Join(before, "\n")
        }</span>

        <span class="cov0" title="0">afterStr := ""
        if len(after) &gt; 0 </span><span class="cov0" title="0">{
                afterStr = strings.Join(after, "\n")
        }</span>

        <span class="cov0" title="0">return beforeStr, current, afterStr</span>
}

// GenerateHint creates a hint based on the error message
func (f *ErrorFormatter) GenerateHint(errStr, errType string) string <span class="cov0" title="0">{
        // Check if it's an indentation error
        for _, pattern := range indentationPatterns </span><span class="cov0" title="0">{
                if strings.Contains(errStr, pattern) </span><span class="cov0" title="0">{
                        return hintTemplates["YAML_SYNTAX"]
                }</span>
        }

        // Check if it's a missing field
        <span class="cov0" title="0">if strings.Contains(errStr, "missing required field") || strings.Contains(errStr, "is required") </span><span class="cov0" title="0">{
                fieldName := f.ExtractFieldName(errStr)
                if fieldName != "" </span><span class="cov0" title="0">{
                        return fmt.Sprintf(hintTemplates["MISSING_FIELD"], fieldName)
                }</span>
                <span class="cov0" title="0">return hintTemplates["MISSING_REQUIRED"]</span>
        }

        // Check if it's a range error
        <span class="cov0" title="0">if strings.Contains(errStr, "must be between") </span><span class="cov0" title="0">{
                return hintTemplates["RANGE_ERROR"]
        }</span>

        // Check if it's a negative value error
        <span class="cov0" title="0">if strings.Contains(errStr, "negative") </span><span class="cov0" title="0">{
                return hintTemplates["NEGATIVE_VALUE"]
        }</span>

        // Check if it's an invalid value
        <span class="cov0" title="0">if strings.Contains(errStr, "invalid value") </span><span class="cov0" title="0">{
                fieldName := f.ExtractFieldName(errStr)
                if fieldName != "" </span><span class="cov0" title="0">{
                        return fmt.Sprintf(hintTemplates["INVALID_VALUE"], fieldName)
                }</span>
                <span class="cov0" title="0">return hintTemplates["FIELD_VALIDATION"]</span>
        }

        // Default hint based on error type
        <span class="cov0" title="0">if hint, ok := hintTemplates[errType]; ok </span><span class="cov0" title="0">{
                return hint
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// AddError adds a new error to the formatter
func (f *ErrorFormatter) AddError(err ValidationError) <span class="cov0" title="0">{
        f.Errors = append(f.Errors, err)
        if err.ErrorType == ErrorType </span><span class="cov0" title="0">{
                f.ErrorCount++
        }</span> else<span class="cov0" title="0"> if err.ErrorType == WarningType </span><span class="cov0" title="0">{
                f.WarningCount++
        }</span>
}

// PrintError prints an error with context
func (f *ErrorFormatter) PrintError(errStr string, lineNum int) <span class="cov0" title="0">{
        // Determine error type
        errType := "GENERAL_ERROR"
        for pattern, category := range ErrorCategoryMapping </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(errStr), strings.ToLower(pattern)) </span><span class="cov0" title="0">{
                        errType = category
                        break</span>
                }
        }

        <span class="cov0" title="0">autoFixable := false
        hint := f.GenerateHint(errStr, errType)

        // YAML indentation errors are often auto-fixable
        for _, pattern := range indentationPatterns </span><span class="cov0" title="0">{
                if strings.Contains(errStr, pattern) </span><span class="cov0" title="0">{
                        if hint == "" </span><span class="cov0" title="0">{
                                hint = "Check YAML indentation. Each level should be indented with 2 spaces."
                        }</span>
                        <span class="cov0" title="0">autoFixable = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if f.OutputFormat == "json" </span><span class="cov0" title="0">{
                // Get context
                before, current, after := f.extractLineContext(lineNum)
                contextString := ""
                if current != "" </span><span class="cov0" title="0">{
                        if before != "" </span><span class="cov0" title="0">{
                                contextString += before + "\n"
                        }</span>
                        <span class="cov0" title="0">contextString += current + "\n"
                        if after != "" </span><span class="cov0" title="0">{
                                contextString += after
                        }</span>
                }

                // Store the error
                <span class="cov0" title="0">f.AddError(ValidationError{
                        FileName:    f.FileName,
                        LineNumber:  lineNum,
                        Message:     errStr,
                        ErrorType:   errType,
                        Hint:        hint,
                        AutoFixable: autoFixable,
                        Context:     contextString,
                })

                return</span>
        }

        // Print the error
        <span class="cov0" title="0">indent := "  "
        if lineNum &gt; 0 </span><span class="cov0" title="0">{
                // Get context
                before, current, after := f.extractLineContext(lineNum)

                // Print line and line number information
                LineColor.Printf(" Line %d:\n", lineNum)

                // Print any before context with line numbers
                if before != "" </span><span class="cov0" title="0">{
                        lines := strings.Split(before, "\n")
                        lineStart := lineNum - len(lines)
                        for i, line := range lines </span><span class="cov0" title="0">{
                                ContextColor.Printf("%d  %s\n", lineStart+i, line)
                        }</span>
                }

                // Print the error line with highlighting
                <span class="cov0" title="0">CodeColor.Printf("%d  %s\n", lineNum, current)

                // Print any after context with line numbers
                if after != "" </span><span class="cov0" title="0">{
                        lines := strings.Split(after, "\n")
                        for i, line := range lines </span><span class="cov0" title="0">{
                                ContextColor.Printf("%d  %s\n", lineNum+i+1, line)
                        }</span>
                }

                // Print the error message
                <span class="cov0" title="0">fmt.Println()
                ErrorColor.Printf("%sError: %s\n", indent, errStr)

                // Print hint if available
                if hint != "" </span><span class="cov0" title="0">{
                        HintColor.Printf("%sHint: %s\n\n", indent, hint)
                }</span>
        } else<span class="cov0" title="0"> {
                ErrorColor.Printf("%sError: %s\n", indent, errStr)
                if hint != "" </span><span class="cov0" title="0">{
                        HintColor.Printf("%sHint: %s\n\n", indent, hint)
                }</span>
        }
}

// PrintServiceError prints an error specific to a service
func (f *ErrorFormatter) PrintServiceError(serviceName, errStr string, lineNum int) <span class="cov0" title="0">{
        // Determine error type
        errType := "SERVICE_ERROR"
        for pattern, category := range ErrorCategoryMapping </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(errStr), strings.ToLower(pattern)) </span><span class="cov0" title="0">{
                        errType = category
                        break</span>
                }
        }

        <span class="cov0" title="0">hint := f.GenerateHint(errStr, errType)
        autoFixable := false

        if f.OutputFormat == "json" </span><span class="cov0" title="0">{
                // Get context
                before, current, after := f.extractLineContext(lineNum)
                contextString := ""
                if current != "" </span><span class="cov0" title="0">{
                        if before != "" </span><span class="cov0" title="0">{
                                contextString += before + "\n"
                        }</span>
                        <span class="cov0" title="0">contextString += current + "\n"
                        if after != "" </span><span class="cov0" title="0">{
                                contextString += after
                        }</span>
                }

                // Store the error
                <span class="cov0" title="0">f.AddError(ValidationError{
                        FileName:     f.FileName,
                        LineNumber:   lineNum,
                        Message:      errStr,
                        ErrorType:    errType,
                        Hint:         hint,
                        AutoFixable:  autoFixable,
                        ResourceName: serviceName,
                        ResourceType: "service",
                        Context:      contextString,
                })

                return</span>
        }

        // Print the service error
        <span class="cov0" title="0">indent := "  "

        // Print service name if available
        if serviceName != "" </span><span class="cov0" title="0">{
                FileColor.Printf("Service '%s':\n", serviceName)
        }</span>

        <span class="cov0" title="0">if lineNum &gt; 0 </span><span class="cov0" title="0">{
                // Get context
                before, current, after := f.extractLineContext(lineNum)

                // Print line and line number information
                LineColor.Printf(" Line %d:\n", lineNum)

                // Print any before context with line numbers
                if before != "" </span><span class="cov0" title="0">{
                        lines := strings.Split(before, "\n")
                        lineStart := lineNum - len(lines)
                        for i, line := range lines </span><span class="cov0" title="0">{
                                ContextColor.Printf("%d  %s\n", lineStart+i, line)
                        }</span>
                }

                // Print the error line with highlighting
                <span class="cov0" title="0">CodeColor.Printf("%d  %s\n", lineNum, current)

                // Print any after context with line numbers
                if after != "" </span><span class="cov0" title="0">{
                        lines := strings.Split(after, "\n")
                        for i, line := range lines </span><span class="cov0" title="0">{
                                ContextColor.Printf("%d  %s\n", lineNum+i+1, line)
                        }</span>
                }

                // Print the error message
                <span class="cov0" title="0">fmt.Println()
                ErrorColor.Printf("%sError: %s\n", indent, errStr)

                // Print hint if available
                if hint != "" </span><span class="cov0" title="0">{
                        HintColor.Printf("%sHint: %s\n", indent, hint)
                }</span>
        } else<span class="cov0" title="0"> {
                ErrorColor.Printf("%sError: %s\n", indent, errStr)
                if hint != "" </span><span class="cov0" title="0">{
                        HintColor.Printf("%sHint: %s\n", indent, hint)
                }</span>
        }
}

// TryAutoFix attempts to fix common errors
func (f *ErrorFormatter) TryAutoFix(errStr string, lineNum int) (bool, []byte) <span class="cov0" title="0">{
        if f.FileData == nil || lineNum &lt;= 0 || !f.CanAutoFix </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Clone the file data
        <span class="cov0" title="0">newData := make([]byte, len(f.FileData))
        copy(newData, f.FileData)

        // Check if it's an indentation error
        if isIndentationError(errStr) </span><span class="cov0" title="0">{
                return f.fixIndentation(lineNum, newData)
        }</span>

        // Check if it's a boolean format issue
        <span class="cov0" title="0">if strings.Contains(errStr, "cannot unmarshal") &amp;&amp;
                (strings.Contains(errStr, "bool") || strings.Contains(errStr, "boolean")) </span><span class="cov0" title="0">{
                return f.fixBooleanValue(lineNum, newData)
        }</span>

        // Check if it's a required field issue
        <span class="cov0" title="0">if strings.Contains(errStr, "missing required field") </span><span class="cov0" title="0">{
                return f.fixMissingField(errStr, lineNum, newData)
        }</span>

        <span class="cov0" title="0">return false, nil</span>
}

// isIndentationError checks if an error is related to indentation
func isIndentationError(errStr string) bool <span class="cov0" title="0">{
        for _, pattern := range indentationPatterns </span><span class="cov0" title="0">{
                if strings.Contains(errStr, pattern) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// fixIndentation attempts to fix indentation issues
func (f *ErrorFormatter) fixIndentation(lineNum int, data []byte) (bool, []byte) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(bytes.NewReader(data))
        var lines []string
        lineCount := 0

        prevIndentLevel := 0

        // Read all lines
        for scanner.Scan() </span><span class="cov0" title="0">{
                lineCount++
                line := scanner.Text()

                // Only calculate indentation if not on the error line
                if lineCount != lineNum </span><span class="cov0" title="0">{
                        // Get the indentation level of non-error lines
                        indentMatch := regexp.MustCompile(`^(\s*)`).FindString(line)
                        prevIndentLevel = len(indentMatch) / 2
                }</span>

                // If this is the error line, try to fix indentation
                <span class="cov0" title="0">if lineCount == lineNum </span><span class="cov0" title="0">{
                        // Get the previous non-empty line's indentation
                        for i := len(lines) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                if strings.TrimSpace(lines[i]) != "" </span><span class="cov0" title="0">{
                                        prevIndent := regexp.MustCompile(`^(\s*)`).FindString(lines[i])
                                        prevIndentLevel = len(prevIndent) / 2
                                        break</span>
                                }
                        }

                        // Check if this line starts with a key
                        <span class="cov0" title="0">if strings.Contains(line, ":") </span><span class="cov0" title="0">{
                                keyMatch := regexp.MustCompile(`^(\s*)(\S+):`).FindStringSubmatch(line)
                                if len(keyMatch) &gt;= 3 </span><span class="cov0" title="0">{
                                        // This is a key, should it be indented?
                                        if strings.HasSuffix(strings.TrimSpace(lines[len(lines)-1]), ":") </span><span class="cov0" title="0">{
                                                // Previous line ends with :, this should be indented more
                                                correctIndent := strings.Repeat("  ", prevIndentLevel+1)
                                                correctedLine := correctIndent + strings.TrimLeft(line, " \t")
                                                lines = append(lines, correctedLine)
                                                continue</span>
                                        } else<span class="cov0" title="0"> if strings.Contains(lines[len(lines)-1], ":") &amp;&amp;
                                                !strings.HasSuffix(strings.TrimSpace(lines[len(lines)-1]), ":") </span><span class="cov0" title="0">{
                                                // Previous line has a key: value, this should have the same indentation
                                                correctIndent := strings.Repeat("  ", prevIndentLevel)
                                                correctedLine := correctIndent + strings.TrimLeft(line, " \t")
                                                lines = append(lines, correctedLine)
                                                continue</span>
                                        }
                                }
                        }

                        // Check if it's a list item
                        <span class="cov0" title="0">if strings.TrimLeft(line, " \t")[0] == '-' </span><span class="cov0" title="0">{
                                // Is the previous line also a list item?
                                if strings.Contains(strings.TrimSpace(lines[len(lines)-1]), "- ") </span><span class="cov0" title="0">{
                                        // Should have same indentation as previous list item
                                        correctIndent := regexp.MustCompile(`^(\s*)`).FindString(lines[len(lines)-1])
                                        correctedLine := correctIndent + strings.TrimLeft(line, " \t")
                                        lines = append(lines, correctedLine)
                                        continue</span>
                                } else<span class="cov0" title="0"> if strings.HasSuffix(strings.TrimSpace(lines[len(lines)-1]), ":") </span><span class="cov0" title="0">{
                                        // Previous line ends with :, this should be a list under it
                                        correctIndent := strings.Repeat("  ", prevIndentLevel+1)
                                        correctedLine := correctIndent + strings.TrimLeft(line, " \t")
                                        lines = append(lines, correctedLine)
                                        continue</span>
                                }
                        }

                        // If we're here, we couldn't determine a specific fix, try basic approach
                        // Based on colon patterns
                        <span class="cov0" title="0">if strings.HasSuffix(strings.TrimSpace(lines[len(lines)-1]), ":") </span><span class="cov0" title="0">{
                                // Previous line ends with :, this should be indented more
                                correctIndent := strings.Repeat("  ", prevIndentLevel+1)
                                correctedLine := correctIndent + strings.TrimLeft(line, " \t")
                                lines = append(lines, correctedLine)
                        }</span> else<span class="cov0" title="0"> {
                                // Just add the line as-is for now
                                lines = append(lines, line)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Not the error line, just add it
                        lines = append(lines, line)
                }</span>
        }

        // Create new data
        <span class="cov0" title="0">newData := []byte(strings.Join(lines, "\n"))
        if len(f.FileData) &gt; 0 &amp;&amp; f.FileData[len(f.FileData)-1] == '\n' </span><span class="cov0" title="0">{
                // Preserve trailing newline if original had one
                newData = append(newData, '\n')
        }</span>

        // Only return true if we actually made changes
        <span class="cov0" title="0">return !bytes.Equal(data, newData), newData</span>
}

// fixBooleanValue attempts to fix boolean values
func (f *ErrorFormatter) fixBooleanValue(lineNum int, data []byte) (bool, []byte) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(bytes.NewReader(data))
        var lines []string
        lineCount := 0

        // Read all lines
        for scanner.Scan() </span><span class="cov0" title="0">{
                lineCount++
                line := scanner.Text()

                // If this is the error line, try to fix boolean value
                if lineCount == lineNum </span><span class="cov0" title="0">{
                        // Find patterns like key: yes, key: no, key: True, key: False
                        boolPattern := regexp.MustCompile(`^(\s*)([^:]+):\s*(yes|no|Yes|No|TRUE|FALSE|True|False)(.*)$`)
                        matches := boolPattern.FindStringSubmatch(line)

                        if len(matches) &gt;= 4 </span><span class="cov0" title="0">{
                                indent := matches[1]
                                key := matches[2]
                                value := matches[3]
                                rest := matches[4]

                                // Map to correct boolean values
                                correctValue := "false"
                                if strings.ToLower(value) == "yes" || strings.ToLower(value) == "true" </span><span class="cov0" title="0">{
                                        correctValue = "true"
                                }</span>

                                // Create corrected line
                                <span class="cov0" title="0">correctedLine := fmt.Sprintf("%s%s: %s%s", indent, key, correctValue, rest)
                                lines = append(lines, correctedLine)
                                continue</span>
                        }
                }

                // Not the error line or not a boolean error, just add it
                <span class="cov0" title="0">lines = append(lines, line)</span>
        }

        // Create new data
        <span class="cov0" title="0">newData := []byte(strings.Join(lines, "\n"))
        if len(f.FileData) &gt; 0 &amp;&amp; f.FileData[len(f.FileData)-1] == '\n' </span><span class="cov0" title="0">{
                // Preserve trailing newline if original had one
                newData = append(newData, '\n')
        }</span>

        // Only return true if we actually made changes
        <span class="cov0" title="0">return !bytes.Equal(data, newData), newData</span>
}

// fixMissingField attempts to add missing required fields
func (f *ErrorFormatter) fixMissingField(errStr string, lineNum int, data []byte) (bool, []byte) <span class="cov0" title="0">{
        fieldName := f.ExtractFieldName(errStr)
        if fieldName == "" </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">scanner := bufio.NewScanner(bytes.NewReader(data))
        var lines []string
        lineCount := 0

        // Find the parent object level for this field
        parentIndent := ""
        sectionFound := false

        // First pass to determine context
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                lineCount++

                // If we're at or past the error line
                if lineCount &gt;= lineNum </span><span class="cov0" title="0">{
                        // Look for a parent section that might be missing a field
                        indentMatch := regexp.MustCompile(`^(\s*)`).FindString(line)
                        if parentIndent == "" || len(indentMatch) &lt; len(parentIndent) </span><span class="cov0" title="0">{
                                parentIndent = indentMatch
                                sectionFound = true
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">lines = append(lines, line)</span>
        }

        // Reset for second pass
        <span class="cov0" title="0">lineCount = 0
        scanner = bufio.NewScanner(bytes.NewReader(data))
        lines = []string{}

        // Second pass to insert missing field
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                lineCount++

                lines = append(lines, line)

                // If we've found a section and we're at the error line
                if sectionFound &amp;&amp; lineCount == lineNum </span><span class="cov0" title="0">{
                        // Insert the missing field with appropriate default value
                        var defaultValue string

                        // Choose appropriate default based on field name
                        switch strings.ToLower(fieldName) </span>{
                        case "name":<span class="cov0" title="0">
                                defaultValue = "default-name"</span>
                        case "image":<span class="cov0" title="0">
                                defaultValue = "default-image:latest"</span>
                        case "port":<span class="cov0" title="0">
                                defaultValue = "80"</span>
                        case "scale":<span class="cov0" title="0">
                                defaultValue = "1"</span>
                        case "namespace":<span class="cov0" title="0">
                                defaultValue = "default"</span>
                        default:<span class="cov0" title="0">
                                defaultValue = ""</span> // Empty string for unknown fields
                        }

                        // Create field line with proper indentation
                        <span class="cov0" title="0">fieldLine := fmt.Sprintf("%s  %s: %s", parentIndent, fieldName, defaultValue)
                        lines = append(lines, fieldLine)</span>
                }
        }

        // Create new data
        <span class="cov0" title="0">newData := []byte(strings.Join(lines, "\n"))
        if len(f.FileData) &gt; 0 &amp;&amp; f.FileData[len(f.FileData)-1] == '\n' </span><span class="cov0" title="0">{
                // Preserve trailing newline if original had one
                newData = append(newData, '\n')
        }</span>

        // Only return true if we actually made changes
        <span class="cov0" title="0">return !bytes.Equal(data, newData), newData</span>
}

// FormatAsJSON formats all errors as a JSON string
func (f *ErrorFormatter) FormatAsJSON() string <span class="cov0" title="0">{
        result := map[string]interface{}{
                "filename":      f.FileName,
                "errors":        f.Errors,
                "error_count":   f.ErrorCount,
                "warning_count": f.WarningCount,
                "fix_count":     f.FixCount,
                "time":          time.Since(f.StartTime).Seconds(),
                "success":       f.ErrorCount == 0,
        }

        jsonBytes, err := json.MarshalIndent(result, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf(`{"error":"Failed to marshal JSON: %s"}`, err.Error())
        }</span>

        <span class="cov0" title="0">return string(jsonBytes)</span>
}

// PrintErrorSummary prints a summary of all errors categorized by type
func (f *ErrorFormatter) PrintErrorSummary() <span class="cov0" title="0">{
        if f.OutputFormat == "json" || len(f.Errors) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Group errors by type
        <span class="cov0" title="0">byType := make(map[string][]ValidationError)
        for _, err := range f.Errors </span><span class="cov0" title="0">{
                byType[err.ErrorType] = append(byType[err.ErrorType], err)
        }</span>

        // Get sorted list of error types
        <span class="cov0" title="0">var errorTypes []string
        for errType := range byType </span><span class="cov0" title="0">{
                errorTypes = append(errorTypes, errType)
        }</span>
        <span class="cov0" title="0">sort.Strings(errorTypes)

        // Print the summary
        fmt.Println()
        HeadingColor.Printf("Error summary for %s:\n", f.FileName)
        for _, errType := range errorTypes </span><span class="cov0" title="0">{
                errors := byType[errType]
                fmt.Printf("  %s: %d errors\n", errType, len(errors))
        }</span>

        // Print auto-fix summary if any fixes were applied
        <span class="cov0" title="0">if f.FixCount &gt; 0 </span><span class="cov0" title="0">{
                SuccessColor.Printf("  Auto-fixed: %d issues\n", f.FixCount)
        }</span>

        <span class="cov0" title="0">fmt.Println()</span>
}

// PrintSuccess prints a success message
func PrintSuccess(message string) <span class="cov0" title="0">{
        SuccessColor.Println(message)
}</span>

// PrintLintSummary prints a summary of the linting process
func PrintLintSummary(fileCount, errorCount, fixCount int, duration time.Duration) <span class="cov0" title="0">{
        fmt.Println()
        HeadingColor.Println("Lint summary:")
        fmt.Printf("  Files:     %d\n", fileCount)
        fmt.Printf("  Errors:    %d\n", errorCount)
        if fixCount &gt; 0 </span><span class="cov0" title="0">{
                SuccessColor.Printf("  Auto-fixed: %d\n", fixCount)
        }</span>
        <span class="cov0" title="0">fmt.Printf("  Time:      %.2fs\n", duration.Seconds())
        fmt.Println()

        if errorCount == 0 </span><span class="cov0" title="0">{
                SuccessColor.Println(" All files passed validation!")
        }</span> else<span class="cov0" title="0"> {
                ErrorColor.Printf(" Found %d validation errors\n", errorCount)
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package util

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// IsDirectory checks if a path is a directory.
func IsDirectory(path string) bool <span class="cov0" title="0">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return info.IsDir()</span>
}

// FileExists checks if a file exists.
func FileExists(path string) bool <span class="cov0" title="0">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return !info.IsDir()</span>
}

// GetYAMLFilesInDirectory returns all YAML files (.yaml or .yml) in a directory.
func GetYAMLFilesInDirectory(dirPath string, recursive bool) ([]string, error) <span class="cov0" title="0">{
        var files []string

        if !IsDirectory(dirPath) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not a directory: %s", dirPath)
        }</span>

        <span class="cov0" title="0">walkFn := func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // If it's not a directory and has .yaml or .yml extension, add it to the list
                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        ext := strings.ToLower(filepath.Ext(path))
                        if ext == ".yaml" || ext == ".yml" </span><span class="cov0" title="0">{
                                files = append(files, path)
                        }</span>
                } else<span class="cov0" title="0"> if path != dirPath &amp;&amp; !recursive </span><span class="cov0" title="0">{
                        // Skip subdirectories if not recursive
                        return filepath.SkipDir
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">err := filepath.Walk(dirPath, walkFn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return files, nil</span>
}

// ExpandFilePaths expands file paths to include files in directories and glob patterns.
func ExpandFilePaths(paths []string, recursive bool) ([]string, error) <span class="cov0" title="0">{
        var expandedPaths []string

        for _, path := range paths </span><span class="cov0" title="0">{
                // Check if the path is a directory
                if IsDirectory(path) </span><span class="cov0" title="0">{
                        dirFiles, err := GetYAMLFilesInDirectory(path, recursive)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error getting YAML files from directory %s: %w", path, err)
                        }</span>
                        <span class="cov0" title="0">expandedPaths = append(expandedPaths, dirFiles...)
                        continue</span>
                }

                // Check if the path contains glob patterns
                <span class="cov0" title="0">if strings.ContainsAny(path, "*?[") </span><span class="cov0" title="0">{
                        matches, err := filepath.Glob(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error expanding glob pattern %s: %w", path, err)
                        }</span>

                        // Process each match
                        <span class="cov0" title="0">for _, match := range matches </span><span class="cov0" title="0">{
                                if IsDirectory(match) </span><span class="cov0" title="0">{
                                        // If the match is a directory, get YAML files from it
                                        dirFiles, err := GetYAMLFilesInDirectory(match, recursive)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("error getting YAML files from directory %s: %w", match, err)
                                        }</span>
                                        <span class="cov0" title="0">expandedPaths = append(expandedPaths, dirFiles...)</span>
                                } else<span class="cov0" title="0"> {
                                        // If the match is a file, add it directly
                                        expandedPaths = append(expandedPaths, match)
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Regular file path
                <span class="cov0" title="0">if FileExists(path) </span><span class="cov0" title="0">{
                        expandedPaths = append(expandedPaths, path)
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("file not found: %s", path)
                }</span>
        }

        <span class="cov0" title="0">return expandedPaths, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package log

import (
        "context"
        "fmt"
        "os"
        "runtime"
        "strings"
        "time"
)

// Implementation of the new Logger interface methods for BaseLogger

// Debug logs a message at the debug level with fields.
func (l *BaseLogger) Debug(msg string, fields ...Field) <span class="cov8" title="1">{
        if l.level &lt;= DebugLevel </span><span class="cov0" title="0">{
                l.logWithFields(DebugLevel, msg, fields)
        }</span>
}

// Info logs a message at the info level with fields.
func (l *BaseLogger) Info(msg string, fields ...Field) <span class="cov8" title="1">{
        if l.level &lt;= InfoLevel </span><span class="cov8" title="1">{
                l.logWithFields(InfoLevel, msg, fields)
        }</span>
}

// Warn logs a message at the warn level with fields.
func (l *BaseLogger) Warn(msg string, fields ...Field) <span class="cov8" title="1">{
        if l.level &lt;= WarnLevel </span><span class="cov8" title="1">{
                l.logWithFields(WarnLevel, msg, fields)
        }</span>
}

// Error logs a message at the error level with fields.
func (l *BaseLogger) Error(msg string, fields ...Field) <span class="cov8" title="1">{
        if l.level &lt;= ErrorLevel </span><span class="cov8" title="1">{
                l.logWithFields(ErrorLevel, msg, fields)
        }</span>
}

// Fatal logs a message at the fatal level with fields and then exits.
func (l *BaseLogger) Fatal(msg string, fields ...Field) <span class="cov0" title="0">{
        if l.level &lt;= FatalLevel </span><span class="cov0" title="0">{
                l.logWithFields(FatalLevel, msg, fields)
                os.Exit(1)
        }</span>
}

// Backward compatible methods with key-value pairs

// Debugf logs a message at the debug level with key-value args.
func (l *BaseLogger) Debugf(msg string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= DebugLevel </span><span class="cov0" title="0">{
                l.log(DebugLevel, msg, args...)
        }</span>
}

// Infof logs a message at the info level with key-value args.
func (l *BaseLogger) Infof(msg string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= InfoLevel </span><span class="cov0" title="0">{
                l.log(InfoLevel, msg, args...)
        }</span>
}

// Warnf logs a message at the warn level with key-value args.
func (l *BaseLogger) Warnf(msg string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= WarnLevel </span><span class="cov0" title="0">{
                l.log(WarnLevel, msg, args...)
        }</span>
}

// Errorf logs a message at the error level with key-value args.
func (l *BaseLogger) Errorf(msg string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= ErrorLevel </span><span class="cov0" title="0">{
                l.log(ErrorLevel, msg, args...)
        }</span>
}

// Fatalf logs a message at the fatal level with key-value args and then exits.
func (l *BaseLogger) Fatalf(msg string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= FatalLevel </span><span class="cov0" title="0">{
                l.log(FatalLevel, msg, args...)
                os.Exit(1)
        }</span>
}

// WithField returns a new logger with the field added to it.
func (l *BaseLogger) WithField(key string, value interface{}) Logger <span class="cov8" title="1">{
        return l.WithFields(Fields{key: value})
}</span>

// WithFields returns a new logger with the fields added to it.
func (l *BaseLogger) WithFields(fields Fields) Logger <span class="cov8" title="1">{
        newLogger := &amp;BaseLogger{
                level:     l.level,
                formatter: l.formatter,
                outputs:   l.outputs,
                hooks:     l.hooks,
                fields:    Fields{},
        }

        // Copy existing fields
        for k, v := range l.fields </span><span class="cov8" title="1">{
                newLogger.fields[k] = v
        }</span>

        // Add new fields
        <span class="cov8" title="1">for k, v := range fields </span><span class="cov8" title="1">{
                newLogger.fields[k] = v
        }</span>

        <span class="cov8" title="1">return newLogger</span>
}

// With adds fields to the logger (new Field-based API)
func (l *BaseLogger) With(fields ...Field) Logger <span class="cov0" title="0">{
        if len(fields) == 0 </span><span class="cov0" title="0">{
                return l
        }</span>

        <span class="cov0" title="0">newLogger := &amp;BaseLogger{
                level:     l.level,
                formatter: l.formatter,
                outputs:   l.outputs,
                hooks:     l.hooks,
                fields:    Fields{},
        }

        // Copy existing fields
        for k, v := range l.fields </span><span class="cov0" title="0">{
                newLogger.fields[k] = v
        }</span>

        // Add new fields
        <span class="cov0" title="0">for _, field := range fields </span><span class="cov0" title="0">{
                newLogger.fields[field.Key] = field.Value
        }</span>

        <span class="cov0" title="0">return newLogger</span>
}

// WithError returns a new logger with the error added as a field.
func (l *BaseLogger) WithError(err error) Logger <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return l
        }</span>
        <span class="cov0" title="0">return l.WithField("error", err.Error())</span>
}

// WithContext returns a new logger with fields from the context.
func (l *BaseLogger) WithContext(ctx context.Context) Logger <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return l
        }</span>

        <span class="cov0" title="0">fields := ContextExtractor(ctx)
        if len(fields) == 0 </span><span class="cov0" title="0">{
                return l
        }</span>

        <span class="cov0" title="0">return l.WithFields(fields)</span>
}

// WithComponent returns a new logger with the component field added.
func (l *BaseLogger) WithComponent(component string) Logger <span class="cov8" title="1">{
        return l.WithField(ComponentKey, component)
}</span>

// SetLevel sets the minimum log level.
func (l *BaseLogger) SetLevel(level Level) <span class="cov0" title="0">{
        l.level = level
}</span>

// GetLevel returns the current minimum log level.
func (l *BaseLogger) GetLevel() Level <span class="cov0" title="0">{
        return l.level
}</span>

// Outputs returns the configured log outputs.
func (l *BaseLogger) Outputs() []Output <span class="cov0" title="0">{
        return l.outputs
}</span>

// log creates a log entry from key-value pairs and writes it to all outputs.
func (l *BaseLogger) log(level Level, msg string, args ...interface{}) <span class="cov0" title="0">{
        // Create fields from args (key-value pairs)
        fields := Fields{}
        for i := 0; i &lt; len(args); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(args) </span><span class="cov0" title="0">{
                        key, ok := args[i].(string)
                        if !ok </span><span class="cov0" title="0">{
                                key = fmt.Sprintf("arg%d", i)
                        }</span>
                        <span class="cov0" title="0">fields[key] = args[i+1]</span>
                } else<span class="cov0" title="0"> {
                        fields[fmt.Sprintf("arg%d", i)] = args[i]
                }</span>
        }

        // Merge base fields with entry fields
        <span class="cov0" title="0">entryFields := Fields{}
        for k, v := range l.fields </span><span class="cov0" title="0">{
                entryFields[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range fields </span><span class="cov0" title="0">{
                entryFields[k] = v
        }</span>

        // Create and write the entry
        <span class="cov0" title="0">l.writeEntry(level, msg, entryFields, nil)</span>
}

// logWithFields creates a log entry from Field structs and writes it to all outputs.
func (l *BaseLogger) logWithFields(level Level, msg string, fields []Field) <span class="cov8" title="1">{
        // Convert Field structs to a Fields map
        entryFields := Fields{}

        // Start with logger's fields
        for k, v := range l.fields </span><span class="cov8" title="1">{
                entryFields[k] = v
        }</span>

        // Add the fields for this log call
        <span class="cov8" title="1">for _, field := range fields </span><span class="cov8" title="1">{
                entryFields[field.Key] = field.Value
        }</span>

        // Create and write the entry
        <span class="cov8" title="1">l.writeEntry(level, msg, entryFields, nil)</span>
}

// writeEntry creates and writes a log entry with the given fields
func (l *BaseLogger) writeEntry(level Level, msg string, fields Fields, err error) <span class="cov8" title="1">{
        // Get caller info
        _, file, line, ok := runtime.Caller(3) // Adjusted to account for the new method layers
        caller := "unknown"
        if ok </span><span class="cov8" title="1">{
                parts := strings.Split(file, "/")
                if len(parts) &gt; 2 </span><span class="cov8" title="1">{
                        caller = fmt.Sprintf("%s:%d", strings.Join(parts[len(parts)-2:], "/"), line)
                }</span> else<span class="cov0" title="0"> {
                        caller = fmt.Sprintf("%s:%d", file, line)
                }</span>
        }

        // Create entry
        <span class="cov8" title="1">entry := &amp;Entry{
                Level:     level,
                Message:   msg,
                Fields:    fields,
                Timestamp: time.Now(),
                Caller:    caller,
                Error:     err,
        }

        // Fire hooks
        for _, hook := range l.hooks </span><span class="cov0" title="0">{
                for _, hookLevel := range hook.Levels() </span><span class="cov0" title="0">{
                        if hookLevel == level </span><span class="cov0" title="0">{
                                if err := hook.Fire(entry); err != nil </span><span class="cov0" title="0">{
                                        // If a hook fails, don't stop processing but log the error
                                        fmt.Fprintf(os.Stderr, "Error firing hook: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        // Format entry
        <span class="cov8" title="1">formattedEntry, err := l.formatter.Format(entry)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error formatting log entry: %v\n", err)
                return
        }</span>

        // Write to all outputs
        <span class="cov8" title="1">for _, output := range l.outputs </span><span class="cov8" title="1">{
                if err := output.Write(entry, formattedEntry); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error writing to log output: %v\n", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package log

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// Config defines logging configuration.
type Config struct {
        // Level sets the minimum log level
        Level string `json:"level" yaml:"level"`

        // Format sets the output format (json, text)
        Format string `json:"format" yaml:"format"`

        // Outputs defines where logs should be written
        Outputs []OutputConfig `json:"outputs" yaml:"outputs"`

        // Sampling defines sampling behavior for high-volume logs
        Sampling *SamplingConfig `json:"sampling" yaml:"sampling"`

        // EnableCaller enables adding caller information to logs
        EnableCaller bool `json:"enable_caller" yaml:"enable_caller"`

        // RedactedFields lists fields that should be redacted (e.g. passwords)
        RedactedFields []string `json:"redacted_fields" yaml:"redacted_fields"`
}

// OutputConfig defines a single log output.
type OutputConfig struct {
        // Type is the output type (console, file, syslog, remote)
        Type string `json:"type" yaml:"type"`

        // Options are type-specific configuration options
        Options map[string]interface{} `json:"options" yaml:"options"`
}

// SamplingConfig defines sampling behavior for high-volume logs.
type SamplingConfig struct {
        // Initial is the initial number of entries to process without sampling
        Initial int `json:"initial" yaml:"initial"`

        // Thereafter is how often to sample after the initial entries
        Thereafter int `json:"thereafter" yaml:"thereafter"`
}

// DefaultConfig returns a default configuration.
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Level:  "info",
                Format: "text",
                Outputs: []OutputConfig{
                        {
                                Type: "console",
                                Options: map[string]interface{}{
                                        "error_to_stderr": true,
                                },
                        },
                },
                Sampling:     nil, // No sampling by default
                EnableCaller: false,
        }
}</span>

// ApplyConfig creates a logger from a configuration.
func ApplyConfig(config *Config) (Logger, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>

        // Parse log level
        <span class="cov0" title="0">level, err := ParseLevel(config.Level)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create options
        <span class="cov0" title="0">options := []LoggerOption{
                WithLevel(level),
        }

        // Add formatter
        switch strings.ToLower(config.Format) </span>{
        case "json":<span class="cov0" title="0">
                options = append(options, WithFormatter(&amp;JSONFormatter{
                        EnableCaller: config.EnableCaller,
                }))</span>
        case "text", "":<span class="cov0" title="0">
                options = append(options, WithFormatter(&amp;TextFormatter{
                        EnableCaller:   config.EnableCaller,
                        ShortTimestamp: false,
                }))</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid log format: %s", config.Format)</span>
        }

        // Create the logger
        <span class="cov0" title="0">logger := NewLogger(options...)

        // Configure outputs
        if len(config.Outputs) == 0 </span><span class="cov0" title="0">{
                // Add default console output if none specified
                output := NewConsoleOutput(WithErrorToStderr())
                logger.(*BaseLogger).outputs = append(logger.(*BaseLogger).outputs, output)
        }</span> else<span class="cov0" title="0"> {
                // Clear default outputs
                logger.(*BaseLogger).outputs = nil

                // Add configured outputs
                for _, outputConfig := range config.Outputs </span><span class="cov0" title="0">{
                        output, err := createOutput(outputConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">logger.(*BaseLogger).outputs = append(logger.(*BaseLogger).outputs, output)</span>
                }
        }

        // Add redaction hook if needed
        <span class="cov0" title="0">if len(config.RedactedFields) &gt; 0 </span><span class="cov0" title="0">{
                logger.(*BaseLogger).hooks = append(logger.(*BaseLogger).hooks, NewRedactionHook(config.RedactedFields))
        }</span>

        // Add sampling hook if configured
        <span class="cov0" title="0">if config.Sampling != nil &amp;&amp; config.Sampling.Thereafter &gt; 0 </span><span class="cov0" title="0">{
                logger.(*BaseLogger).hooks = append(
                        logger.(*BaseLogger).hooks,
                        NewSamplingHook(config.Sampling.Initial, config.Sampling.Thereafter),
                )
        }</span>

        <span class="cov0" title="0">return logger, nil</span>
}

// createOutput creates an output from a configuration.
func createOutput(config OutputConfig) (Output, error) <span class="cov0" title="0">{
        switch strings.ToLower(config.Type) </span>{
        case "console":<span class="cov0" title="0">
                options := []ConsoleOutputOption{}

                // Parse options
                if v, ok := config.Options["stderr"].(bool); ok &amp;&amp; v </span><span class="cov0" title="0">{
                        options = append(options, WithStderr())
                }</span>
                <span class="cov0" title="0">if v, ok := config.Options["error_to_stderr"].(bool); ok &amp;&amp; v </span><span class="cov0" title="0">{
                        options = append(options, WithErrorToStderr())
                }</span>

                <span class="cov0" title="0">return NewConsoleOutput(options...), nil</span>

        case "file":<span class="cov0" title="0">
                // Get filename
                filename, ok := config.Options["filename"].(string)
                if !ok || filename == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("file output requires a filename")
                }</span>

                // Expand variables and paths
                <span class="cov0" title="0">filename = os.ExpandEnv(filename)
                if !filepath.IsAbs(filename) </span><span class="cov0" title="0">{
                        wd, err := os.Getwd()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">filename = filepath.Join(wd, filename)</span>
                }

                <span class="cov0" title="0">options := []FileOutputOption{}

                // Parse max size
                if v, ok := config.Options["max_size"].(string); ok </span><span class="cov0" title="0">{
                        size, err := parseSize(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">options = append(options, WithMaxSize(size))</span>
                }

                // Parse max age
                <span class="cov0" title="0">if v, ok := config.Options["max_age"].(string); ok </span><span class="cov0" title="0">{
                        duration, err := time.ParseDuration(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">options = append(options, WithMaxAge(duration))</span>
                }

                // Parse max backups
                <span class="cov0" title="0">if v, ok := config.Options["max_backups"].(int); ok </span><span class="cov0" title="0">{
                        options = append(options, WithMaxBackups(v))
                }</span>

                <span class="cov0" title="0">return NewFileOutput(filename, options...), nil</span>

        case "null":<span class="cov0" title="0">
                return NewNullOutput(), nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown output type: %s", config.Type)</span>
        }
}

// ParseLevel parses a level string into a Level.
func ParseLevel(level string) (Level, error) <span class="cov0" title="0">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov0" title="0">
                return DebugLevel, nil</span>
        case "info":<span class="cov0" title="0">
                return InfoLevel, nil</span>
        case "warn", "warning":<span class="cov0" title="0">
                return WarnLevel, nil</span>
        case "error":<span class="cov0" title="0">
                return ErrorLevel, nil</span>
        case "fatal":<span class="cov0" title="0">
                return FatalLevel, nil</span>
        default:<span class="cov0" title="0">
                return InfoLevel, fmt.Errorf("unknown log level: %s", level)</span>
        }
}

// parseSize parses a size string (e.g., "10MB") into bytes.
func parseSize(size string) (int64, error) <span class="cov0" title="0">{
        size = strings.TrimSpace(size)
        if size == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Try to parse as a simple number
        <span class="cov0" title="0">var bytes int64
        if _, err := fmt.Sscanf(size, "%d", &amp;bytes); err == nil </span><span class="cov0" title="0">{
                return bytes, nil
        }</span>

        // Try to parse with units
        <span class="cov0" title="0">var value float64
        var unit string
        if _, err := fmt.Sscanf(size, "%f%s", &amp;value, &amp;unit); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid size format: %s", size)
        }</span>

        <span class="cov0" title="0">unit = strings.ToUpper(unit)
        switch unit </span>{
        case "B":<span class="cov0" title="0">
                return int64(value), nil</span>
        case "KB", "K":<span class="cov0" title="0">
                return int64(value * 1024), nil</span>
        case "MB", "M":<span class="cov0" title="0">
                return int64(value * 1024 * 1024), nil</span>
        case "GB", "G":<span class="cov0" title="0">
                return int64(value * 1024 * 1024 * 1024), nil</span>
        case "TB", "T":<span class="cov0" title="0">
                return int64(value * 1024 * 1024 * 1024 * 1024), nil</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unknown size unit: %s", unit)</span>
        }
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package log

import (
        "encoding/json"
        "time"
)

// Field represents a structured log field with a key and value
type Field struct {
        Key   string
        Value interface{}
}

// F creates a log field with the provided key and value
func F(key string, value interface{}) Field <span class="cov0" title="0">{
        return Field{
                Key:   key,
                Value: value,
        }
}</span>

// Err creates an error field
func Err(err error) Field <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return Field{Key: "error", Value: nil}
        }</span>
        <span class="cov8" title="1">return Field{
                Key:   "error",
                Value: err.Error(),
        }</span>
}

// Int creates an integer field
func Int(key string, value int) Field <span class="cov8" title="1">{
        return Field{
                Key:   key,
                Value: value,
        }
}</span>

// Str creates a string field
func Str(key, value string) Field <span class="cov8" title="1">{
        return Field{
                Key:   key,
                Value: value,
        }
}</span>

// Bool creates a boolean field
func Bool(key string, value bool) Field <span class="cov0" title="0">{
        return Field{
                Key:   key,
                Value: value,
        }
}</span>

// Int64 creates an int64 field
func Int64(key string, value int64) Field <span class="cov0" title="0">{
        return Field{
                Key:   key,
                Value: value,
        }
}</span>

// Float64 creates a float64 field
func Float64(key string, value float64) Field <span class="cov0" title="0">{
        return Field{
                Key:   key,
                Value: value,
        }
}</span>

// Time creates a time field
func Time(key string, value time.Time) Field <span class="cov0" title="0">{
        return Field{
                Key:   key,
                Value: value,
        }
}</span>

// Duration creates a duration field
func Duration(key string, value time.Duration) Field <span class="cov8" title="1">{
        return Field{
                Key:   key,
                Value: value,
        }
}</span>

// Any creates a field for any value (alias for F)
func Any(key string, value interface{}) Field <span class="cov0" title="0">{
        return Field{
                Key:   key,
                Value: value,
        }
}</span>

// JSON creates a field for a JSON-serializable value
func Json(key string, value interface{}) Field <span class="cov8" title="1">{
        // Marshal the value to JSON
        jsonBytes, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return Field{Key: key, Value: err.Error()}
        }</span>

        <span class="cov8" title="1">return Field{
                Key:   key,
                Value: string(jsonBytes),
        }</span>
}

// Component creates a component field, useful for tagging logs with a component name
func Component(value string) Field <span class="cov0" title="0">{
        return Field{
                Key:   ComponentKey,
                Value: value,
        }
}</span>

// RequestID creates a request ID field
func RequestID(value string) Field <span class="cov0" title="0">{
        return Field{
                Key:   RequestIDKey,
                Value: value,
        }
}</span>

// TraceID creates a trace ID field
func TraceID(value string) Field <span class="cov0" title="0">{
        return Field{
                Key:   TraceIDKey,
                Value: value,
        }
}</span>

// SpanID creates a span ID field
func SpanID(value string) Field <span class="cov0" title="0">{
        return Field{
                Key:   SpanIDKey,
                Value: value,
        }
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package log

import (
        "encoding/json"
        "fmt"
        "strings"
        "time"
)

// JSONFormatter formats log entries as JSON.
type JSONFormatter struct {
        TimestampFormat string // Format for timestamps
        EnableCaller    bool   // Enable caller information (default: false)
}

// Format formats the entry as JSON.
func (f *JSONFormatter) Format(entry *Entry) ([]byte, error) <span class="cov8" title="1">{
        data := make(map[string]interface{})

        // Add timestamp
        timestampFormat := time.RFC3339
        if f.TimestampFormat != "" </span><span class="cov0" title="0">{
                timestampFormat = f.TimestampFormat
        }</span>
        <span class="cov8" title="1">data["timestamp"] = entry.Timestamp.Format(timestampFormat)

        // Add level
        data["level"] = entry.Level.String()

        // Add message
        data["message"] = entry.Message

        // Add caller if enabled
        if f.EnableCaller &amp;&amp; entry.Caller != "" </span><span class="cov0" title="0">{
                data["caller"] = entry.Caller
        }</span>

        // Add fields
        <span class="cov8" title="1">for k, v := range entry.Fields </span><span class="cov8" title="1">{
                // Don't overwrite standard fields
                if k != "timestamp" &amp;&amp; k != "level" &amp;&amp; k != "message" &amp;&amp; k != "caller" </span><span class="cov8" title="1">{
                        data[k] = v
                }</span>
        }

        // Marshal to JSON
        <span class="cov8" title="1">return json.Marshal(data)</span>
}

// TextFormatter formats log entries as human-readable text.
type TextFormatter struct {
        TimestampFormat  string // Format for timestamps
        EnableCaller     bool   // Enable caller information (default: false)
        DisableColors    bool   // Disable color output
        ShortTimestamp   bool   // Use short timestamp without date (default: false)
        DisableTimestamp bool   // Disable timestamp output
}

// NewTextFormatter creates a new TextFormatter with sensible defaults.
func NewTextFormatter() *TextFormatter <span class="cov0" title="0">{
        return &amp;TextFormatter{
                TimestampFormat: "15:04:05.000",
                EnableCaller:    false, // Don't show caller by default
                DisableColors:   false, // Enable colors by default
                ShortTimestamp:  false, // Use full timestamp by default (with date)
        }
}</span>

// Format formats the entry as text.
func (f *TextFormatter) Format(entry *Entry) ([]byte, error) <span class="cov8" title="1">{
        // Determine timestamp format
        timestampFormat := "2006-01-02T15:04:05.000" // Default to full timestamp
        if f.ShortTimestamp </span><span class="cov0" title="0">{
                timestampFormat = "15:04:05.000" // Short timestamp if explicitly requested
        }</span>
        <span class="cov8" title="1">if f.TimestampFormat != "" </span><span class="cov0" title="0">{
                timestampFormat = f.TimestampFormat // Override with custom format if specified
        }</span>

        // Format timestamp
        <span class="cov8" title="1">timestamp := entry.Timestamp.Format(timestampFormat)

        // Format level with color
        level := entry.Level.String()
        if !f.DisableColors </span><span class="cov0" title="0">{
                level = colorizeLevel(entry.Level)
        }</span>

        // Format caller (only if explicitly enabled)
        <span class="cov8" title="1">caller := ""
        if f.EnableCaller &amp;&amp; entry.Caller != "" </span><span class="cov0" title="0">{
                if !f.DisableColors </span><span class="cov0" title="0">{
                        caller = fmt.Sprintf(" (%s%s%s)", colorDim, entry.Caller, colorReset)
                }</span> else<span class="cov0" title="0"> {
                        caller = fmt.Sprintf(" (%s)", entry.Caller)
                }</span>
        }

        // Extract fields
        <span class="cov8" title="1">var fieldParts []string
        for k, v := range entry.Fields </span><span class="cov8" title="1">{
                if !f.DisableColors </span><span class="cov0" title="0">{
                        // Use light blue color for field keys
                        fieldParts = append(fieldParts, fmt.Sprintf("%s%s%s=%v", colorCyan, k, colorReset, v))
                }</span> else<span class="cov8" title="1"> {
                        fieldParts = append(fieldParts, fmt.Sprintf("%s=%v", k, v))
                }</span>
        }

        <span class="cov8" title="1">fields := ""
        if len(fieldParts) &gt; 0 </span><span class="cov8" title="1">{
                fields = " " + strings.Join(fieldParts, " ")
        }</span>

        // Format message with color (just use the default color)
        <span class="cov8" title="1">message := entry.Message

        // Add color to timestamp if enabled
        if !f.DisableColors </span><span class="cov0" title="0">{
                timestamp = colorDim + timestamp + colorReset
        }</span>

        // Put together final log line
        <span class="cov8" title="1">logLine := fmt.Sprintf("%s %s%s %s%s\n",
                timestamp,
                level,
                caller,
                message,
                fields)

        return []byte(logLine), nil</span>
}

// Color codes for terminal output
const (
        colorReset  = "\033[0m"
        colorRed    = "\033[31m"
        colorGreen  = "\033[32m"
        colorYellow = "\033[33m"
        colorBlue   = "\033[34m"
        colorCyan   = "\033[36m" // Light blue/cyan for field keys
        colorDim    = "\033[90m" // Dim/gray color for timestamps, caller
)

// colorizeLevel adds color to log levels
func colorizeLevel(level Level) string <span class="cov0" title="0">{
        switch level </span>{
        case DebugLevel:<span class="cov0" title="0">
                return colorBlue + "DBG" + colorReset</span>
        case InfoLevel:<span class="cov0" title="0">
                return colorGreen + "INF" + colorReset</span>
        case WarnLevel:<span class="cov0" title="0">
                return colorYellow + "WRN" + colorReset</span>
        case ErrorLevel:<span class="cov0" title="0">
                return colorRed + "ERR" + colorReset</span>
        case FatalLevel:<span class="cov0" title="0">
                return colorRed + "FTL" + colorReset</span>
        default:<span class="cov0" title="0">
                return level.String() + colorReset</span>
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package log

import (
        "strings"
        "sync"
)

// RedactionHook redacts sensitive values from log entries.
type RedactionHook struct {
        fields []string
}

// Levels returns the levels this hook should be called for.
func (h *RedactionHook) Levels() []Level <span class="cov0" title="0">{
        return []Level{DebugLevel, InfoLevel, WarnLevel, ErrorLevel, FatalLevel}
}</span>

// Fire executes the hook's logic for a log entry.
func (h *RedactionHook) Fire(entry *Entry) error <span class="cov0" title="0">{
        // Iterate through fields that should be redacted
        for _, field := range h.fields </span><span class="cov0" title="0">{
                // Check if the field exists in the entry
                if value, ok := entry.Fields[field]; ok </span><span class="cov0" title="0">{
                        // Redact the value based on its type
                        switch value.(type) </span>{
                        case string:<span class="cov0" title="0">
                                entry.Fields[field] = "[REDACTED]"</span>
                        default:<span class="cov0" title="0">
                                entry.Fields[field] = "[REDACTED]"</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// NewRedactionHook creates a new redaction hook.
func NewRedactionHook(fields []string) *RedactionHook <span class="cov0" title="0">{
        return &amp;RedactionHook{
                fields: fields,
        }
}</span>

// SamplingHook implements sampling for high-volume logs.
type SamplingHook struct {
        mu         sync.Mutex
        counters   map[string]uint64
        initial    uint64
        thereafter uint64
}

// Levels returns the levels this hook should be called for.
func (h *SamplingHook) Levels() []Level <span class="cov0" title="0">{
        return []Level{DebugLevel, InfoLevel, WarnLevel, ErrorLevel, FatalLevel}
}</span>

// Fire executes the hook's logic for a log entry.
func (h *SamplingHook) Fire(entry *Entry) error <span class="cov0" title="0">{
        // Create a key based on level and message to track similar entries
        key := strings.Join([]string{entry.Level.String(), entry.Message}, ":")

        h.mu.Lock()
        counter, ok := h.counters[key]
        if !ok </span><span class="cov0" title="0">{
                counter = 0
                h.counters[key] = 0
        }</span>

        // Check if the entry should be sampled out
        <span class="cov0" title="0">sample := counter &lt; h.initial || (counter-h.initial)%h.thereafter == 0

        // Update counter
        h.counters[key]++
        h.mu.Unlock()

        if !sample </span><span class="cov0" title="0">{
                // Add a field to indicate sampling if not already present
                if _, ok := entry.Fields["_sampled"]; !ok </span><span class="cov0" title="0">{
                        entry.Fields["_sampled"] = true
                }</span>

                // Signal that this entry should be dropped
                <span class="cov0" title="0">return ErrEntrySampled</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// NewSamplingHook creates a new sampling hook.
func NewSamplingHook(initial, thereafter int) *SamplingHook <span class="cov0" title="0">{
        if initial &lt; 0 </span><span class="cov0" title="0">{
                initial = 0
        }</span>
        <span class="cov0" title="0">if thereafter &lt;= 0 </span><span class="cov0" title="0">{
                thereafter = 1
        }</span>

        <span class="cov0" title="0">return &amp;SamplingHook{
                counters:   make(map[string]uint64),
                initial:    uint64(initial),
                thereafter: uint64(thereafter),
        }</span>
}

// ErrEntrySampled is returned when an entry is sampled out.
var ErrEntrySampled = &amp;entrySampledError{}

type entrySampledError struct{}

func (e *entrySampledError) Error() string <span class="cov0" title="0">{
        return "entry sampled"
}</span>

// OTELHook integrates with OpenTelemetry to add trace information to logs.
type OTELHook struct{}

// Levels returns the levels this hook should be called for.
func (h *OTELHook) Levels() []Level <span class="cov0" title="0">{
        return []Level{DebugLevel, InfoLevel, WarnLevel, ErrorLevel, FatalLevel}
}</span>

// Fire executes the hook's logic for a log entry.
func (h *OTELHook) Fire(entry *Entry) error <span class="cov0" title="0">{
        // This is a placeholder for OTEL integration
        // When implemented, it would extract trace/span IDs from context
        // and add them to the log entry

        // For now, do nothing
        return nil
}</span>

// NewOTELHook creates a new OpenTelemetry hook.
func NewOTELHook() *OTELHook <span class="cov0" title="0">{
        return &amp;OTELHook{}
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">// Package log provides a structured logging system for Rune services.
package log

import (
        "context"
        "time"
)

// Level represents the severity level of a log message.
type Level int

// Log levels
const (
        DebugLevel Level = iota
        InfoLevel
        WarnLevel
        ErrorLevel
        FatalLevel
)

// String returns the string representation of the log level.
func (l Level) String() string <span class="cov8" title="1">{
        switch l </span>{
        case DebugLevel:<span class="cov0" title="0">
                return "DEBUG"</span>
        case InfoLevel:<span class="cov8" title="1">
                return "INFO"</span>
        case WarnLevel:<span class="cov8" title="1">
                return "WARN"</span>
        case ErrorLevel:<span class="cov8" title="1">
                return "ERROR"</span>
        case FatalLevel:<span class="cov0" title="0">
                return "FATAL"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// Fields is a map of field names to values.
type Fields map[string]interface{}

// Context keys for propagating logging context
const (
        RequestIDKey = "request_id"
        TraceIDKey   = "trace_id"
        SpanIDKey    = "span_id"
        ComponentKey = "component"
        OperationKey = "operation"
)

// Entry represents a single log entry.
type Entry struct {
        Level     Level
        Message   string
        Fields    Fields
        Timestamp time.Time
        Caller    string
        Error     error
}

// Logger defines the core logging interface for Rune components.
type Logger interface {
        // Standard logging methods with structured context (Field-based API)
        Debug(msg string, fields ...Field)
        Info(msg string, fields ...Field)
        Warn(msg string, fields ...Field)
        Error(msg string, fields ...Field)
        Fatal(msg string, fields ...Field)

        // Standard logging methods with key-value pairs (for backward compatibility)
        Debugf(msg string, args ...interface{})
        Infof(msg string, args ...interface{})
        Warnf(msg string, args ...interface{})
        Errorf(msg string, args ...interface{})
        Fatalf(msg string, args ...interface{})

        // Field creation methods (for backward compatibility)
        WithField(key string, value interface{}) Logger
        WithFields(fields Fields) Logger
        WithError(err error) Logger

        // With adds multiple fields to the logger (for new Field-based API)
        With(fields ...Field) Logger

        // WithContext adds request context to the Logger
        WithContext(ctx context.Context) Logger

        // WithComponent tags logs with a component name
        WithComponent(component string) Logger

        // SetLevel sets the minimum log level
        SetLevel(level Level)

        // GetLevel returns the current minimum log level
        GetLevel() Level
}

// Formatter defines the interface for formatting log entries.
type Formatter interface {
        Format(entry *Entry) ([]byte, error)
}

// Output defines the interface for log outputs.
type Output interface {
        Write(entry *Entry, formattedEntry []byte) error
        Close() error
}

// LoggerOption is a function that configures a logger.
type LoggerOption func(*BaseLogger)

// BaseLogger implements the Logger interface.
type BaseLogger struct {
        level     Level
        fields    Fields
        formatter Formatter
        outputs   []Output
        hooks     []Hook
}

// Hook is a function that is called during logging.
type Hook interface {
        Levels() []Level
        Fire(entry *Entry) error
}

// ContextExtractor extracts logging context from a context.Context.
func ContextExtractor(ctx context.Context) Fields <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return Fields{}
        }</span>

        <span class="cov0" title="0">fields := Fields{}

        // Extract standard context values
        if v := ctx.Value(RequestIDKey); v != nil </span><span class="cov0" title="0">{
                fields[RequestIDKey] = v
        }</span>
        <span class="cov0" title="0">if v := ctx.Value(TraceIDKey); v != nil </span><span class="cov0" title="0">{
                fields[TraceIDKey] = v
        }</span>
        <span class="cov0" title="0">if v := ctx.Value(SpanIDKey); v != nil </span><span class="cov0" title="0">{
                fields[SpanIDKey] = v
        }</span>
        <span class="cov0" title="0">if v := ctx.Value(ComponentKey); v != nil </span><span class="cov0" title="0">{
                fields[ComponentKey] = v
        }</span>
        <span class="cov0" title="0">if v := ctx.Value(OperationKey); v != nil </span><span class="cov0" title="0">{
                fields[OperationKey] = v
        }</span>

        <span class="cov0" title="0">return fields</span>
}

// ContextInjector injects logging fields into a context.Context.
func ContextInjector(ctx context.Context, fields Fields) context.Context <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">for k, v := range fields </span><span class="cov0" title="0">{
                ctx = context.WithValue(ctx, k, v)
        }</span>

        <span class="cov0" title="0">return ctx</span>
}

// FromContext extracts a logger from a context.Context.
// If no logger is found, it returns the default logger.
func FromContext(ctx context.Context) Logger <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return defaultLogger
        }</span>

        <span class="cov0" title="0">if logger, ok := ctx.Value(loggerKey).(Logger); ok </span><span class="cov0" title="0">{
                return logger
        }</span>

        // Extract context fields and add them to the default logger
        <span class="cov0" title="0">fields := ContextExtractor(ctx)
        if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                return defaultLogger.WithFields(fields)
        }</span>

        <span class="cov0" title="0">return defaultLogger</span>
}

// loggerKey is the context key for the logger.
type loggerKeyType struct{}

var loggerKey = loggerKeyType{}

// WithLogger adds a logger to a context.Context.
func WithLogger(ctx context.Context, logger Logger) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, loggerKey, logger)
}</span>

// Global default logger
var defaultLogger Logger

// Initialize the default logger
func init() <span class="cov8" title="1">{
        // Create a default logger that outputs to stderr with INFO level
        defaultLogger = NewLogger(WithLevel(InfoLevel))
}</span>

// SetDefaultLogger sets the global default logger.
func SetDefaultLogger(logger Logger) <span class="cov0" title="0">{
        defaultLogger = logger
}</span>

// GetDefaultLogger returns the global default logger.
func GetDefaultLogger() Logger <span class="cov8" title="1">{
        return defaultLogger
}</span>

// Standard global logging methods with fields
func Debug(msg string, fields ...Field) <span class="cov0" title="0">{
        defaultLogger.Debug(msg, fields...)
}</span>

func Info(msg string, fields ...Field) <span class="cov0" title="0">{
        defaultLogger.Info(msg, fields...)
}</span>

func Warn(msg string, fields ...Field) <span class="cov0" title="0">{
        defaultLogger.Warn(msg, fields...)
}</span>

func Error(msg string, fields ...Field) <span class="cov0" title="0">{
        defaultLogger.Error(msg, fields...)
}</span>

func Fatal(msg string, fields ...Field) <span class="cov0" title="0">{
        defaultLogger.Fatal(msg, fields...)
}</span>

// Standard global logging methods with key-value pairs (for backward compatibility)
func Debugf(msg string, args ...interface{}) <span class="cov0" title="0">{
        defaultLogger.Debugf(msg, args...)
}</span>

func Infof(msg string, args ...interface{}) <span class="cov0" title="0">{
        defaultLogger.Infof(msg, args...)
}</span>

func Warnf(msg string, args ...interface{}) <span class="cov0" title="0">{
        defaultLogger.Warnf(msg, args...)
}</span>

func Errorf(msg string, args ...interface{}) <span class="cov0" title="0">{
        defaultLogger.Errorf(msg, args...)
}</span>

func Fatalf(msg string, args ...interface{}) <span class="cov0" title="0">{
        defaultLogger.Fatalf(msg, args...)
}</span>

// With adds fields to the logger (for new Field-based API)
func With(fields ...Field) Logger <span class="cov0" title="0">{
        return defaultLogger.With(fields...)
}</span>

// For backward compatibility
func WithField(key string, value interface{}) Logger <span class="cov0" title="0">{
        return defaultLogger.WithField(key, value)
}</span>

func WithFields(fields Fields) Logger <span class="cov0" title="0">{
        return defaultLogger.WithFields(fields)
}</span>

func WithError(err error) Logger <span class="cov0" title="0">{
        return defaultLogger.WithError(err)
}</span>

func WithContext(ctx context.Context) Logger <span class="cov0" title="0">{
        return defaultLogger.WithContext(ctx)
}</span>

func WithComponent(component string) Logger <span class="cov0" title="0">{
        return defaultLogger.WithComponent(component)
}</span>

// NewLogger creates a new logger with the given options.
func NewLogger(options ...LoggerOption) Logger <span class="cov8" title="1">{
        logger := &amp;BaseLogger{
                level:     InfoLevel,
                fields:    Fields{},
                formatter: &amp;JSONFormatter{},
                outputs:   []Output{},
                hooks:     []Hook{},
        }

        // Apply options
        for _, option := range options </span><span class="cov8" title="1">{
                option(logger)
        }</span>

        // Add default output if none specified
        <span class="cov8" title="1">if len(logger.outputs) == 0 </span><span class="cov8" title="1">{
                logger.outputs = append(logger.outputs, &amp;ConsoleOutput{})
        }</span>

        <span class="cov8" title="1">return logger</span>
}

// WithLevel sets the minimum log level.
func WithLevel(level Level) LoggerOption <span class="cov8" title="1">{
        return func(l *BaseLogger) </span><span class="cov8" title="1">{
                l.level = level
        }</span>
}

// WithFormatter sets the log formatter.
func WithFormatter(formatter Formatter) LoggerOption <span class="cov8" title="1">{
        return func(l *BaseLogger) </span><span class="cov8" title="1">{
                l.formatter = formatter
        }</span>
}

// WithOutput adds an output to the logger.
func WithOutput(output Output) LoggerOption <span class="cov0" title="0">{
        return func(l *BaseLogger) </span><span class="cov0" title="0">{
                l.outputs = append(l.outputs, output)
        }</span>
}

// WithHook adds a hook to the logger.
func WithHook(hook Hook) LoggerOption <span class="cov0" title="0">{
        return func(l *BaseLogger) </span><span class="cov0" title="0">{
                l.hooks = append(l.hooks, hook)
        }</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package log

import (
        "context"
        "fmt"
        "strings"
        "sync"
)

// TestEntry represents a captured log entry for testing
type TestEntry struct {
        Level   Level
        Message string
        Fields  []Field
}

// TestLogger is a Logger implementation for testing that captures logs
// without producing output and provides methods to verify logging behavior.
type TestLogger struct {
        mu      sync.Mutex
        entries []TestEntry
        fields  []Field
        level   Level
}

// NewTestLogger creates a new TestLogger for use in unit tests
func NewTestLogger() *TestLogger <span class="cov0" title="0">{
        return &amp;TestLogger{
                level: InfoLevel,
        }
}</span>

// GetEntries returns all captured log entries
func (l *TestLogger) GetEntries() []TestEntry <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        // Return a copy to prevent modification
        result := make([]TestEntry, len(l.entries))
        copy(result, l.entries)
        return result
}</span>

// ClearEntries clears all captured log entries
func (l *TestLogger) ClearEntries() <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.entries = nil
}</span>

// Debug logs a debug message
func (l *TestLogger) Debug(msg string, fields ...Field) <span class="cov0" title="0">{
        if l.level &lt;= DebugLevel </span><span class="cov0" title="0">{
                l.log(DebugLevel, msg, fields)
        }</span>
}

// Info logs an info message
func (l *TestLogger) Info(msg string, fields ...Field) <span class="cov0" title="0">{
        if l.level &lt;= InfoLevel </span><span class="cov0" title="0">{
                l.log(InfoLevel, msg, fields)
        }</span>
}

// Warn logs a warning message
func (l *TestLogger) Warn(msg string, fields ...Field) <span class="cov0" title="0">{
        if l.level &lt;= WarnLevel </span><span class="cov0" title="0">{
                l.log(WarnLevel, msg, fields)
        }</span>
}

// Error logs an error message
func (l *TestLogger) Error(msg string, fields ...Field) <span class="cov0" title="0">{
        if l.level &lt;= ErrorLevel </span><span class="cov0" title="0">{
                l.log(ErrorLevel, msg, fields)
        }</span>
}

// Fatal logs a fatal message
func (l *TestLogger) Fatal(msg string, fields ...Field) <span class="cov0" title="0">{
        if l.level &lt;= FatalLevel </span><span class="cov0" title="0">{
                l.log(FatalLevel, msg, fields)
        }</span>
}

// log captures a log entry
func (l *TestLogger) log(level Level, msg string, fields []Field) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        // Combine base fields with the provided fields
        allFields := make([]Field, 0, len(l.fields)+len(fields))
        allFields = append(allFields, l.fields...)
        allFields = append(allFields, fields...)

        l.entries = append(l.entries, TestEntry{
                Level:   level,
                Message: msg,
                Fields:  allFields,
        })
}</span>

// Debugf logs a formatted debug message
func (l *TestLogger) Debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= DebugLevel </span><span class="cov0" title="0">{
                l.logf(DebugLevel, format, args...)
        }</span>
}

// Infof logs a formatted info message
func (l *TestLogger) Infof(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= InfoLevel </span><span class="cov0" title="0">{
                l.logf(InfoLevel, format, args...)
        }</span>
}

// Warnf logs a formatted warning message
func (l *TestLogger) Warnf(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= WarnLevel </span><span class="cov0" title="0">{
                l.logf(WarnLevel, format, args...)
        }</span>
}

// Errorf logs a formatted error message
func (l *TestLogger) Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= ErrorLevel </span><span class="cov0" title="0">{
                l.logf(ErrorLevel, format, args...)
        }</span>
}

// Fatalf logs a formatted fatal message
func (l *TestLogger) Fatalf(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= FatalLevel </span><span class="cov0" title="0">{
                l.logf(FatalLevel, format, args...)
        }</span>
}

// logf captures a formatted log entry
func (l *TestLogger) logf(level Level, format string, args ...interface{}) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        msg := fmt.Sprintf(format, args...)
        l.entries = append(l.entries, TestEntry{
                Level:   level,
                Message: msg,
                Fields:  l.fields,
        })
}</span>

// WithField returns a new logger with a field added to the context
func (l *TestLogger) WithField(key string, value interface{}) Logger <span class="cov0" title="0">{
        return l.With(Any(key, value))
}</span>

// WithFields returns a new logger with fields added to the context
func (l *TestLogger) WithFields(fields Fields) Logger <span class="cov0" title="0">{
        newLogger := &amp;TestLogger{
                level:   l.level,
                entries: l.entries,
        }

        // Copy existing fields
        newLogger.fields = make([]Field, len(l.fields))
        copy(newLogger.fields, l.fields)

        // Add new fields
        for k, v := range fields </span><span class="cov0" title="0">{
                newLogger.fields = append(newLogger.fields, Any(k, v))
        }</span>

        <span class="cov0" title="0">return newLogger</span>
}

// WithError returns a new logger with an error field
func (l *TestLogger) WithError(err error) Logger <span class="cov0" title="0">{
        return l.With(Err(err))
}</span>

// With returns a new logger with the provided fields added to the context
func (l *TestLogger) With(fields ...Field) Logger <span class="cov0" title="0">{
        newLogger := &amp;TestLogger{
                level:   l.level,
                entries: l.entries,
        }

        // Copy existing fields
        newLogger.fields = make([]Field, len(l.fields))
        copy(newLogger.fields, l.fields)

        // Add new fields
        newLogger.fields = append(newLogger.fields, fields...)

        return newLogger
}</span>

// WithContext returns a new logger with context values extracted as fields
func (l *TestLogger) WithContext(ctx context.Context) Logger <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return l
        }</span>

        <span class="cov0" title="0">fields := ContextExtractor(ctx)
        return l.WithFields(fields)</span>
}

// WithComponent returns a new logger with a component field
func (l *TestLogger) WithComponent(component string) Logger <span class="cov0" title="0">{
        return l.With(Str(ComponentKey, component))
}</span>

// SetLevel sets the minimum log level
func (l *TestLogger) SetLevel(level Level) <span class="cov0" title="0">{
        l.level = level
}</span>

// GetLevel returns the current minimum log level
func (l *TestLogger) GetLevel() Level <span class="cov0" title="0">{
        return l.level
}</span>

// AssertLogged returns true if a log entry with the given level and message was captured
func (l *TestLogger) AssertLogged(level Level, containsMessage string) bool <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        for _, entry := range l.entries </span><span class="cov0" title="0">{
                if entry.Level == level &amp;&amp; strings.Contains(entry.Message, containsMessage) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// AssertLoggedWithField returns true if a log entry with the given level, message,
// and field key/value was captured
func (l *TestLogger) AssertLoggedWithField(level Level, containsMessage string, key string, value interface{}) bool <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        for _, entry := range l.entries </span><span class="cov0" title="0">{
                if entry.Level != level || !strings.Contains(entry.Message, containsMessage) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check fields
                <span class="cov0" title="0">for _, field := range entry.Fields </span><span class="cov0" title="0">{
                        if field.Key == key </span><span class="cov0" title="0">{
                                // For simplicity, just check string representation
                                valueStr := fmt.Sprintf("%v", value)
                                fieldValueStr := fmt.Sprintf("%v", field.Value)
                                if valueStr == fieldValueStr </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package log

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
        "time"
)

// ConsoleOutput writes log entries to the console (stdout/stderr).
type ConsoleOutput struct {
        mu            sync.Mutex
        useStderr     bool      // Use stderr instead of stdout
        errorToStderr bool      // Send error and fatal logs to stderr
        writer        io.Writer // Custom writer (optional)
        errorWriter   io.Writer // Custom error writer (optional)
}

// Write writes the log entry to the console.
func (o *ConsoleOutput) Write(entry *Entry, formattedEntry []byte) error <span class="cov8" title="1">{
        o.mu.Lock()
        defer o.mu.Unlock()

        // Determine the appropriate writer
        var writer io.Writer
        if o.writer != nil </span><span class="cov0" title="0">{
                writer = o.writer
        }</span> else<span class="cov8" title="1"> if o.useStderr </span><span class="cov0" title="0">{
                writer = os.Stderr
        }</span> else<span class="cov8" title="1"> {
                writer = os.Stdout
        }</span>

        // Use error writer for error/fatal levels if enabled
        <span class="cov8" title="1">if (entry.Level == ErrorLevel || entry.Level == FatalLevel) &amp;&amp; o.errorToStderr </span><span class="cov0" title="0">{
                if o.errorWriter != nil </span><span class="cov0" title="0">{
                        writer = o.errorWriter
                }</span> else<span class="cov0" title="0"> {
                        writer = os.Stderr
                }</span>
        }

        <span class="cov8" title="1">_, err := writer.Write(formattedEntry)
        return err</span>
}

// Close implements the Output interface but does nothing for console output.
func (o *ConsoleOutput) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// ConsoleOutputOption is a function that configures a ConsoleOutput.
type ConsoleOutputOption func(*ConsoleOutput)

// WithStderr configures the ConsoleOutput to use stderr.
func WithStderr() ConsoleOutputOption <span class="cov0" title="0">{
        return func(o *ConsoleOutput) </span><span class="cov0" title="0">{
                o.useStderr = true
        }</span>
}

// WithErrorToStderr configures the ConsoleOutput to send error and fatal logs to stderr.
func WithErrorToStderr() ConsoleOutputOption <span class="cov0" title="0">{
        return func(o *ConsoleOutput) </span><span class="cov0" title="0">{
                o.errorToStderr = true
        }</span>
}

// WithCustomWriter configures the ConsoleOutput to use a custom writer.
func WithCustomWriter(writer io.Writer) ConsoleOutputOption <span class="cov0" title="0">{
        return func(o *ConsoleOutput) </span><span class="cov0" title="0">{
                o.writer = writer
        }</span>
}

// WithCustomErrorWriter configures the ConsoleOutput to use a custom error writer.
func WithCustomErrorWriter(writer io.Writer) ConsoleOutputOption <span class="cov0" title="0">{
        return func(o *ConsoleOutput) </span><span class="cov0" title="0">{
                o.errorWriter = writer
        }</span>
}

// NewConsoleOutput creates a new ConsoleOutput with the given options.
func NewConsoleOutput(options ...ConsoleOutputOption) *ConsoleOutput <span class="cov0" title="0">{
        o := &amp;ConsoleOutput{
                errorToStderr: true, // Default to sending errors to stderr
        }

        for _, option := range options </span><span class="cov0" title="0">{
                option(o)
        }</span>

        <span class="cov0" title="0">return o</span>
}

// FileOutput writes log entries to a file.
type FileOutput struct {
        mu           sync.Mutex
        file         *os.File
        filename     string
        maxSize      int64         // Maximum file size in bytes
        maxAge       time.Duration // Maximum file age
        maxBackups   int           // Maximum number of backups
        backupFormat string        // Format for backup filenames
        currentSize  int64         // Current file size
        openTime     time.Time     // When the file was opened
}

// Write writes the log entry to the file.
func (o *FileOutput) Write(entry *Entry, formattedEntry []byte) error <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        // Ensure file is open
        if o.file == nil </span><span class="cov0" title="0">{
                if err := o.openFile(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Check if rotation is needed
        <span class="cov0" title="0">if o.shouldRotate(int64(len(formattedEntry))) </span><span class="cov0" title="0">{
                if err := o.rotate(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Write to file
        <span class="cov0" title="0">n, err := o.file.Write(formattedEntry)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update current size
        <span class="cov0" title="0">o.currentSize += int64(n)
        return nil</span>
}

// Close closes the file.
func (o *FileOutput) Close() error <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        if o.file != nil </span><span class="cov0" title="0">{
                err := o.file.Close()
                o.file = nil
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// shouldRotate checks if the file should be rotated.
func (o *FileOutput) shouldRotate(size int64) bool <span class="cov0" title="0">{
        // Check size limit
        if o.maxSize &gt; 0 &amp;&amp; o.currentSize+size &gt; o.maxSize </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check age limit
        <span class="cov0" title="0">if o.maxAge &gt; 0 &amp;&amp; time.Since(o.openTime) &gt; o.maxAge </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// openFile opens the log file.
func (o *FileOutput) openFile() error <span class="cov0" title="0">{
        // Create directory if needed
        dir := filepath.Dir(o.filename)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Open file for appending
        <span class="cov0" title="0">file, err := os.OpenFile(o.filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get file info for size
        <span class="cov0" title="0">info, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                file.Close()
                return err
        }</span>

        <span class="cov0" title="0">o.file = file
        o.currentSize = info.Size()
        o.openTime = time.Now()
        return nil</span>
}

// rotate rotates the log file.
func (o *FileOutput) rotate() error <span class="cov0" title="0">{
        // Close current file
        if o.file != nil </span><span class="cov0" title="0">{
                if err := o.file.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">o.file = nil</span>
        }

        // Generate backup name
        <span class="cov0" title="0">backupName := o.backupFilename()

        // Rename current file to backup
        if err := os.Rename(o.filename, backupName); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        // Clean up old backups
        <span class="cov0" title="0">if o.maxBackups &gt; 0 </span><span class="cov0" title="0">{
                if err := o.cleanupOldBackups(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Open new file
        <span class="cov0" title="0">return o.openFile()</span>
}

// backupFilename generates a filename for a backup.
func (o *FileOutput) backupFilename() string <span class="cov0" title="0">{
        format := o.backupFormat
        if format == "" </span><span class="cov0" title="0">{
                format = "2006-01-02T15-04-05"
        }</span>
        <span class="cov0" title="0">timestamp := time.Now().Format(format)
        return fmt.Sprintf("%s.%s", o.filename, timestamp)</span>
}

// cleanupOldBackups removes old backup files.
func (o *FileOutput) cleanupOldBackups() error <span class="cov0" title="0">{
        dir := filepath.Dir(o.filename)
        base := filepath.Base(o.filename)

        // List all backup files
        files, err := filepath.Glob(filepath.Join(dir, base+".*"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If we have fewer backups than the limit, no cleanup needed
        <span class="cov0" title="0">if len(files) &lt;= o.maxBackups </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get file info for sorting
        <span class="cov0" title="0">type backupFile struct {
                path    string
                modTime time.Time
        }
        backups := make([]backupFile, 0, len(files))
        for _, file := range files </span><span class="cov0" title="0">{
                info, err := os.Stat(file)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">backups = append(backups, backupFile{path: file, modTime: info.ModTime()})</span>
        }

        // Sort by modification time (newest first)
        <span class="cov0" title="0">for i := 0; i &lt; len(backups)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(backups); j++ </span><span class="cov0" title="0">{
                        if backups[i].modTime.Before(backups[j].modTime) </span><span class="cov0" title="0">{
                                backups[i], backups[j] = backups[j], backups[i]
                        }</span>
                }
        }

        // Remove excess backups
        <span class="cov0" title="0">for i := o.maxBackups; i &lt; len(backups); i++ </span><span class="cov0" title="0">{
                if err := os.Remove(backups[i].path); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// FileOutputOption is a function that configures a FileOutput.
type FileOutputOption func(*FileOutput)

// WithMaxSize sets the maximum file size.
func WithMaxSize(maxBytes int64) FileOutputOption <span class="cov0" title="0">{
        return func(o *FileOutput) </span><span class="cov0" title="0">{
                o.maxSize = maxBytes
        }</span>
}

// WithMaxAge sets the maximum file age.
func WithMaxAge(maxAge time.Duration) FileOutputOption <span class="cov0" title="0">{
        return func(o *FileOutput) </span><span class="cov0" title="0">{
                o.maxAge = maxAge
        }</span>
}

// WithMaxBackups sets the maximum number of backup files.
func WithMaxBackups(maxBackups int) FileOutputOption <span class="cov0" title="0">{
        return func(o *FileOutput) </span><span class="cov0" title="0">{
                o.maxBackups = maxBackups
        }</span>
}

// WithBackupFormat sets the format for backup filenames.
func WithBackupFormat(format string) FileOutputOption <span class="cov0" title="0">{
        return func(o *FileOutput) </span><span class="cov0" title="0">{
                o.backupFormat = format
        }</span>
}

// NewFileOutput creates a new FileOutput with the given options.
func NewFileOutput(filename string, options ...FileOutputOption) *FileOutput <span class="cov0" title="0">{
        o := &amp;FileOutput{
                filename:     filename,
                maxSize:      10 * 1024 * 1024, // 10MB default
                maxBackups:   5,                // 5 backups default
                backupFormat: "2006-01-02T15-04-05",
        }

        for _, option := range options </span><span class="cov0" title="0">{
                option(o)
        }</span>

        <span class="cov0" title="0">return o</span>
}

// NullOutput discards all log entries.
type NullOutput struct{}

// Write implements the Output interface but does nothing.
func (o *NullOutput) Write(entry *Entry, formattedEntry []byte) error <span class="cov0" title="0">{
        return nil
}</span>

// Close implements the Output interface but does nothing.
func (o *NullOutput) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// NewNullOutput creates a new NullOutput.
func NewNullOutput() *NullOutput <span class="cov0" title="0">{
        return &amp;NullOutput{}
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package log

import (
        "io"
        stdlog "log"
)

// ToStdLogger converts our structured Logger to a standard library *log.Logger
// This is helpful for integrating with libraries or components that expect a standard logger
func ToStdLogger(logger Logger, prefix string, flag int) *stdlog.Logger <span class="cov0" title="0">{
        if flag == 0 </span><span class="cov0" title="0">{
                flag = stdlog.LstdFlags
        }</span>
        <span class="cov0" title="0">return stdlog.New(&amp;logAdapter{logger: logger}, prefix, flag)</span>
}

// logAdapter adapts our Logger to io.Writer for use with standard log package
type logAdapter struct {
        logger Logger
}

// Write implements io.Writer, converting written content to structured log messages
func (a *logAdapter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        // Remove trailing newline if present
        msg := string(p)
        if len(msg) &gt; 0 &amp;&amp; msg[len(msg)-1] == '\n' </span><span class="cov0" title="0">{
                msg = msg[:len(msg)-1]
        }</span>

        // Log at info level
        <span class="cov0" title="0">a.logger.Info(msg)

        return len(p), nil</span>
}

// StdLogWriter creates an io.Writer that logs lines at the specified level
// Useful for redirecting output from third-party libraries
func StdLogWriter(logger Logger, level Level) io.Writer <span class="cov0" title="0">{
        return &amp;leveledLogAdapter{
                logger: logger,
                level:  level,
        }
}</span>

// leveledLogAdapter adapts our Logger to io.Writer with level control
type leveledLogAdapter struct {
        logger Logger
        level  Level
}

// Write implements io.Writer, writing to the logger at the configured level
func (a *leveledLogAdapter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        // Remove trailing newline if present
        msg := string(p)
        if len(msg) &gt; 0 &amp;&amp; msg[len(msg)-1] == '\n' </span><span class="cov0" title="0">{
                msg = msg[:len(msg)-1]
        }</span>

        <span class="cov0" title="0">switch a.level </span>{
        case DebugLevel:<span class="cov0" title="0">
                a.logger.Debug(msg)</span>
        case InfoLevel:<span class="cov0" title="0">
                a.logger.Info(msg)</span>
        case WarnLevel:<span class="cov0" title="0">
                a.logger.Warn(msg)</span>
        case ErrorLevel:<span class="cov0" title="0">
                a.logger.Error(msg)</span>
        case FatalLevel:<span class="cov0" title="0">
                a.logger.Error(msg)</span> // Don't use Fatal to avoid os.Exit
        default:<span class="cov0" title="0">
                a.logger.Info(msg)</span>
        }

        <span class="cov0" title="0">return len(p), nil</span>
}

// RedirectStdLog redirects the standard library's default logger to our logger
// This is useful for capturing logs from third-party libraries that use the
// standard log package directly
func RedirectStdLog(logger Logger) func() <span class="cov0" title="0">{
        // Save the original settings
        origOutput := stdlog.Writer()
        origFlags := stdlog.Flags()
        origPrefix := stdlog.Prefix()

        // Redirect to our logger
        stdlog.SetOutput(StdLogWriter(logger, InfoLevel))
        stdlog.SetFlags(0) // Remove standard logger's built-in prefixes

        // Return a function that restores the original settings
        return func() </span><span class="cov0" title="0">{
                stdlog.SetOutput(origOutput)
                stdlog.SetFlags(origFlags)
                stdlog.SetPrefix(origPrefix)
        }</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package orchestrator

import (
        "fmt"
        "strings"

        "github.com/rzbill/rune/pkg/types"
)

// prepareEnvVars prepares environment variables for an instance
func prepareEnvVars(service *types.Service, instance *types.Instance) map[string]string <span class="cov8" title="1">{
        envVars := make(map[string]string)

        // Add service-defined environment variables
        for key, value := range service.Env </span><span class="cov8" title="1">{
                envVars[key] = value
        }</span>

        // Add built-in environment variables
        <span class="cov8" title="1">envVars["RUNE_SERVICE_NAME"] = service.Name
        envVars["RUNE_SERVICE_NAMESPACE"] = service.Namespace
        envVars["RUNE_INSTANCE_ID"] = instance.ID

        // Add normalized environment variables (for compatibility)
        serviceName := strings.ToUpper(service.Name)
        serviceName = strings.ReplaceAll(serviceName, "-", "_")

        envVars[fmt.Sprintf("%s_SERVICE_HOST", serviceName)] = fmt.Sprintf("%s.%s.rune", service.Name, service.Namespace)

        // Add port-related environment variables
        for _, port := range service.Ports </span><span class="cov8" title="1">{
                portName := strings.ToUpper(port.Name)
                portName = strings.ReplaceAll(portName, "-", "_")

                envVars[fmt.Sprintf("%s_SERVICE_PORT_%s", serviceName, portName)] = fmt.Sprintf("%d", port.Port)

                // If this is the first port, also set the default port
                if len(envVars[fmt.Sprintf("%s_SERVICE_PORT", serviceName)]) == 0 </span><span class="cov8" title="1">{
                        envVars[fmt.Sprintf("%s_SERVICE_PORT", serviceName)] = fmt.Sprintf("%d", port.Port)
                }</span>
        }

        <span class="cov8" title="1">return envVars</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package orchestrator

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "strings"
        "sync"
        "time"

        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/types"
)

// FakeInstanceController implements the InstanceController interface for testing purposes
type FakeInstanceController struct {
        mu                    sync.Mutex
        logger                log.Logger
        instances             map[string]*types.Instance // Keyed by ID
        CreateInstanceCalls   []CreateInstanceCall
        RecreateInstanceCalls []RecreateInstanceCall
        UpdateInstanceCalls   []UpdateInstanceCall
        DeleteInstanceCalls   []DeleteInstanceCall
        RestartInstanceCalls  []RestartInstanceCall
        GetStatusCalls        []string // Instance IDs
        GetLogsCalls          []string // Instance IDs
        ExecCalls             []ExecCall

        // Custom behavior options
        CreateInstanceFunc   func(ctx context.Context, service *types.Service, instanceName string) (*types.Instance, error)
        RecreateInstanceFunc func(ctx context.Context, service *types.Service, instance *types.Instance) (*types.Instance, error)
        UpdateInstanceFunc   func(ctx context.Context, service *types.Service, instance *types.Instance) error
        DeleteInstanceFunc   func(ctx context.Context, instance *types.Instance) error
        RestartInstanceFunc  func(ctx context.Context, instance *types.Instance, reason InstanceRestartReason) error
        GetStatusFunc        func(ctx context.Context, instance *types.Instance) (*InstanceStatusInfo, error)
        GetLogsFunc          func(ctx context.Context, instance *types.Instance, opts LogOptions) (io.ReadCloser, error)
        ExecFunc             func(ctx context.Context, instance *types.Instance, options ExecOptions) (ExecStream, error)

        // Default error responses
        CreateInstanceError   error
        RecreateInstanceError error
        UpdateInstanceError   error
        DeleteInstanceError   error
        RestartInstanceError  error
        GetStatusError        error
        GetLogsError          error
        ExecError             error

        // Mock responses
        ExecStdout   []byte
        ExecStderr   []byte
        ExecExitCode int
}

// CreateInstanceCall records the parameters of a CreateInstance call
type CreateInstanceCall struct {
        Service      *types.Service
        InstanceName string
}

// RecreateInstanceCall records the parameters of a RecreateInstance call
type RecreateInstanceCall struct {
        Service  *types.Service
        Instance *types.Instance
}

// UpdateInstanceCall records the parameters of an UpdateInstance call
type UpdateInstanceCall struct {
        Service  *types.Service
        Instance *types.Instance
}

// DeleteInstanceCall records the parameters of a DeleteInstance call
type DeleteInstanceCall struct {
        Instance *types.Instance
}

// RestartInstanceCall records the parameters of a RestartInstance call
type RestartInstanceCall struct {
        Instance *types.Instance
        Reason   InstanceRestartReason
}

// ExecCall records the parameters of an Exec call
type ExecCall struct {
        Instance *types.Instance
        Options  ExecOptions
}

// NewFakeInstanceController creates a new test instance controller
func NewFakeInstanceController() *FakeInstanceController <span class="cov8" title="1">{
        return &amp;FakeInstanceController{
                instances: make(map[string]*types.Instance),
                logger:    log.NewLogger().WithComponent("test-instance-controller"),
        }
}</span>

// CreateInstance records a call to create an instance and returns a predefined or mocked result
func (c *FakeInstanceController) CreateInstance(ctx context.Context, service *types.Service, instanceName string) (*types.Instance, error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Record the call
        c.CreateInstanceCalls = append(c.CreateInstanceCalls, CreateInstanceCall{
                Service:      service,
                InstanceName: instanceName,
        })

        // If custom function is provided, use it
        if c.CreateInstanceFunc != nil </span><span class="cov8" title="1">{
                return c.CreateInstanceFunc(ctx, service, instanceName)
        }</span>

        // If error is set, return it
        <span class="cov8" title="1">if c.CreateInstanceError != nil </span><span class="cov0" title="0">{
                return nil, c.CreateInstanceError
        }</span>

        // Default behavior
        <span class="cov8" title="1">instance := &amp;types.Instance{
                ID:          instanceName, // Use the name as ID for simplicity in tests
                Name:        instanceName,
                Namespace:   service.Namespace,
                ServiceID:   service.ID,
                Status:      types.InstanceStatusRunning,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
                Environment: make(map[string]string),
        }

        // Store the instance
        c.instances[instance.ID] = instance

        return instance, nil</span>
}

// RecreateInstance records a call to recreate an instance
func (c *FakeInstanceController) RecreateInstance(ctx context.Context, service *types.Service, instance *types.Instance) (*types.Instance, error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Record the call
        c.RecreateInstanceCalls = append(c.RecreateInstanceCalls, RecreateInstanceCall{
                Service:  service,
                Instance: instance,
        })

        // If custom function is provided, use it
        if c.RecreateInstanceFunc != nil </span><span class="cov0" title="0">{
                return c.RecreateInstanceFunc(ctx, service, instance)
        }</span>

        // If error is set, return it
        <span class="cov0" title="0">if c.RecreateInstanceError != nil </span><span class="cov0" title="0">{
                return nil, c.RecreateInstanceError
        }</span>

        // Default behavior: Delete and recreate
        <span class="cov0" title="0">delete(c.instances, instance.ID)

        newInstance := &amp;types.Instance{
                ID:          instance.ID,
                Name:        instance.Name,
                Namespace:   service.Namespace,
                ServiceID:   service.ID,
                Status:      types.InstanceStatusRunning,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
                Environment: make(map[string]string),
        }

        // Store the new instance
        c.instances[newInstance.ID] = newInstance

        return newInstance, nil</span>
}

// UpdateInstance records a call to update an instance
func (c *FakeInstanceController) UpdateInstance(ctx context.Context, service *types.Service, instance *types.Instance) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Record the call
        c.UpdateInstanceCalls = append(c.UpdateInstanceCalls, UpdateInstanceCall{
                Service:  service,
                Instance: instance,
        })

        // If custom function is provided, use it
        if c.UpdateInstanceFunc != nil </span><span class="cov0" title="0">{
                return c.UpdateInstanceFunc(ctx, service, instance)
        }</span>

        // If error is set, return it
        <span class="cov8" title="1">if c.UpdateInstanceError != nil </span><span class="cov0" title="0">{
                return c.UpdateInstanceError
        }</span>

        // Default behavior
        <span class="cov8" title="1">if existingInstance, exists := c.instances[instance.ID]; exists </span><span class="cov8" title="1">{
                // Update the stored instance
                existingInstance.Status = instance.Status
                existingInstance.UpdatedAt = time.Now()
                existingInstance.Environment = instance.Environment
                c.instances[instance.ID] = existingInstance
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DeleteInstance records a call to delete an instance
func (c *FakeInstanceController) DeleteInstance(ctx context.Context, instance *types.Instance) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Record the call
        c.DeleteInstanceCalls = append(c.DeleteInstanceCalls, DeleteInstanceCall{
                Instance: instance,
        })

        // If custom function is provided, use it
        if c.DeleteInstanceFunc != nil </span><span class="cov8" title="1">{
                return c.DeleteInstanceFunc(ctx, instance)
        }</span>

        // If error is set, return it
        <span class="cov8" title="1">if c.DeleteInstanceError != nil </span><span class="cov0" title="0">{
                return c.DeleteInstanceError
        }</span>

        // Default behavior
        <span class="cov8" title="1">delete(c.instances, instance.ID)

        return nil</span>
}

// GetInstanceStatus records a call to get instance status
func (c *FakeInstanceController) GetInstanceStatus(ctx context.Context, instance *types.Instance) (*InstanceStatusInfo, error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Record the call
        c.GetStatusCalls = append(c.GetStatusCalls, instance.ID)

        // If custom function is provided, use it
        if c.GetStatusFunc != nil </span><span class="cov0" title="0">{
                return c.GetStatusFunc(ctx, instance)
        }</span>

        // If error is set, return it
        <span class="cov0" title="0">if c.GetStatusError != nil </span><span class="cov0" title="0">{
                return nil, c.GetStatusError
        }</span>

        // Default behavior
        <span class="cov0" title="0">storedInstance, exists := c.instances[instance.ID]
        if !exists </span><span class="cov0" title="0">{
                return &amp;InstanceStatusInfo{
                        State:      types.InstanceStatusUnknown,
                        InstanceID: instance.ID,
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;InstanceStatusInfo{
                State:      storedInstance.Status,
                InstanceID: storedInstance.ID,
                NodeID:     storedInstance.NodeID,
                CreatedAt:  storedInstance.CreatedAt,
        }, nil</span>
}

// GetInstanceLogs records a call to get instance logs
func (c *FakeInstanceController) GetInstanceLogs(ctx context.Context, instance *types.Instance, opts LogOptions) (io.ReadCloser, error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Record the call
        c.GetLogsCalls = append(c.GetLogsCalls, instance.ID)

        // If custom function is provided, use it
        if c.GetLogsFunc != nil </span><span class="cov0" title="0">{
                return c.GetLogsFunc(ctx, instance, opts)
        }</span>

        // If error is set, return it
        <span class="cov0" title="0">if c.GetLogsError != nil </span><span class="cov0" title="0">{
                return nil, c.GetLogsError
        }</span>

        // Default behavior - return empty reader
        <span class="cov0" title="0">return io.NopCloser(strings.NewReader("")), nil</span>
}

// Exec records a call to execute a command in an instance
func (c *FakeInstanceController) Exec(ctx context.Context, instance *types.Instance, options ExecOptions) (ExecStream, error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Record the call
        c.ExecCalls = append(c.ExecCalls, ExecCall{
                Instance: instance,
                Options:  options,
        })

        // If custom function is provided, use it
        if c.ExecFunc != nil </span><span class="cov0" title="0">{
                return c.ExecFunc(ctx, instance, options)
        }</span>

        // If error is set, return it
        <span class="cov0" title="0">if c.ExecError != nil </span><span class="cov0" title="0">{
                return nil, c.ExecError
        }</span>

        // Default behavior - return a fake exec stream
        <span class="cov0" title="0">return NewFakeExecStream(c.ExecStdout, c.ExecStderr, c.ExecExitCode), nil</span>
}

// RestartInstance records a call to restart an instance
func (c *FakeInstanceController) RestartInstance(ctx context.Context, instance *types.Instance, reason InstanceRestartReason) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Record the call
        c.RestartInstanceCalls = append(c.RestartInstanceCalls, RestartInstanceCall{
                Instance: instance,
                Reason:   reason,
        })

        // If custom function is provided, use it
        if c.RestartInstanceFunc != nil </span><span class="cov0" title="0">{
                return c.RestartInstanceFunc(ctx, instance, reason)
        }</span>

        // If error is set, return it
        <span class="cov0" title="0">if c.RestartInstanceError != nil </span><span class="cov0" title="0">{
                return c.RestartInstanceError
        }</span>

        // Default behavior
        <span class="cov0" title="0">if storedInstance, exists := c.instances[instance.ID]; exists </span><span class="cov0" title="0">{
                storedInstance.Status = types.InstanceStatusRunning
                storedInstance.UpdatedAt = time.Now()
                c.instances[instance.ID] = storedInstance
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddInstance allows tests to add an instance directly to the controller's storage
func (c *FakeInstanceController) AddInstance(instance *types.Instance) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.instances[instance.ID] = instance
}</span>

// GetInstance allows tests to retrieve an instance from the controller's storage
func (c *FakeInstanceController) GetInstance(instanceID string) (*types.Instance, bool) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        instance, exists := c.instances[instanceID]
        return instance, exists
}</span>

// Reset clears all recorded calls and stored instances
func (c *FakeInstanceController) Reset() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.instances = make(map[string]*types.Instance)
        c.CreateInstanceCalls = nil
        c.RecreateInstanceCalls = nil
        c.UpdateInstanceCalls = nil
        c.DeleteInstanceCalls = nil
        c.RestartInstanceCalls = nil
        c.GetStatusCalls = nil
        c.GetLogsCalls = nil
        c.ExecCalls = nil
}</span>

// FakeExecStream implements ExecStream for testing
type FakeExecStream struct {
        StdoutContent []byte
        StdoutPos     int
        StderrContent []byte
        StderrReader  io.Reader
        ExitCodeVal   int
        SignalsSent   []string
        InputCapture  []byte
        Closed        bool
        mu            sync.Mutex
}

// NewFakeExecStream creates a new fake exec stream with predefined content
func NewFakeExecStream(stdout, stderr []byte, exitCode int) *FakeExecStream <span class="cov0" title="0">{
        return &amp;FakeExecStream{
                StdoutContent: stdout,
                StderrContent: stderr,
                ExitCodeVal:   exitCode,
                StderrReader:  bytes.NewReader(stderr),
                SignalsSent:   make([]string, 0),
                InputCapture:  make([]byte, 0),
                Closed:        false,
        }
}</span>

// Write captures input that would be sent to the exec process
func (s *FakeExecStream) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.Closed </span><span class="cov0" title="0">{
                return 0, io.ErrClosedPipe
        }</span>

        // Capture the input
        <span class="cov0" title="0">s.InputCapture = append(s.InputCapture, p...)
        return len(p), nil</span>
}

// Read returns predefined output content in chunks
func (s *FakeExecStream) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.Closed </span><span class="cov0" title="0">{
                return 0, io.ErrClosedPipe
        }</span>

        // If we've read everything, return EOF
        <span class="cov0" title="0">if s.StdoutPos &gt;= len(s.StdoutContent) </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>

        // Calculate how much to read
        <span class="cov0" title="0">remaining := len(s.StdoutContent) - s.StdoutPos
        toRead := len(p)
        if toRead &gt; remaining </span><span class="cov0" title="0">{
                toRead = remaining
        }</span>

        // Copy the data
        <span class="cov0" title="0">copy(p, s.StdoutContent[s.StdoutPos:s.StdoutPos+toRead])
        s.StdoutPos += toRead

        return toRead, nil</span>
}

// Stderr returns an io.Reader for the stderr stream
func (s *FakeExecStream) Stderr() io.Reader <span class="cov0" title="0">{
        return s.StderrReader
}</span>

// ResizeTerminal records terminal resize events
func (s *FakeExecStream) ResizeTerminal(width, height uint32) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.Closed </span><span class="cov0" title="0">{
                return fmt.Errorf("exec session closed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Signal records signals sent to the process
func (s *FakeExecStream) Signal(sigName string) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.Closed </span><span class="cov0" title="0">{
                return fmt.Errorf("exec session closed")
        }</span>

        <span class="cov0" title="0">s.SignalsSent = append(s.SignalsSent, sigName)
        return nil</span>
}

// ExitCode returns the predefined exit code
func (s *FakeExecStream) ExitCode() (int, error) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        return s.ExitCodeVal, nil
}</span>

// Close marks the stream as closed
func (s *FakeExecStream) Close() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.Closed = true
        return nil
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package orchestrator

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "sync"
        "time"

        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/types"
)

// FakeOrchestrator implements the Orchestrator interface for testing purposes
type FakeOrchestrator struct {
        mu                     sync.Mutex
        logger                 log.Logger
        started                bool
        stopped                bool
        services               map[string]map[string]*types.Service  // namespace -&gt; name -&gt; service
        instances              map[string]map[string]*types.Instance // namespace -&gt; ID -&gt; instance
        StartCalls             []context.Context
        StopCalls              []bool
        GetServiceStatusCalls  []GetServiceStatusCall
        GetInstanceStatusCalls []GetInstanceStatusCall
        GetServiceLogsCalls    []GetServiceLogsCall
        GetInstanceLogsCalls   []GetInstanceLogsCall
        ExecInServiceCalls     []ExecInServiceCall
        ExecInInstanceCalls    []ExecInInstanceCall
        RestartServiceCalls    []RestartServiceCall
        RestartInstanceCalls   []OrchestratorRestartInstanceCall

        // Custom behavior options
        StartFunc             func(ctx context.Context) error
        StopFunc              func() error
        GetServiceStatusFunc  func(ctx context.Context, namespace, name string) (*ServiceStatusInfo, error)
        GetInstanceStatusFunc func(ctx context.Context, namespace, serviceName, instanceID string) (*InstanceStatusInfo, error)
        GetServiceLogsFunc    func(ctx context.Context, namespace, name string, opts LogOptions) (io.ReadCloser, error)
        GetInstanceLogsFunc   func(ctx context.Context, namespace, serviceName, instanceID string, opts LogOptions) (io.ReadCloser, error)
        ExecInServiceFunc     func(ctx context.Context, namespace, serviceName string, options ExecOptions) (ExecStream, error)
        ExecInInstanceFunc    func(ctx context.Context, namespace, serviceName, instanceID string, options ExecOptions) (ExecStream, error)
        RestartServiceFunc    func(ctx context.Context, namespace, serviceName string) error
        RestartInstanceFunc   func(ctx context.Context, namespace, serviceName, instanceID string) error

        // Default error responses
        StartError             error
        StopError              error
        GetServiceStatusError  error
        GetInstanceStatusError error
        GetServiceLogsError    error
        GetInstanceLogsError   error
        ExecInServiceError     error
        ExecInInstanceError    error
        RestartServiceError    error
        RestartInstanceError   error

        // Mock responses
        LogsOutput   []byte
        ExecStdout   []byte
        ExecStderr   []byte
        ExecExitCode int
}

// Call tracking structs
type GetServiceStatusCall struct {
        Namespace string
        Name      string
}

type GetInstanceStatusCall struct {
        Namespace   string
        ServiceName string
        InstanceID  string
}

type GetServiceLogsCall struct {
        Namespace string
        Name      string
        Options   LogOptions
}

type GetInstanceLogsCall struct {
        Namespace   string
        ServiceName string
        InstanceID  string
        Options     LogOptions
}

type ExecInServiceCall struct {
        Namespace   string
        ServiceName string
        Options     ExecOptions
}

type ExecInInstanceCall struct {
        Namespace   string
        ServiceName string
        InstanceID  string
        Options     ExecOptions
}

type RestartServiceCall struct {
        Namespace   string
        ServiceName string
}

type OrchestratorRestartInstanceCall struct {
        Namespace   string
        ServiceName string
        InstanceID  string
}

// NewFakeOrchestrator creates a new fake orchestrator for testing
func NewFakeOrchestrator() *FakeOrchestrator <span class="cov0" title="0">{
        return &amp;FakeOrchestrator{
                logger:    log.NewLogger().WithComponent("fake-orchestrator"),
                services:  make(map[string]map[string]*types.Service),
                instances: make(map[string]map[string]*types.Instance),
        }
}</span>

// Start implementation for testing
func (o *FakeOrchestrator) Start(ctx context.Context) error <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        o.StartCalls = append(o.StartCalls, ctx)

        if o.StartFunc != nil </span><span class="cov0" title="0">{
                return o.StartFunc(ctx)
        }</span>

        <span class="cov0" title="0">if o.StartError != nil </span><span class="cov0" title="0">{
                return o.StartError
        }</span>

        <span class="cov0" title="0">o.started = true
        return nil</span>
}

// Stop implementation for testing
func (o *FakeOrchestrator) Stop() error <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        o.StopCalls = append(o.StopCalls, true)

        if o.StopFunc != nil </span><span class="cov0" title="0">{
                return o.StopFunc()
        }</span>

        <span class="cov0" title="0">if o.StopError != nil </span><span class="cov0" title="0">{
                return o.StopError
        }</span>

        <span class="cov0" title="0">o.stopped = true
        return nil</span>
}

// GetServiceStatus implementation for testing
func (o *FakeOrchestrator) GetServiceStatus(ctx context.Context, namespace, name string) (*ServiceStatusInfo, error) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        o.GetServiceStatusCalls = append(o.GetServiceStatusCalls, GetServiceStatusCall{
                Namespace: namespace,
                Name:      name,
        })

        if o.GetServiceStatusFunc != nil </span><span class="cov0" title="0">{
                return o.GetServiceStatusFunc(ctx, namespace, name)
        }</span>

        <span class="cov0" title="0">if o.GetServiceStatusError != nil </span><span class="cov0" title="0">{
                return nil, o.GetServiceStatusError
        }</span>

        // Default behavior - look up in our fake storage
        <span class="cov0" title="0">nsServices, ok := o.services[namespace]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namespace %s not found", namespace)
        }</span>

        <span class="cov0" title="0">service, ok := nsServices[name]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service %s not found in namespace %s", name, namespace)
        }</span>

        // Count instances for this service
        <span class="cov0" title="0">instanceCount := 0
        readyCount := 0
        for _, nsInstances := range o.instances </span><span class="cov0" title="0">{
                for _, instance := range nsInstances </span><span class="cov0" title="0">{
                        if instance.Namespace == namespace &amp;&amp; instance.ServiceID == name </span><span class="cov0" title="0">{
                                instanceCount++
                                if instance.Status == types.InstanceStatusRunning </span><span class="cov0" title="0">{
                                        readyCount++
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return &amp;ServiceStatusInfo{
                State:              service.Status,
                InstanceCount:      instanceCount,
                ReadyInstanceCount: readyCount,
        }, nil</span>
}

// GetInstanceStatus implementation for testing
func (o *FakeOrchestrator) GetInstanceStatus(ctx context.Context, namespace, serviceName, instanceID string) (*InstanceStatusInfo, error) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        o.GetInstanceStatusCalls = append(o.GetInstanceStatusCalls, GetInstanceStatusCall{
                Namespace:   namespace,
                ServiceName: serviceName,
                InstanceID:  instanceID,
        })

        if o.GetInstanceStatusFunc != nil </span><span class="cov0" title="0">{
                return o.GetInstanceStatusFunc(ctx, namespace, serviceName, instanceID)
        }</span>

        <span class="cov0" title="0">if o.GetInstanceStatusError != nil </span><span class="cov0" title="0">{
                return nil, o.GetInstanceStatusError
        }</span>

        // Default behavior - look up in our fake storage
        <span class="cov0" title="0">nsInstances, ok := o.instances[namespace]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namespace %s not found", namespace)
        }</span>

        <span class="cov0" title="0">instance, ok := nsInstances[instanceID]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance %s not found in namespace %s", instanceID, namespace)
        }</span>

        // Verify service association
        <span class="cov0" title="0">if instance.ServiceID != serviceName </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance %s does not belong to service %s", instanceID, serviceName)
        }</span>

        <span class="cov0" title="0">return &amp;InstanceStatusInfo{
                State:      instance.Status,
                InstanceID: instance.ID,
                NodeID:     instance.NodeID,
                CreatedAt:  instance.CreatedAt,
        }, nil</span>
}

// GetServiceLogs implementation for testing
func (o *FakeOrchestrator) GetServiceLogs(ctx context.Context, namespace, name string, opts LogOptions) (io.ReadCloser, error) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        o.GetServiceLogsCalls = append(o.GetServiceLogsCalls, GetServiceLogsCall{
                Namespace: namespace,
                Name:      name,
                Options:   opts,
        })

        if o.GetServiceLogsFunc != nil </span><span class="cov0" title="0">{
                return o.GetServiceLogsFunc(ctx, namespace, name, opts)
        }</span>

        <span class="cov0" title="0">if o.GetServiceLogsError != nil </span><span class="cov0" title="0">{
                return nil, o.GetServiceLogsError
        }</span>

        // Default behavior - verify service exists first
        <span class="cov0" title="0">nsServices, ok := o.services[namespace]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namespace %s not found", namespace)
        }</span>

        <span class="cov0" title="0">_, ok = nsServices[name]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service %s not found in namespace %s", name, namespace)
        }</span>

        // Return predefined logs content or empty if not set
        <span class="cov0" title="0">content := o.LogsOutput
        if content == nil </span><span class="cov0" title="0">{
                content = []byte("")
        }</span>

        <span class="cov0" title="0">return io.NopCloser(bytes.NewReader(content)), nil</span>
}

// GetInstanceLogs implementation for testing
func (o *FakeOrchestrator) GetInstanceLogs(ctx context.Context, namespace, serviceName, instanceID string, opts LogOptions) (io.ReadCloser, error) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        o.GetInstanceLogsCalls = append(o.GetInstanceLogsCalls, GetInstanceLogsCall{
                Namespace:   namespace,
                ServiceName: serviceName,
                InstanceID:  instanceID,
                Options:     opts,
        })

        if o.GetInstanceLogsFunc != nil </span><span class="cov0" title="0">{
                return o.GetInstanceLogsFunc(ctx, namespace, serviceName, instanceID, opts)
        }</span>

        <span class="cov0" title="0">if o.GetInstanceLogsError != nil </span><span class="cov0" title="0">{
                return nil, o.GetInstanceLogsError
        }</span>

        // Default behavior - verify instance exists
        <span class="cov0" title="0">nsInstances, ok := o.instances[namespace]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namespace %s not found", namespace)
        }</span>

        <span class="cov0" title="0">instance, ok := nsInstances[instanceID]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance %s not found in namespace %s", instanceID, namespace)
        }</span>

        // Verify service association
        <span class="cov0" title="0">if instance.ServiceID != serviceName </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance %s does not belong to service %s", instanceID, serviceName)
        }</span>

        // Return predefined logs content or empty if not set
        <span class="cov0" title="0">content := o.LogsOutput
        if content == nil </span><span class="cov0" title="0">{
                content = []byte("")
        }</span>

        <span class="cov0" title="0">return io.NopCloser(bytes.NewReader(content)), nil</span>
}

// ExecInService implementation for testing
func (o *FakeOrchestrator) ExecInService(ctx context.Context, namespace, serviceName string, options ExecOptions) (ExecStream, error) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        o.ExecInServiceCalls = append(o.ExecInServiceCalls, ExecInServiceCall{
                Namespace:   namespace,
                ServiceName: serviceName,
                Options:     options,
        })

        if o.ExecInServiceFunc != nil </span><span class="cov0" title="0">{
                return o.ExecInServiceFunc(ctx, namespace, serviceName, options)
        }</span>

        <span class="cov0" title="0">if o.ExecInServiceError != nil </span><span class="cov0" title="0">{
                return nil, o.ExecInServiceError
        }</span>

        // Default behavior - verify service exists
        <span class="cov0" title="0">nsServices, ok := o.services[namespace]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namespace %s not found", namespace)
        }</span>

        <span class="cov0" title="0">_, ok = nsServices[serviceName]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service %s not found in namespace %s", serviceName, namespace)
        }</span>

        // Verify service has at least one running instance
        <span class="cov0" title="0">instanceFound := false
        for _, nsInstances := range o.instances </span><span class="cov0" title="0">{
                for _, instance := range nsInstances </span><span class="cov0" title="0">{
                        if instance.Namespace == namespace &amp;&amp; instance.ServiceID == serviceName &amp;&amp; instance.Status == types.InstanceStatusRunning </span><span class="cov0" title="0">{
                                instanceFound = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if instanceFound </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if !instanceFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no running instances found for service %s in namespace %s", serviceName, namespace)
        }</span>

        // Return a fake exec stream
        <span class="cov0" title="0">return NewFakeExecStream(o.ExecStdout, o.ExecStderr, o.ExecExitCode), nil</span>
}

// ExecInInstance implementation for testing
func (o *FakeOrchestrator) ExecInInstance(ctx context.Context, namespace, serviceName, instanceID string, options ExecOptions) (ExecStream, error) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        o.ExecInInstanceCalls = append(o.ExecInInstanceCalls, ExecInInstanceCall{
                Namespace:   namespace,
                ServiceName: serviceName,
                InstanceID:  instanceID,
                Options:     options,
        })

        if o.ExecInInstanceFunc != nil </span><span class="cov0" title="0">{
                return o.ExecInInstanceFunc(ctx, namespace, serviceName, instanceID, options)
        }</span>

        <span class="cov0" title="0">if o.ExecInInstanceError != nil </span><span class="cov0" title="0">{
                return nil, o.ExecInInstanceError
        }</span>

        // Default behavior - verify instance exists
        <span class="cov0" title="0">nsInstances, ok := o.instances[namespace]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namespace %s not found", namespace)
        }</span>

        <span class="cov0" title="0">instance, ok := nsInstances[instanceID]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance %s not found in namespace %s", instanceID, namespace)
        }</span>

        // Verify service association
        <span class="cov0" title="0">if instance.ServiceID != serviceName </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance %s does not belong to service %s", instanceID, serviceName)
        }</span>

        // Verify instance is running
        <span class="cov0" title="0">if instance.Status != types.InstanceStatusRunning </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance %s is not running, current status: %s", instanceID, instance.Status)
        }</span>

        // Return a fake exec stream
        <span class="cov0" title="0">return NewFakeExecStream(o.ExecStdout, o.ExecStderr, o.ExecExitCode), nil</span>
}

// AddService adds a service to the fake storage
func (o *FakeOrchestrator) AddService(service *types.Service) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        namespace := service.Namespace
        if _, ok := o.services[namespace]; !ok </span><span class="cov0" title="0">{
                o.services[namespace] = make(map[string]*types.Service)
        }</span>

        <span class="cov0" title="0">o.services[namespace][service.Name] = service</span>
}

// AddInstance adds an instance to the fake storage
func (o *FakeOrchestrator) AddInstance(instance *types.Instance) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        namespace := instance.Namespace
        if _, ok := o.instances[namespace]; !ok </span><span class="cov0" title="0">{
                o.instances[namespace] = make(map[string]*types.Instance)
        }</span>

        <span class="cov0" title="0">o.instances[namespace][instance.ID] = instance</span>
}

// GetService gets a service from the fake storage
func (o *FakeOrchestrator) GetService(namespace, name string) (*types.Service, bool) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        nsServices, ok := o.services[namespace]
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">service, ok := nsServices[name]
        return service, ok</span>
}

// GetInstance gets an instance from the fake storage
func (o *FakeOrchestrator) GetInstance(namespace, id string) (*types.Instance, bool) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        nsInstances, ok := o.instances[namespace]
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">instance, ok := nsInstances[id]
        return instance, ok</span>
}

// ListServiceInstances gets all instances for a service
func (o *FakeOrchestrator) ListServiceInstances(namespace, serviceName string) []*types.Instance <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        var result []*types.Instance

        for _, nsInstances := range o.instances </span><span class="cov0" title="0">{
                for _, instance := range nsInstances </span><span class="cov0" title="0">{
                        if instance.Namespace == namespace &amp;&amp; instance.ServiceID == serviceName </span><span class="cov0" title="0">{
                                result = append(result, instance)
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// DeleteService removes a service from the fake storage
func (o *FakeOrchestrator) DeleteService(namespace, name string) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        nsServices, ok := o.services[namespace]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">delete(nsServices, name)</span>
}

// DeleteInstance removes an instance from the fake storage
func (o *FakeOrchestrator) DeleteInstance(namespace, id string) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        nsInstances, ok := o.instances[namespace]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">delete(nsInstances, id)</span>
}

// Reset resets the fake orchestrator's state
func (o *FakeOrchestrator) Reset() <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        o.started = false
        o.stopped = false
        o.services = make(map[string]map[string]*types.Service)
        o.instances = make(map[string]map[string]*types.Instance)
        o.StartCalls = nil
        o.StopCalls = nil
        o.GetServiceStatusCalls = nil
        o.GetInstanceStatusCalls = nil
        o.GetServiceLogsCalls = nil
        o.GetInstanceLogsCalls = nil
        o.ExecInServiceCalls = nil
        o.ExecInInstanceCalls = nil
        o.RestartServiceCalls = nil
        o.RestartInstanceCalls = nil
}</span>

// RestartService implementation for testing
func (o *FakeOrchestrator) RestartService(ctx context.Context, namespace, serviceName string) error <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        o.RestartServiceCalls = append(o.RestartServiceCalls, RestartServiceCall{
                Namespace:   namespace,
                ServiceName: serviceName,
        })

        if o.RestartServiceFunc != nil </span><span class="cov0" title="0">{
                return o.RestartServiceFunc(ctx, namespace, serviceName)
        }</span>

        <span class="cov0" title="0">if o.RestartServiceError != nil </span><span class="cov0" title="0">{
                return o.RestartServiceError
        }</span>

        // Default behavior - verify service exists first
        <span class="cov0" title="0">nsServices, ok := o.services[namespace]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("namespace %s not found", namespace)
        }</span>

        <span class="cov0" title="0">_, ok = nsServices[serviceName]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("service %s not found in namespace %s", serviceName, namespace)
        }</span>

        // Find all instances for this service and set them as "restarted"
        <span class="cov0" title="0">instanceCount := 0
        for _, nsInstances := range o.instances </span><span class="cov0" title="0">{
                for _, instance := range nsInstances </span><span class="cov0" title="0">{
                        if instance.Namespace == namespace &amp;&amp; instance.ServiceID == serviceName </span><span class="cov0" title="0">{
                                instance.Status = types.InstanceStatusRunning
                                instance.StatusMessage = "Restarted by fake orchestrator"
                                instanceCount++
                        }</span>
                }
        }

        <span class="cov0" title="0">if instanceCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no instances found for service %s in namespace %s", serviceName, namespace)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RestartInstance implementation for testing
func (o *FakeOrchestrator) RestartInstance(ctx context.Context, namespace, serviceName, instanceID string) error <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        o.RestartInstanceCalls = append(o.RestartInstanceCalls, OrchestratorRestartInstanceCall{
                Namespace:   namespace,
                ServiceName: serviceName,
                InstanceID:  instanceID,
        })

        if o.RestartInstanceFunc != nil </span><span class="cov0" title="0">{
                return o.RestartInstanceFunc(ctx, namespace, serviceName, instanceID)
        }</span>

        <span class="cov0" title="0">if o.RestartInstanceError != nil </span><span class="cov0" title="0">{
                return o.RestartInstanceError
        }</span>

        // Default behavior - verify instance exists
        <span class="cov0" title="0">nsInstances, ok := o.instances[namespace]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("namespace %s not found", namespace)
        }</span>

        <span class="cov0" title="0">instance, ok := nsInstances[instanceID]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("instance %s not found in namespace %s", instanceID, namespace)
        }</span>

        // Verify service association
        <span class="cov0" title="0">if instance.ServiceID != serviceName </span><span class="cov0" title="0">{
                return fmt.Errorf("instance %s does not belong to service %s", instanceID, serviceName)
        }</span>

        // "Restart" the instance in our fake store
        <span class="cov0" title="0">instance.Status = types.InstanceStatusRunning
        instance.StatusMessage = "Restarted by fake orchestrator"
        instance.UpdatedAt = time.Now()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package orchestrator

import (
        "context"
        "fmt"
        "net"
        "net/http"
        "sync"
        "time"

        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner"
        "github.com/rzbill/rune/pkg/runner/manager"
        "github.com/rzbill/rune/pkg/store"
        "github.com/rzbill/rune/pkg/types"
)

// HealthController monitors instance health
type HealthController interface {
        // Start the health controller
        Start(ctx context.Context) error

        // Stop the health controller
        Stop() error

        // AddInstance adds an instance to be monitored
        AddInstance(instance *types.Instance) error

        // RemoveInstance removes an instance from monitoring
        RemoveInstance(instanceID string) error

        // GetHealthStatus gets the current health status of an instance
        GetHealthStatus(ctx context.Context, instanceID string) (*InstanceHealthStatus, error)
}

// healthController implements the HealthController interface
type healthController struct {
        logger log.Logger

        // Monitored instances map
        instances map[string]*instanceHealth

        // Mutex for instances map
        mu sync.RWMutex

        // Context for background operations
        ctx    context.Context
        cancel context.CancelFunc

        // HTTP client for health checks
        client *http.Client

        // Wait group for checker goroutines
        wg sync.WaitGroup

        // Store to retrieve service definitions
        store store.Store

        // Runners for executing commands
        runnerManager manager.IRunnerManager

        // Instance controller for restarting instances
        instanceController InstanceController
}

// instanceHealth tracks health check state for an instance
type instanceHealth struct {
        instance            *types.Instance
        service             *types.Service
        livenessResults     []HealthCheckResult
        readinessResults    []HealthCheckResult
        livenessStatus      bool
        readinessStatus     bool
        lastCheck           time.Time
        consecutiveFailures int
        restartCount        int
        lastRestartTime     time.Time
        instanceController  InstanceController
}

// NewHealthController creates a new health controller
func NewHealthController(logger log.Logger, store store.Store, runnerManager manager.IRunnerManager) HealthController <span class="cov8" title="1">{
        return &amp;healthController{
                logger:    logger.WithComponent("health-controller"),
                instances: make(map[string]*instanceHealth),
                client: &amp;http.Client{
                        Timeout: 5 * time.Second,
                },
                store:         store,
                runnerManager: runnerManager,
        }
}</span>

// SetInstanceController sets the instance controller for restarting instances
func (c *healthController) SetInstanceController(controller InstanceController) <span class="cov8" title="1">{
        c.instanceController = controller
}</span>

// Start the health controller
func (c *healthController) Start(ctx context.Context) error <span class="cov8" title="1">{
        c.logger.Info("Starting health controller")

        // Create a context with cancel for all background operations
        c.ctx, c.cancel = context.WithCancel(ctx)

        return nil
}</span>

// Stop the health controller
func (c *healthController) Stop() error <span class="cov8" title="1">{
        c.logger.Info("Stopping health controller")

        // Cancel context to stop all operations
        if c.cancel != nil </span><span class="cov8" title="1">{
                c.cancel()
        }</span>

        // Wait for all goroutines to finish
        <span class="cov8" title="1">c.wg.Wait()

        return nil</span>
}

// AddInstance adds an instance to be monitored
func (c *healthController) AddInstance(instance *types.Instance) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.logger.Info("Adding instance to health monitoring",
                log.Str("instance", instance.ID))

        // Check if instance is already being monitored
        if _, exists := c.instances[instance.ID]; exists </span><span class="cov0" title="0">{
                c.logger.Debug("Instance already being monitored",
                        log.Str("instance", instance.ID))
                return nil
        }</span>

        // Get the service definition for this instance
        <span class="cov8" title="1">var service types.Service
        namespace := instance.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default" // Use default namespace as fallback
        }</span>

        // Fetch from the store using service ID
        <span class="cov8" title="1">err := c.store.Get(c.ctx, "services", namespace, instance.ServiceID, &amp;service)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to get service definition for health check",
                        log.Str("instance", instance.ID),
                        log.Str("service", instance.ServiceID),
                        log.Err(err))
                return fmt.Errorf("failed to get service definition for health check: %w", err)
        }</span>

        // Create a health state entry for the instance
        <span class="cov8" title="1">healthState := &amp;instanceHealth{
                instance:            instance,
                service:             &amp;service,
                livenessResults:     make([]HealthCheckResult, 0),
                readinessResults:    make([]HealthCheckResult, 0),
                lastCheck:           time.Now(),
                consecutiveFailures: 0,
                restartCount:        0,
                lastRestartTime:     time.Time{}, // Zero time represents no prior restarts
        }

        // If no health checks are configured, consider the instance healthy by default
        if service.Health == nil </span><span class="cov8" title="1">{
                c.logger.Debug("No health checks configured for service, marking as healthy by default",
                        log.Str("service", service.Name),
                        log.Str("instance", instance.ID))

                // Mark as healthy by default
                healthState.livenessStatus = true
                healthState.readinessStatus = true

                // Add instance to monitored instances
                c.instances[instance.ID] = healthState
                return nil
        }</span>

        // For instances with health checks, start as unhealthy until proven healthy
        <span class="cov8" title="1">healthState.livenessStatus = false
        healthState.readinessStatus = false

        // Add instance to monitored instances
        c.instances[instance.ID] = healthState

        // Start monitoring goroutine for this instance
        c.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer c.wg.Done()
                c.monitorInstance(instance.ID)
        }</span>()

        <span class="cov8" title="1">return nil</span>
}

// RemoveInstance removes an instance from monitoring
func (c *healthController) RemoveInstance(instanceID string) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.logger.Info("Removing instance from health monitoring",
                log.Str("instance", instanceID))

        // Check if instance is being monitored
        if _, exists := c.instances[instanceID]; !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Remove instance from monitored instances
        <span class="cov8" title="1">delete(c.instances, instanceID)

        return nil</span>
}

// GetHealthStatus gets the current health status of an instance
func (c *healthController) GetHealthStatus(ctx context.Context, instanceID string) (*InstanceHealthStatus, error) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        // Check if instance is being monitored
        ih, exists := c.instances[instanceID]
        if !exists </span><span class="cov8" title="1">{
                // Instead of returning an error, return a default healthy status
                // This means the instance doesn't have any health checks configured
                // or hasn't been added to monitoring yet
                c.logger.Debug("Instance not being monitored, returning default healthy status",
                        log.Str("instance", instanceID))

                return &amp;InstanceHealthStatus{
                        InstanceID:  instanceID,
                        Liveness:    true, // Default to healthy
                        Readiness:   true, // Default to ready
                        LastChecked: time.Now(),
                }, nil
        }</span>

        <span class="cov8" title="1">return &amp;InstanceHealthStatus{
                InstanceID:  instanceID,
                Liveness:    ih.livenessStatus,
                Readiness:   ih.readinessStatus,
                LastChecked: ih.lastCheck,
        }, nil</span>
}

// monitorInstance monitors the health of an instance
func (c *healthController) monitorInstance(instanceID string) <span class="cov8" title="1">{
        c.logger.Debug("Starting health monitoring for instance",
                log.Str("instance", instanceID))

        // Get instance state under read lock
        c.mu.RLock()
        ih, exists := c.instances[instanceID]
        if !exists </span><span class="cov8" title="1">{
                c.mu.RUnlock()
                c.logger.Error("Instance not found for monitoring, stopping", log.Str("instance", instanceID))
                return
        }</span>

        // Get health check configurations
        <span class="cov8" title="1">service := ih.service

        // If service has no health checks, we don't need to monitor it
        // (it's already marked as healthy in AddInstance)
        if service.Health == nil </span><span class="cov0" title="0">{
                c.mu.RUnlock()
                c.logger.Debug("Instance has no health checks configured, already marked healthy",
                        log.Str("instance", instanceID))
                return
        }</span>

        <span class="cov8" title="1">livenessProbe := service.Health.Liveness
        readinessProbe := service.Health.Readiness
        c.mu.RUnlock()

        // Configure check intervals with sensible defaults
        livenessInterval := 10 * time.Second
        readinessInterval := 10 * time.Second
        livenessInitialDelay := 0 * time.Second
        readinessInitialDelay := 0 * time.Second

        if livenessProbe != nil &amp;&amp; livenessProbe.IntervalSeconds &gt; 0 </span><span class="cov8" title="1">{
                livenessInterval = time.Duration(livenessProbe.IntervalSeconds) * time.Second
        }</span>
        <span class="cov8" title="1">if readinessProbe != nil &amp;&amp; readinessProbe.IntervalSeconds &gt; 0 </span><span class="cov0" title="0">{
                readinessInterval = time.Duration(readinessProbe.IntervalSeconds) * time.Second
        }</span>
        <span class="cov8" title="1">if livenessProbe != nil &amp;&amp; livenessProbe.InitialDelaySeconds &gt; 0 </span><span class="cov0" title="0">{
                livenessInitialDelay = time.Duration(livenessProbe.InitialDelaySeconds) * time.Second
        }</span>
        <span class="cov8" title="1">if readinessProbe != nil &amp;&amp; readinessProbe.InitialDelaySeconds &gt; 0 </span><span class="cov0" title="0">{
                readinessInitialDelay = time.Duration(readinessProbe.InitialDelaySeconds) * time.Second
        }</span>

        // Create tickers for each probe type
        <span class="cov8" title="1">var livenessTicker, readinessTicker *time.Ticker

        // Wait for initial delays before starting checks
        time.Sleep(livenessInitialDelay)
        livenessTicker = time.NewTicker(livenessInterval)

        if readinessProbe != nil </span><span class="cov0" title="0">{
                // Create a goroutine for readiness checks
                c.wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer c.wg.Done()
                        time.Sleep(readinessInitialDelay)
                        readinessTicker = time.NewTicker(readinessInterval)
                        defer readinessTicker.Stop()

                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-c.ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case &lt;-readinessTicker.C:<span class="cov0" title="0">
                                        if readinessProbe != nil </span><span class="cov0" title="0">{
                                                c.performHealthCheck(instanceID, readinessProbe, "readiness")
                                        }</span>
                                }
                        }
                }()
        }

        // Main goroutine for liveness checks
        <span class="cov8" title="1">defer livenessTicker.Stop()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-c.ctx.Done():<span class="cov8" title="1">
                        c.logger.Debug("Stopping health monitoring for instance",
                                log.Str("instance", instanceID))
                        return</span>
                case &lt;-livenessTicker.C:<span class="cov8" title="1">
                        if livenessProbe != nil </span><span class="cov8" title="1">{
                                c.performHealthCheck(instanceID, livenessProbe, "liveness")
                        }</span>
                }
        }
}

// performHealthCheck performs a health check for an instance
func (c *healthController) performHealthCheck(instanceID string, probe *types.Probe, checkType string) <span class="cov8" title="1">{
        start := time.Now()
        success := false
        message := ""

        // Get instance under read lock
        c.mu.RLock()
        ih, exists := c.instances[instanceID]
        if !exists </span><span class="cov0" title="0">{
                c.mu.RUnlock()
                return
        }</span>
        <span class="cov8" title="1">instance := ih.instance // We do need the instance for exec checks
        c.mu.RUnlock()

        // Determine endpoint for the check
        var endpoint string
        if probe.Port &gt; 0 </span><span class="cov8" title="1">{
                // In a real environment, we would get the actual IP of the instance
                // For now, assume we're using localhost for testing
                endpoint = fmt.Sprintf("http://localhost:%d", probe.Port)
        }</span>

        // Perform the appropriate check based on probe type
        <span class="cov8" title="1">switch probe.Type </span>{
        case "http":<span class="cov8" title="1">
                // HTTP check
                url := fmt.Sprintf("%s%s", endpoint, probe.Path)
                req, err := http.NewRequestWithContext(c.ctx, "GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        message = fmt.Sprintf("Failed to create HTTP request: %v", err)
                        break</span>
                }

                <span class="cov8" title="1">resp, err := c.client.Do(req)
                if err != nil </span><span class="cov8" title="1">{
                        message = fmt.Sprintf("HTTP health check failed: %v", err)
                        break</span>
                }
                <span class="cov8" title="1">defer resp.Body.Close()

                // Check for successful status code (200-399)
                if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 400 </span><span class="cov8" title="1">{
                        success = true
                        message = fmt.Sprintf("HTTP health check succeeded with status %d", resp.StatusCode)
                }</span> else<span class="cov0" title="0"> {
                        message = fmt.Sprintf("HTTP health check returned non-success status %d", resp.StatusCode)
                }</span>

        case "tcp":<span class="cov8" title="1">
                // TCP check
                conn, err := net.DialTimeout("tcp", fmt.Sprintf("localhost:%d", probe.Port), 5*time.Second)
                if err != nil </span><span class="cov0" title="0">{
                        message = fmt.Sprintf("TCP health check failed: %v", err)
                        break</span>
                }
                <span class="cov8" title="1">defer conn.Close()

                success = true
                message = "TCP health check succeeded"</span>

        case "exec":<span class="cov8" title="1">
                // Exec check - execute a command in the instance using the appropriate runner
                if len(probe.Command) == 0 </span><span class="cov0" title="0">{
                        message = "Exec health check failed: no command specified"
                        break</span>
                }

                // Determine which runner to use based on the instance's runtime
                <span class="cov8" title="1">var activeRunner runner.Runner

                // In a production environment, we would determine the correct runner
                // based on the instance's type. For simplicity, try both runners.
                _runner, err := c.runnerManager.GetInstanceRunner(instance)
                if err != nil </span><span class="cov0" title="0">{
                        message = fmt.Sprintf("Exec health check failed to get runner: %v", err)
                        break</span>
                }
                <span class="cov8" title="1">activeRunner = _runner

                // Execute the command
                execOpts := runner.GetExecOptions(probe.Command, instance)
                execStream, err := activeRunner.Exec(c.ctx, instance, execOpts)
                if err != nil </span><span class="cov0" title="0">{
                        message = fmt.Sprintf("Exec health check failed to start command: %v", err)
                        break</span>
                }
                <span class="cov8" title="1">defer execStream.Close()

                // Wait for command completion and check exit code
                exitCode, err := execStream.ExitCode()
                if err != nil </span><span class="cov8" title="1">{
                        message = fmt.Sprintf("Exec health check failed to get exit code: %v", err)
                        break</span>
                }

                <span class="cov0" title="0">if exitCode == 0 </span><span class="cov0" title="0">{
                        success = true
                        message = "Exec health check succeeded with exit code 0"
                }</span> else<span class="cov0" title="0"> {
                        message = fmt.Sprintf("Exec health check failed with exit code %d", exitCode)
                }</span>

        default:<span class="cov8" title="1">
                message = fmt.Sprintf("Unknown health check type: %s", probe.Type)</span>
        }

        // Record the result
        <span class="cov8" title="1">duration := time.Since(start)
        result := HealthCheckResult{
                Success:    success,
                Message:    message,
                Duration:   duration,
                CheckTime:  time.Now(),
                InstanceID: instanceID,
                CheckType:  checkType,
        }

        // Update instance health status
        c.mu.Lock()
        defer c.mu.Unlock()

        // Check if instance still exists
        ih, exists = c.instances[instanceID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        // Update status based on check type
        <span class="cov8" title="1">if checkType == "liveness" </span><span class="cov8" title="1">{
                ih.livenessResults = append(ih.livenessResults, result)
                if len(ih.livenessResults) &gt; 10 </span><span class="cov0" title="0">{
                        ih.livenessResults = ih.livenessResults[1:]
                }</span>

                // Update liveness status based on success
                <span class="cov8" title="1">ih.livenessStatus = success

                // Log the result
                if success </span><span class="cov8" title="1">{
                        c.logger.Debug("Liveness check passed",
                                log.Str("instance", instanceID),
                                log.Duration("duration", duration))

                        // Reset failure counter on success
                        ih.consecutiveFailures = 0
                }</span> else<span class="cov8" title="1"> {
                        // Increment consecutive failures counter
                        ih.consecutiveFailures++

                        c.logger.Warn("Liveness check failed",
                                log.Str("instance", instanceID),
                                log.Str("message", message),
                                log.Int("consecutive_failures", ih.consecutiveFailures),
                                log.Duration("duration", duration))

                        // Trigger a restart if we have had enough failures
                        // (typically 3-5 consecutive failures)
                        if ih.consecutiveFailures &gt;= 3 </span><span class="cov8" title="1">{
                                if err := c.restartInstanceWithBackoff(instanceID, ih); err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error("Failed to restart unhealthy instance",
                                                log.Str("instance", instanceID),
                                                log.Err(err))
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> if checkType == "readiness" </span><span class="cov0" title="0">{
                ih.readinessResults = append(ih.readinessResults, result)
                if len(ih.readinessResults) &gt; 10 </span><span class="cov0" title="0">{
                        ih.readinessResults = ih.readinessResults[1:]
                }</span>

                // Update readiness status based on success
                <span class="cov0" title="0">ih.readinessStatus = success

                // Log the result
                if success </span><span class="cov0" title="0">{
                        c.logger.Debug("Readiness check passed",
                                log.Str("instance", instanceID),
                                log.Duration("duration", duration))
                }</span> else<span class="cov0" title="0"> {
                        c.logger.Warn("Readiness check failed",
                                log.Str("instance", instanceID),
                                log.Str("message", message),
                                log.Duration("duration", duration))
                }</span>
        }

        <span class="cov8" title="1">ih.lastCheck = time.Now()</span>
}

// restartInstanceWithBackoff restarts an instance with exponential backoff
func (c *healthController) restartInstanceWithBackoff(instanceID string, ih *instanceHealth) error <span class="cov8" title="1">{
        // Check if we have an instance controller
        if c.instanceController == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot restart instance, no instance controller available")
        }</span>

        // Get the current time
        <span class="cov8" title="1">now := time.Now()

        // Calculate the backoff duration based on restart count
        // Base backoff is 10 seconds, doubles each restart up to a max of 5 minutes
        backoff := 10 * time.Second * time.Duration(1&lt;&lt;uint(ih.restartCount))
        maxBackoff := 5 * time.Minute
        if backoff &gt; maxBackoff </span><span class="cov0" title="0">{
                backoff = maxBackoff
        }</span>

        // Check if enough time has elapsed since the last restart
        <span class="cov8" title="1">if !ih.lastRestartTime.IsZero() &amp;&amp; now.Sub(ih.lastRestartTime) &lt; backoff </span><span class="cov0" title="0">{
                // Not enough time has elapsed, skip this restart
                return fmt.Errorf("skipping restart due to backoff, next eligible in %v",
                        backoff-(now.Sub(ih.lastRestartTime)))
        }</span>

        // Log the restart attempt
        <span class="cov8" title="1">c.logger.Info("Restarting unhealthy instance",
                log.Str("instance", instanceID),
                log.Int("restart_count", ih.restartCount+1),
                log.Duration("backoff", backoff))

        // Get the instance
        instance := ih.instance
        if instance == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("instance is nil, cannot restart")
        }</span>

        // Use the instance controller to handle the restart
        <span class="cov8" title="1">if err := c.instanceController.RestartInstance(c.ctx, instance, InstanceRestartReasonHealthCheckFailure); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restart instance: %w", err)
        }</span>

        // Update restart metrics
        <span class="cov8" title="1">ih.restartCount++
        ih.lastRestartTime = now
        ih.consecutiveFailures = 0 // Reset failures after restart

        c.logger.Info("Instance restart initiated successfully",
                log.Str("instance", instanceID),
                log.Int("restart_count", ih.restartCount))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package orchestrator

import (
        "context"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner"
        "github.com/rzbill/rune/pkg/runner/manager"
        "github.com/rzbill/rune/pkg/store"
        "github.com/rzbill/rune/pkg/types"
)

type InstanceRestartReason string

const (
        InstanceRestartReasonManual             InstanceRestartReason = "manual"
        InstanceRestartReasonHealthCheckFailure InstanceRestartReason = "health-check-failure"
        InstanceRestartReasonUpdate             InstanceRestartReason = "update"
        InstanceRestartReasonFailure            InstanceRestartReason = "failure"
)

// InstanceController manages instance lifecycle
type InstanceController interface {
        // CreateInstance creates a new instance for a service
        CreateInstance(ctx context.Context, service *types.Service, instanceName string) (*types.Instance, error)

        // RecreateInstance recreates an instance
        RecreateInstance(ctx context.Context, service *types.Service, instance *types.Instance) (*types.Instance, error)

        // UpdateInstance updates an existing instance
        UpdateInstance(ctx context.Context, service *types.Service, instance *types.Instance) error

        // DeleteInstance removes an instance
        DeleteInstance(ctx context.Context, instance *types.Instance) error

        // GetInstanceStatus gets the current status of an instance
        GetInstanceStatus(ctx context.Context, instance *types.Instance) (*InstanceStatusInfo, error)

        // GetInstanceLogs gets logs for an instance
        GetInstanceLogs(ctx context.Context, instance *types.Instance, opts LogOptions) (io.ReadCloser, error)

        // RestartInstance restarts an instance with respect to the service's restart policy
        RestartInstance(ctx context.Context, instance *types.Instance, reason InstanceRestartReason) error

        // Exec executes a command in a running instance
        // Returns an ExecStream for bidirectional communication
        Exec(ctx context.Context, instance *types.Instance, options ExecOptions) (ExecStream, error)
}

// instanceController implements the InstanceController interface
type instanceController struct {
        store         store.Store
        runnerManager manager.IRunnerManager
        logger        log.Logger
}

// NewInstanceController creates a new instance controller
func NewInstanceController(store store.Store, runnerManager manager.IRunnerManager, logger log.Logger) InstanceController <span class="cov8" title="1">{
        return &amp;instanceController{
                store:         store,
                runnerManager: runnerManager,
                logger:        logger.WithComponent("instance-controller"),
        }
}</span>

// CreateInstance creates a new instance for a service
// This would be simplified to only handle the pure creation case
func (c *instanceController) CreateInstance(ctx context.Context, service *types.Service, instanceName string) (*types.Instance, error) <span class="cov8" title="1">{
        c.logger.Info("Creating new instance",
                log.Str("service", service.Name),
                log.Str("namespace", service.Namespace),
                log.Str("instance", instanceName))

        // Create instance object
        instance := &amp;types.Instance{
                ID:          uuid.New().String(),
                Name:        instanceName,
                Namespace:   service.Namespace,
                ServiceName: service.Name,
                ServiceID:   service.ID,
                NodeID:      "local",
                Status:      types.InstanceStatusPending,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        // Save instance to store
        if err := c.store.Create(ctx, types.ResourceTypeInstance, service.Namespace, instance.ID, instance); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create instance in store: %w", err)
        }</span>

        // Create instance based on runtime
        <span class="cov8" title="1">serviceRunner, err := c.runnerManager.GetServiceRunner(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get runner for service: %w", err)
        }</span>

        // Set the runner type for the instance
        <span class="cov8" title="1">instance.Runner = serviceRunner.Type()

        // Build environment variables using the proper function from envvar.go
        envVars := buildEnvVars(service, instance)
        c.logger.Debug("Prepared environment variables",
                log.Str("instance", instanceName),
                log.Int("env_var_count", len(envVars)))

        // Set environment variables in the instance
        instance.Environment = envVars

        // Store original image for future compatibility checks
        if service.Image != "" </span><span class="cov8" title="1">{
                if instance.Environment == nil </span><span class="cov0" title="0">{
                        instance.Environment = make(map[string]string)
                }</span>
                <span class="cov8" title="1">instance.Environment["RUNE_ORIGINAL_IMAGE"] = service.Image</span>
        }

        // Update instance with pending status
        <span class="cov8" title="1">instance.Status = types.InstanceStatusStarting
        if err := c.store.Update(ctx, types.ResourceTypeInstance, service.Namespace, instance.ID, instance); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to update instance status",
                        log.Str("instance", instance.ID),
                        log.Err(err))
        }</span>

        // Create the instance using the runner
        <span class="cov8" title="1">if err := serviceRunner.Create(ctx, instance); err != nil </span><span class="cov0" title="0">{
                instance.Status = types.InstanceStatusFailed
                if updateErr := c.store.Update(ctx, types.ResourceTypeInstance, instance.Namespace, instance.ID, instance); updateErr != nil </span><span class="cov0" title="0">{
                        c.logger.Error("Failed to update instance status after create failure",
                                log.Str("instance", instance.ID),
                                log.Err(updateErr))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to create instance: %w", err)</span>
        }

        // Start the instance
        <span class="cov8" title="1">if err := serviceRunner.Start(ctx, instance); err != nil </span><span class="cov0" title="0">{
                instance.Status = types.InstanceStatusFailed
                if updateErr := c.store.Update(ctx, types.ResourceTypeInstance, instance.Namespace, instance.ID, instance); updateErr != nil </span><span class="cov0" title="0">{
                        c.logger.Error("Failed to update instance status after start failure",
                                log.Str("instance", instance.ID),
                                log.Err(updateErr))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to start instance: %w", err)</span>
        }

        // Update instance with running status
        <span class="cov8" title="1">instance.Status = types.InstanceStatusRunning
        instance.StatusMessage = "Created successfully"
        if err := c.store.Update(ctx, types.ResourceTypeInstance, service.Namespace, instance.ID, instance); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to update instance status",
                        log.Str("instance", instance.ID),
                        log.Err(err))
        }</span>

        <span class="cov8" title="1">return instance, nil</span>
}

// RecreateInstance destroys an existing instance and creates a new one with the same name
func (c *instanceController) RecreateInstance(ctx context.Context, service *types.Service, existingInstance *types.Instance) (*types.Instance, error) <span class="cov0" title="0">{
        instanceName := existingInstance.Name
        c.logger.Info("Recreating instance",
                log.Str("service", service.Name),
                log.Str("namespace", service.Namespace),
                log.Str("instance", instanceName))

        // Delete the existing instance
        if err := c.DeleteInstance(ctx, existingInstance); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete instance for recreation: %w", err)
        }</span>

        // Create a new instance
        <span class="cov0" title="0">return c.CreateInstance(ctx, service, instanceName)</span>
}

// UpdateInstance updates an existing instance
func (c *instanceController) UpdateInstance(ctx context.Context, service *types.Service, instance *types.Instance) error <span class="cov8" title="1">{
        c.logger.Debug("Checking instance for updates",
                log.Str("instance", instance.ID),
                log.Str("service", service.Name))

        // Get current runner for this instance
        runner, err := c.runnerManager.GetInstanceRunner(instance)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get runner for instance: %w", err)
        }</span>

        // Check if the instance is compatible with the current service definition
        <span class="cov8" title="1">isCompatible, reason := c.isInstanceCompatibleWithService(ctx, instance, service)
        if !isCompatible </span><span class="cov8" title="1">{
                c.logger.Info("Instance is not compatible with current service definition, recreation required",
                        log.Str("instance", instance.ID),
                        log.Str("service", service.Name),
                        log.Str("reason", reason))

                // For now, we'll stop and return an error indicating that recreation is needed
                // The caller should handle the recreation
                return fmt.Errorf("instance %s requires recreation to update: %s", instance.ID, reason)
        }</span>

        // For compatible instances, we can apply in-place updates
        // First check if instance is running
        <span class="cov8" title="1">status, err := runner.Status(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get instance status: %w", err)
        }</span>

        // Check if the instance is in a state that can be updated
        <span class="cov8" title="1">if status != types.InstanceStatusRunning </span><span class="cov0" title="0">{
                c.logger.Info("Instance is not in a state that can be updated in-place",
                        log.Str("instance", instance.ID),
                        log.Str("currentStatus", string(status)))
                return fmt.Errorf("instance %s is in state %s and cannot be updated in-place", instance.ID, status)
        }</span>

        // Apply updates to the instance object
        <span class="cov8" title="1">instanceUpdated := false

        // Update environment variables (only adding/modifying, not removing)
        envVarsUpdated := false
        envVars := buildEnvVars(service, instance)
        for key, value := range envVars </span><span class="cov8" title="1">{
                // Skip internal RUNE environment variables for comparison
                if len(key) &gt; 5 &amp;&amp; key[:5] == "RUNE_" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check if this is a new or changed env var
                <span class="cov8" title="1">currentValue, exists := instance.Environment[key]
                if !exists || currentValue != value </span><span class="cov8" title="1">{
                        if instance.Environment == nil </span><span class="cov0" title="0">{
                                instance.Environment = make(map[string]string)
                        }</span>
                        <span class="cov8" title="1">instance.Environment[key] = value
                        envVarsUpdated = true</span>
                }
        }

        <span class="cov8" title="1">if envVarsUpdated </span><span class="cov8" title="1">{
                c.logger.Debug("Environment variables updated",
                        log.Str("instance", instance.ID))
                instanceUpdated = true
        }</span>

        // Update status message if needed
        <span class="cov8" title="1">if instance.StatusMessage == "" || instance.StatusMessage == "Created" </span><span class="cov8" title="1">{
                instance.StatusMessage = "Updated"
                instanceUpdated = true
        }</span>

        // Update timestamp
        <span class="cov8" title="1">instance.UpdatedAt = time.Now()
        instanceUpdated = true

        // If we've made any updates to the instance object, save it back to the store
        if instanceUpdated </span><span class="cov8" title="1">{
                if err := c.store.Update(ctx, types.ResourceTypeInstance, instance.Namespace, instance.ID, instance); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update instance in store: %w", err)
                }</span>
                <span class="cov8" title="1">c.logger.Info("Instance updated successfully",
                        log.Str("instance", instance.ID),
                        log.Str("service", service.Name))</span>
        } else<span class="cov0" title="0"> {
                c.logger.Debug("No changes needed for instance",
                        log.Str("instance", instance.ID))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DeleteInstance removes an instance
func (c *instanceController) DeleteInstance(ctx context.Context, instance *types.Instance) error <span class="cov8" title="1">{
        c.logger.Info("Deleting instance",
                log.Str("instance", instance.ID))

        c.logger.Info("deleting instance", log.Json("instance", instance))

        runner, err := c.runnerManager.GetInstanceRunner(instance)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get runner for instance: %w", err)
        }</span>

        // Track failures separately for better error reporting
        <span class="cov8" title="1">failedToStop := false
        failedToRemove := false

        // Try to stop and remove with runner
        if err := runner.Stop(ctx, instance, 10*time.Second); err != nil </span><span class="cov0" title="0">{
                c.logger.Debug("Failed to stop instance with runner",
                        log.Str("instance", instance.ID),
                        log.Err(err))
                failedToStop = true
        }</span>

        <span class="cov8" title="1">if err := runner.Remove(ctx, instance, true); err != nil </span><span class="cov0" title="0">{
                c.logger.Debug("Failed to remove instance with runner",
                        log.Str("instance", instance.ID),
                        log.Err(err))
                failedToRemove = true
        }</span>

        // If both operations failed, return a more descriptive error
        <span class="cov8" title="1">if failedToStop &amp;&amp; failedToRemove </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to both stop and remove instance")
        }</span>

        <span class="cov8" title="1">if failedToStop </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop instance")
        }</span>

        <span class="cov8" title="1">if failedToRemove </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove instance")
        }</span>

        <span class="cov8" title="1">c.logger.Info("instance deleted successfully", log.Json("instance", instance))

        // Update instance status in store
        instance.Status = types.InstanceStatusStopped
        if err := c.store.Update(ctx, types.ResourceTypeInstance, instance.Namespace, instance.ID, instance); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to update instance status",
                        log.Str("instance", instance.ID),
                        log.Err(err))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetInstanceStatus gets the current status of an instance
func (c *instanceController) GetInstanceStatus(ctx context.Context, instance *types.Instance) (*InstanceStatusInfo, error) <span class="cov8" title="1">{
        // For now, we'll try to get status from both runners and use the first one that succeeds
        runner, err := c.runnerManager.GetInstanceRunner(instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get runner for instance: %w", err)
        }</span>

        <span class="cov8" title="1">status, err := runner.Status(ctx, instance)
        if err == nil </span><span class="cov8" title="1">{
                // Assuming Status returns a string representing the state
                return &amp;InstanceStatusInfo{
                        State:      status,
                        InstanceID: instance.ID,
                        NodeID:     instance.NodeID,
                        CreatedAt:  instance.CreatedAt,
                }, nil
        }</span>

        // If runner failed, return the instance status from the store
        <span class="cov0" title="0">return &amp;InstanceStatusInfo{
                State:      instance.Status,
                InstanceID: instance.ID,
                NodeID:     instance.NodeID,
                CreatedAt:  instance.CreatedAt,
        }, nil</span>
}

// GetInstanceLogs gets logs for an instance
func (c *instanceController) GetInstanceLogs(ctx context.Context, instance *types.Instance, opts LogOptions) (io.ReadCloser, error) <span class="cov8" title="1">{
        // Try to get logs from both runners and use the first one that succeeds
        _runner, err := c.runnerManager.GetInstanceRunner(instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get runner for instance: %w", err)
        }</span>

        <span class="cov8" title="1">logs, err := _runner.GetLogs(ctx, instance, runner.LogOptions{
                Follow:     opts.Follow,
                Since:      opts.Since,
                Until:      opts.Until,
                Tail:       opts.Tail,
                Timestamps: opts.Timestamps,
        })
        if err == nil </span><span class="cov8" title="1">{
                return logs, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("failed to get logs for instance %s: %w", instance.ID, err)</span>
}

// Exec executes a command in a running instance
func (c *instanceController) Exec(ctx context.Context, instance *types.Instance, options ExecOptions) (ExecStream, error) <span class="cov8" title="1">{
        c.logger.Debug("Executing command in instance",
                log.Str("instance", instance.ID),
                log.Str("command", strings.Join(options.Command, " ")))

        // Get runner for the instance
        _runner, err := c.runnerManager.GetInstanceRunner(instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get runner for instance: %w", err)
        }</span>

        // Convert orchestrator exec options to runner exec options
        <span class="cov8" title="1">runnerOptions := runner.ExecOptions{
                Command:        options.Command,
                Env:            options.Env,
                WorkingDir:     options.WorkingDir,
                TTY:            options.TTY,
                TerminalWidth:  options.TerminalWidth,
                TerminalHeight: options.TerminalHeight,
        }

        // Create exec session with the runner
        execStream, err := _runner.Exec(ctx, instance, runnerOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute command in instance %s: %w", instance.ID, err)
        }</span>

        <span class="cov8" title="1">return execStreamAdapter{execStream}, nil</span>
}

// execStreamAdapter adapts runner.ExecStream to orchestrator.ExecStream
type execStreamAdapter struct {
        runner.ExecStream
}

// buildEnvVars prepares environment variables for an instance
func buildEnvVars(service *types.Service, instance *types.Instance) map[string]string <span class="cov8" title="1">{
        envVars := make(map[string]string)

        // Add service-defined environment variables
        for key, value := range service.Env </span><span class="cov8" title="1">{
                envVars[key] = value
        }</span>

        // Add built-in environment variables
        <span class="cov8" title="1">envVars["RUNE_SERVICE_NAME"] = service.Name
        envVars["RUNE_SERVICE_NAMESPACE"] = service.Namespace
        envVars["RUNE_INSTANCE_ID"] = instance.ID

        return envVars</span>
}

// RestartInstance restarts an instance with respect to the service's restart policy
func (c *instanceController) RestartInstance(ctx context.Context, instance *types.Instance, reason InstanceRestartReason) error <span class="cov8" title="1">{
        c.logger.Info("Restarting instance",
                log.Str("instance", instance.ID),
                log.Str("reason", string(reason)))

        // Get the service to check its restart policy
        var service types.Service
        if err := c.store.Get(ctx, types.ResourceTypeService, instance.Namespace, instance.ServiceID, &amp;service); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get service for restart policy: %w", err)
        }</span>

        // Manual restarts always override any policy
        <span class="cov8" title="1">if reason == InstanceRestartReasonManual </span><span class="cov8" title="1">{
                c.logger.Info("Manual restart requested, overriding restart policy",
                        log.Str("instance", instance.ID))
        }</span> else<span class="cov8" title="1"> {
                // Check restart policy for non-manual restarts
                restartPolicy := types.RestartPolicyAlways // Default to Always
                if service.RestartPolicy != "" </span><span class="cov8" title="1">{
                        restartPolicy = service.RestartPolicy
                }</span>

                // Implement restart policy
                <span class="cov8" title="1">switch restartPolicy </span>{
                case types.RestartPolicyNever:<span class="cov8" title="1">
                        // No automatic restarts allowed
                        c.logger.Info("Skipping restart due to 'Never' policy",
                                log.Str("instance", instance.ID),
                                log.Str("reason", string(reason)))
                        return nil</span>

                case types.RestartPolicyOnFailure:<span class="cov8" title="1">
                        // Only restart if the reason is a failure or health check issue
                        isFailureRelated := reason == InstanceRestartReasonFailure || reason == InstanceRestartReasonHealthCheckFailure
                        if !isFailureRelated </span><span class="cov8" title="1">{
                                c.logger.Info("Skipping restart due to 'OnFailure' policy with non-failure reason",
                                        log.Str("instance", instance.ID),
                                        log.Str("reason", string(reason)))
                                return nil
                        }</span>
                }
        }

        // Get the appropriate runner
        <span class="cov8" title="1">runner, err := c.runnerManager.GetInstanceRunner(instance)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get runner for restart: %w", err)
        }</span>

        // Update instance status to restarting
        <span class="cov8" title="1">instance.Status = types.InstanceStatusStarting
        instance.StatusMessage = fmt.Sprintf("Restarting due to: %s", reason)
        instance.UpdatedAt = time.Now()

        if err := c.store.Update(ctx, types.ResourceTypeInstance, instance.Namespace, instance.ID, instance); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to update instance status before restart",
                        log.Str("instance", instance.ID),
                        log.Err(err))
                // Continue anyway
        }</span>

        // Stop the instance first
        <span class="cov8" title="1">stopTimeout := 10 * time.Second
        if err := runner.Stop(ctx, instance, stopTimeout); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("Failed to stop instance gracefully, will force restart",
                        log.Str("instance", instance.ID),
                        log.Err(err))

                // Try to forcefully remove if stop fails
                if err := runner.Remove(ctx, instance, true); err != nil </span><span class="cov0" title="0">{
                        c.logger.Error("Failed to remove instance during restart",
                                log.Str("instance", instance.ID),
                                log.Err(err))
                        // Continue anyway
                }</span>
        }

        // Create the instance again
        <span class="cov8" title="1">if err := runner.Create(ctx, instance); err != nil </span><span class="cov0" title="0">{
                instance.Status = types.InstanceStatusFailed
                instance.StatusMessage = fmt.Sprintf("Failed to recreate: %v", err)
                if updateErr := c.store.Update(ctx, types.ResourceTypeInstance, instance.Namespace, instance.ID, instance); updateErr != nil </span><span class="cov0" title="0">{
                        c.logger.Error("Failed to update instance status after create failure",
                                log.Str("instance", instance.ID),
                                log.Err(updateErr))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to recreate instance: %w", err)</span>
        }

        // Start the instance
        <span class="cov8" title="1">if err := runner.Start(ctx, instance); err != nil </span><span class="cov0" title="0">{
                instance.Status = types.InstanceStatusFailed
                instance.StatusMessage = fmt.Sprintf("Failed to start: %v", err)
                if updateErr := c.store.Update(ctx, types.ResourceTypeInstance, instance.Namespace, instance.ID, instance); updateErr != nil </span><span class="cov0" title="0">{
                        c.logger.Error("Failed to update instance status after start failure",
                                log.Str("instance", instance.ID),
                                log.Err(updateErr))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to start instance: %w", err)</span>
        }

        // Update instance with running status
        <span class="cov8" title="1">instance.Status = types.InstanceStatusRunning
        instance.StatusMessage = "Restarted successfully"
        instance.UpdatedAt = time.Now()

        if err := c.store.Update(ctx, types.ResourceTypeInstance, instance.Namespace, instance.ID, instance); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to update instance status after restart",
                        log.Str("instance", instance.ID),
                        log.Err(err))
        }</span>

        <span class="cov8" title="1">c.logger.Info("Instance restarted successfully",
                log.Str("instance", instance.ID))

        return nil</span>
}

// isInstanceCompatibleWithService checks if an instance is compatible with a service
func (c *instanceController) isInstanceCompatibleWithService(ctx context.Context, instance *types.Instance, service *types.Service) (bool, string) <span class="cov8" title="1">{
        // Check if the instance belongs to the correct service
        if instance.ServiceID != service.ID </span><span class="cov0" title="0">{
                return false, "instance belongs to different service"
        }</span>

        // Check if the instance is in a failed state
        <span class="cov8" title="1">if instance.Status == types.InstanceStatusFailed ||
                instance.Status == types.InstanceStatusExited ||
                instance.Status == types.InstanceStatusUnknown </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("instance is in failed state: %s", string(instance.Status))
        }</span>

        // Get the current runner for the instance
        <span class="cov8" title="1">runner, err := c.runnerManager.GetInstanceRunner(instance)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("failed to get runner: %v", err)
        }</span>

        // Check if the instance still exists in the runner
        <span class="cov8" title="1">status, err := runner.Status(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("instance not found in runner: %v", err)
        }</span>

        // If instance exists but is in a terminal state, it's incompatible
        <span class="cov8" title="1">if status == types.InstanceStatusExited || status == types.InstanceStatusFailed </span><span class="cov0" title="0">{
                return false, "instance is in terminal state in the runner"
        }</span>

        // For Docker-based instances, perform additional checks
        <span class="cov8" title="1">if instance.ContainerID != "" &amp;&amp; service.Runtime == "docker" </span><span class="cov8" title="1">{
                // Check if image has changed
                // This would require the Instance to store the image it was created with
                if instance.Environment != nil </span><span class="cov8" title="1">{
                        // Look for stored image information in the environment
                        if originalImage, ok := instance.Environment["RUNE_ORIGINAL_IMAGE"]; ok </span><span class="cov8" title="1">{
                                if originalImage != service.Image </span><span class="cov8" title="1">{
                                        return false, fmt.Sprintf("image changed: %s -&gt; %s", originalImage, service.Image)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // If we can't determine the original image, be cautious and recreate
                                c.logger.Debug("Cannot determine original image for instance, assuming incompatible")
                                return false, "cannot determine original image"
                        }</span>
                }

                // Check for significant resource changes
                <span class="cov0" title="0">if service.Resources.CPU.Limit != "" || service.Resources.Memory.Limit != "" </span><span class="cov0" title="0">{
                        // If instance doesn't have resources configured but service does
                        if instance.Resources == nil ||
                                (instance.Resources.CPU.Limit != service.Resources.CPU.Limit) ||
                                (instance.Resources.Memory.Limit != service.Resources.Memory.Limit) </span><span class="cov0" title="0">{
                                return false, "resource requirements changed"
                        }</span>
                }

                // Check for port mapping changes
                // This is more complex and would need to compare port configurations

                // Check for significant environment changes
                // Partial environment changes might be fine, but essential vars should match
                <span class="cov0" title="0">if service.Env != nil &amp;&amp; len(service.Env) &gt; 0 </span><span class="cov0" title="0">{
                        for key, value := range service.Env </span><span class="cov0" title="0">{
                                // Skip RUNE internal environment variables
                                if len(key) &gt; 5 &amp;&amp; key[:5] == "RUNE_" </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">instanceValue, exists := instance.Environment[key]
                                if !exists || instanceValue != value </span><span class="cov0" title="0">{
                                        return false, fmt.Sprintf("environment variable %s changed or missing", key)
                                }</span>
                        }
                }
        }

        // For process-based instances, perform process-specific checks
        <span class="cov8" title="1">if instance.PID != 0 &amp;&amp; service.Runtime == "process" </span><span class="cov0" title="0">{
                // Check command consistency
                if instance.Process != nil &amp;&amp; service.Process != nil </span><span class="cov0" title="0">{
                        if instance.Process.Command != service.Process.Command ||
                                !areStringSlicesEqual(instance.Process.Args, service.Process.Args) </span><span class="cov0" title="0">{
                                return false, "process command or arguments changed"
                        }</span>

                        // Check for working directory changes
                        <span class="cov0" title="0">if instance.Process.WorkingDir != service.Process.WorkingDir </span><span class="cov0" title="0">{
                                return false, "process working directory changed"
                        }</span>
                }
        }

        // If we get here, the instance is compatible
        <span class="cov8" title="1">return true, ""</span>
}

// areStringSlicesEqual checks if two string slices are equal
func areStringSlicesEqual(a, b []string) bool <span class="cov0" title="0">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for i, v := range a </span><span class="cov0" title="0">{
                if v != b[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package orchestrator

import (
        "bytes"
        "fmt"
        "io"
        "sync"
        "time"
)

// MultiLogStreamer combines log streams from multiple instances into a single stream
type MultiLogStreamer struct {
        readers  []io.ReadCloser
        buffer   *bytes.Buffer
        bufMu    sync.Mutex
        closed   bool
        closeMu  sync.Mutex
        done     chan struct{}
        wg       sync.WaitGroup
        metadata bool
}

// InstanceLogInfo associates an instance ID with its log reader
type InstanceLogInfo struct {
        InstanceID string
        Reader     io.ReadCloser
}

// NewMultiLogStreamer creates a new MultiLogStreamer that combines log streams from multiple instances
func NewMultiLogStreamer(instances []InstanceLogInfo, includeMetadata bool) *MultiLogStreamer <span class="cov0" title="0">{
        m := &amp;MultiLogStreamer{
                readers:  make([]io.ReadCloser, len(instances)),
                buffer:   bytes.NewBuffer(nil),
                done:     make(chan struct{}),
                metadata: includeMetadata,
        }

        // Extract readers for internal tracking and store instance IDs
        instanceIDs := make([]string, len(instances))
        for i, info := range instances </span><span class="cov0" title="0">{
                m.readers[i] = info.Reader
                instanceIDs[i] = info.InstanceID
        }</span>

        // Start a goroutine for each reader
        <span class="cov0" title="0">for i, reader := range m.readers </span><span class="cov0" title="0">{
                m.wg.Add(1)
                instanceID := instanceIDs[i]
                go m.collectLogs(reader, instanceID)
        }</span>

        // Start a goroutine to close the streamer when all collectors are done
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                m.wg.Wait()
                close(m.done)
        }</span>()

        <span class="cov0" title="0">return m</span>
}

// collectLogs reads from a reader and writes to the buffer with instance metadata
func (m *MultiLogStreamer) collectLogs(reader io.ReadCloser, instanceID string) <span class="cov0" title="0">{
        defer m.wg.Done()
        defer reader.Close()

        buf := make([]byte, 4096)
        lineBuffer := make([]byte, 0, 4096)

        for </span><span class="cov0" title="0">{
                n, err := reader.Read(buf)
                if n &gt; 0 </span><span class="cov0" title="0">{
                        m.bufMu.Lock()

                        // Process the buffer line by line to add metadata at the beginning of each line
                        if m.metadata </span><span class="cov0" title="0">{
                                data := buf[:n]
                                for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                        lineBuffer = append(lineBuffer, data[i])

                                        // If we have a full line or this is the last chunk of data
                                        if data[i] == '\n' || (err == io.EOF &amp;&amp; i == n-1) </span><span class="cov0" title="0">{
                                                timestamp := time.Now().Format("2006-01-02T15:04:05.000Z")
                                                prefix := fmt.Sprintf("[%s %s] ", instanceID, timestamp)
                                                m.buffer.WriteString(prefix)
                                                m.buffer.Write(lineBuffer)
                                                lineBuffer = lineBuffer[:0] // Clear the line buffer
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                // If not adding metadata, just write the data as is
                                m.buffer.Write(buf[:n])
                        }</span>

                        <span class="cov0" title="0">m.bufMu.Unlock()</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        if err != io.EOF </span><span class="cov0" title="0">{
                                // Log error but continue with other readers
                                fmt.Printf("Error reading from %s logs: %v\n", instanceID, err)
                        }</span>

                        // If we have any remaining data in the line buffer, write it out
                        <span class="cov0" title="0">if m.metadata &amp;&amp; len(lineBuffer) &gt; 0 </span><span class="cov0" title="0">{
                                m.bufMu.Lock()
                                timestamp := time.Now().Format("2006-01-02T15:04:05.000Z")
                                prefix := fmt.Sprintf("[%s %s] ", instanceID, timestamp)
                                m.buffer.WriteString(prefix)
                                m.buffer.Write(lineBuffer)
                                m.bufMu.Unlock()
                        }</span>

                        <span class="cov0" title="0">break</span>
                }
        }
}

// Read implements the io.Reader interface
func (m *MultiLogStreamer) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                // Check if we have data in the buffer
                m.bufMu.Lock()
                if m.buffer.Len() &gt; 0 </span><span class="cov0" title="0">{
                        n, err = m.buffer.Read(p)
                        m.bufMu.Unlock()
                        return
                }</span>
                <span class="cov0" title="0">m.bufMu.Unlock()

                // If not, check if we're done
                select </span>{
                case &lt;-m.done:<span class="cov0" title="0">
                        if m.closed </span><span class="cov0" title="0">{
                                return 0, io.EOF
                        }</span>
                        // One last check for data before returning EOF
                        <span class="cov0" title="0">m.bufMu.Lock()
                        n, err = m.buffer.Read(p)
                        m.bufMu.Unlock()
                        if n &gt; 0 </span><span class="cov0" title="0">{
                                return n, err
                        }</span>
                        <span class="cov0" title="0">return 0, io.EOF</span>
                default:<span class="cov0" title="0">
                        // Wait a bit before checking again
                        time.Sleep(100 * time.Millisecond)</span>
                }
        }
}

// Close implements the io.Closer interface
func (m *MultiLogStreamer) Close() error <span class="cov0" title="0">{
        m.closeMu.Lock()
        defer m.closeMu.Unlock()

        if m.closed </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">m.closed = true

        // Close all readers
        var firstErr error
        for _, reader := range m.readers </span><span class="cov0" title="0">{
                if err := reader.Close(); err != nil &amp;&amp; firstErr == nil </span><span class="cov0" title="0">{
                        firstErr = err
                }</span>
        }

        <span class="cov0" title="0">return firstErr</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package orchestrator

import (
        "io"
)

// MultiReadCloser combines multiple io.ReadCloser into one
type MultiReadCloser struct {
        readers []io.ReadCloser
        current int
}

// NewMultiReadCloser creates a new MultiReadCloser
func NewMultiReadCloser(readers ...io.ReadCloser) *MultiReadCloser <span class="cov0" title="0">{
        return &amp;MultiReadCloser{
                readers: readers,
                current: 0,
        }
}</span>

// Read reads from the current reader and advances to the next one when EOF is reached
func (m *MultiReadCloser) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if m.current &gt;= len(m.readers) </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>

        <span class="cov0" title="0">n, err = m.readers[m.current].Read(p)
        if err == io.EOF </span><span class="cov0" title="0">{
                m.current++
                if m.current &lt; len(m.readers) </span><span class="cov0" title="0">{
                        return m.Read(p)
                }</span>
        }

        <span class="cov0" title="0">return n, err</span>
}

// Close closes all readers
func (m *MultiReadCloser) Close() error <span class="cov0" title="0">{
        for _, r := range m.readers </span><span class="cov0" title="0">{
                if err := r.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package orchestrator

import (
        "context"
        "fmt"
        "io"
        "sync"
        "time"

        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner/manager"
        "github.com/rzbill/rune/pkg/store"
        "github.com/rzbill/rune/pkg/types"
)

// Orchestrator manages service lifecycle and coordinates with runners
type Orchestrator interface {
        // Start the orchestrator with the given context
        Start(ctx context.Context) error

        // Stop the orchestrator and clean up resources
        Stop() error

        // GetServiceStatus returns the current status of a service
        GetServiceStatus(ctx context.Context, namespace, name string) (*ServiceStatusInfo, error)

        // GetInstanceStatus returns the current status of an instance
        GetInstanceStatus(ctx context.Context, namespace, serviceName, instanceID string) (*InstanceStatusInfo, error)

        // GetServiceLogs returns a stream of logs for a service
        GetServiceLogs(ctx context.Context, namespace, name string, opts LogOptions) (io.ReadCloser, error)

        // GetInstanceLogs returns a stream of logs for an instance
        GetInstanceLogs(ctx context.Context, namespace, serviceName, instanceID string, opts LogOptions) (io.ReadCloser, error)

        // ExecInService executes a command in a running instance of the service
        // If multiple instances exist, one will be chosen
        ExecInService(ctx context.Context, namespace, serviceName string, options ExecOptions) (ExecStream, error)

        // ExecInInstance executes a command in a specific instance
        ExecInInstance(ctx context.Context, namespace, serviceName, instanceID string, options ExecOptions) (ExecStream, error)

        // RestartService restarts all instances of a service
        RestartService(ctx context.Context, namespace, serviceName string) error

        // RestartInstance restarts a specific instance
        RestartInstance(ctx context.Context, namespace, serviceName, instanceID string) error
}

// orchestrator implements the Orchestrator interface
type orchestrator struct {
        store              store.Store
        instanceController InstanceController
        healthController   HealthController
        reconciler         *reconciler
        logger             log.Logger

        // Context for background operations
        ctx    context.Context
        cancel context.CancelFunc

        // WaitGroup for goroutines
        wg sync.WaitGroup

        // Watch channel for services
        watchCh &lt;-chan store.WatchEvent
}

// NewOrchestrator creates a new orchestrator
func NewOrchestrator(store store.Store, instanceController InstanceController, healthController HealthController, runnerManager manager.IRunnerManager, logger log.Logger) Orchestrator <span class="cov8" title="1">{
        // Create the reconciler
        reconciler := newReconciler(
                store,
                instanceController,
                healthController,
                runnerManager,
                logger,
        )

        return &amp;orchestrator{
                store:              store,
                instanceController: instanceController,
                healthController:   healthController,
                reconciler:         reconciler,
                logger:             logger.WithComponent("orchestrator"),
        }
}</span>

// Start the orchestrator
func (o *orchestrator) Start(ctx context.Context) error <span class="cov0" title="0">{
        o.logger.Info("Starting orchestrator")

        // Create a context with cancel for all background operations
        o.ctx, o.cancel = context.WithCancel(ctx)

        // Start the reconciler
        if err := o.reconciler.Start(o.ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start reconciler: %w", err)
        }</span>

        // Start health controller
        <span class="cov0" title="0">if err := o.healthController.Start(o.ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start health controller: %w", err)
        }</span>

        // Start watching services
        <span class="cov0" title="0">watchCh, err := o.store.Watch(o.ctx, "services", "")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to watch services: %w", err)
        }</span>
        <span class="cov0" title="0">o.watchCh = watchCh

        // Start a goroutine to process service events
        o.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer o.wg.Done()
                o.watchServices()
        }</span>()

        <span class="cov0" title="0">return nil</span>
}

// Stop the orchestrator
func (o *orchestrator) Stop() error <span class="cov0" title="0">{
        o.logger.Info("Stopping orchestrator")

        // Cancel context to stop all operations
        if o.cancel != nil </span><span class="cov0" title="0">{
                o.cancel()
        }</span>

        // Stop reconciler
        <span class="cov0" title="0">o.reconciler.Stop()

        // Stop health controller
        if err := o.healthController.Stop(); err != nil </span><span class="cov0" title="0">{
                o.logger.Error("Failed to stop health controller", log.Err(err))
        }</span>

        // Wait for all goroutines to finish
        <span class="cov0" title="0">o.wg.Wait()

        o.logger.Info("Orchestrator stopped")
        return nil</span>
}

// watchServices watches service events and processes them
func (o *orchestrator) watchServices() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-o.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case event, ok := &lt;-o.watchCh:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                o.logger.Error("Service watch channel closed, restarting watch")
                                // Try to restart the watch
                                watchCh, err := o.store.Watch(o.ctx, "services", "")
                                if err != nil </span><span class="cov0" title="0">{
                                        o.logger.Error("Failed to restart service watch", log.Err(err))
                                        time.Sleep(5 * time.Second) // Backoff before retry
                                        continue</span>
                                }
                                <span class="cov0" title="0">o.watchCh = watchCh
                                continue</span>
                        }

                        // Process the event
                        <span class="cov0" title="0">switch event.Type </span>{
                        case store.WatchEventCreated:<span class="cov0" title="0">
                                o.logger.Info("Service created",
                                        log.Str("name", event.Name),
                                        log.Str("namespace", event.Namespace))

                                // Type assert to *types.Service
                                service, ok := event.Resource.(*types.Service)
                                if !ok </span><span class="cov0" title="0">{
                                        o.logger.Error("Failed to convert resource to Service",
                                                log.Str("name", event.Name),
                                                log.Str("namespace", event.Namespace))
                                        continue</span>
                                }
                                <span class="cov0" title="0">o.handleServiceCreated(o.ctx, service)</span>

                        case store.WatchEventUpdated:<span class="cov0" title="0">
                                o.logger.Info("Service updated",
                                        log.Str("name", event.Name),
                                        log.Str("namespace", event.Namespace))

                                // Type assert to *types.Service
                                service, ok := event.Resource.(*types.Service)
                                if !ok </span><span class="cov0" title="0">{
                                        o.logger.Error("Failed to convert resource to Service",
                                                log.Str("name", event.Name),
                                                log.Str("namespace", event.Namespace))
                                        continue</span>
                                }
                                <span class="cov0" title="0">o.handleServiceUpdated(o.ctx, service)</span>

                        case store.WatchEventDeleted:<span class="cov0" title="0">
                                o.logger.Info("Service deleted",
                                        log.Str("name", event.Name),
                                        log.Str("namespace", event.Namespace))

                                // Type assert to *types.Service
                                service, ok := event.Resource.(*types.Service)
                                if !ok </span><span class="cov0" title="0">{
                                        o.logger.Error("Failed to convert resource to Service",
                                                log.Str("name", event.Name),
                                                log.Str("namespace", event.Namespace))
                                        continue</span>
                                }
                                <span class="cov0" title="0">o.handleServiceDeleted(o.ctx, service)</span>
                        }
                }
        }
}

// handleServiceCreated handles service creation events
func (o *orchestrator) handleServiceCreated(ctx context.Context, service *types.Service) <span class="cov0" title="0">{
        // Set initial service state
        service.Status = types.ServiceStatusPending

        // Update service status in store
        if err := o.store.Update(ctx, types.ResourceTypeService, service.Namespace, service.Name, service); err != nil </span><span class="cov0" title="0">{
                o.logger.Error("Failed to update service status",
                        log.Str("name", service.Name),
                        log.Str("namespace", service.Namespace),
                        log.Err(err))
                return
        }</span>

        // Schedule reconciliation for this service using the reconciler
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                // Collect running instances for reconciliation
                runningInstances, err := o.reconciler.collectRunningInstances(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        o.logger.Error("Failed to collect running instances",
                                log.Str("name", service.Name),
                                log.Str("namespace", service.Namespace),
                                log.Err(err))
                        return
                }</span>

                // Use the reconciler to handle this service
                <span class="cov0" title="0">if err := o.reconciler.reconcileService(ctx, service, runningInstances); err != nil </span><span class="cov0" title="0">{
                        o.logger.Error("Failed to reconcile service",
                                log.Str("name", service.Name),
                                log.Str("namespace", service.Namespace),
                                log.Err(err))
                }</span>
        }()
}

// handleServiceUpdated handles service update events
func (o *orchestrator) handleServiceUpdated(ctx context.Context, service *types.Service) <span class="cov0" title="0">{
        // Schedule reconciliation for this service using the reconciler
        go func() </span><span class="cov0" title="0">{
                // Collect running instances for reconciliation
                runningInstances, err := o.reconciler.collectRunningInstances(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        o.logger.Error("Failed to collect running instances",
                                log.Str("name", service.Name),
                                log.Str("namespace", service.Namespace),
                                log.Err(err))
                        return
                }</span>

                // Use the reconciler to handle this service
                <span class="cov0" title="0">if err := o.reconciler.reconcileService(ctx, service, runningInstances); err != nil </span><span class="cov0" title="0">{
                        o.logger.Error("Failed to reconcile updated service",
                                log.Str("name", service.Name),
                                log.Str("namespace", service.Namespace),
                                log.Err(err))
                }</span>
        }()
}

// handleServiceDeleted handles service deletion events
func (o *orchestrator) handleServiceDeleted(ctx context.Context, service *types.Service) <span class="cov0" title="0">{
        // List all instances for this service
        instances, err := o.listInstancesForService(ctx, service.Namespace, service.Name)
        if err != nil </span><span class="cov0" title="0">{
                o.logger.Error("Failed to list instances for deleted service",
                        log.Str("name", service.Name),
                        log.Str("namespace", service.Namespace),
                        log.Err(err))
                return
        }</span>

        // Mark the service as deleted
        <span class="cov0" title="0">service.Status = types.ServiceStatusDeleted

        // Delete all instances
        for _, instance := range instances </span><span class="cov0" title="0">{
                if err := o.instanceController.DeleteInstance(ctx, instance); err != nil </span><span class="cov0" title="0">{
                        o.logger.Error("Failed to delete instance for removed service",
                                log.Str("name", service.Name),
                                log.Str("namespace", service.Namespace),
                                log.Str("instance", instance.ID),
                                log.Err(err))
                }</span>

                // Remove from health monitoring
                <span class="cov0" title="0">o.healthController.RemoveInstance(instance.ID)

                // Remove from store
                if err := o.store.Delete(ctx, "instances", service.Namespace, instance.ID); err != nil </span><span class="cov0" title="0">{
                        o.logger.Error("Failed to remove instance from store",
                                log.Str("instance", instance.ID),
                                log.Err(err))
                }</span>
        }
}

// GetServiceStatus returns the current status of a service
func (o *orchestrator) GetServiceStatus(ctx context.Context, namespace, name string) (*ServiceStatusInfo, error) <span class="cov0" title="0">{
        // Get service from store
        var service types.Service
        if err := o.store.Get(ctx, types.ResourceTypeService, namespace, name, &amp;service); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get service: %w", err)
        }</span>

        // List instances for this service
        <span class="cov0" title="0">instances, err := o.listInstancesForService(ctx, namespace, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list instances: %w", err)
        }</span>

        <span class="cov0" title="0">status := &amp;ServiceStatusInfo{
                State:         service.Status,
                InstanceCount: len(instances),
        }

        // Count ready instances
        for _, instance := range instances </span><span class="cov0" title="0">{
                if instance.Status == types.InstanceStatusRunning </span><span class="cov0" title="0">{
                        status.ReadyInstanceCount++
                }</span>
        }

        <span class="cov0" title="0">return status, nil</span>
}

// GetInstanceStatus returns the current status of an instance
func (o *orchestrator) GetInstanceStatus(ctx context.Context, namespace, serviceName, instanceID string) (*InstanceStatusInfo, error) <span class="cov0" title="0">{
        // Get instance from store
        var instance types.Instance
        if err := o.store.Get(ctx, types.ResourceTypeInstance, namespace, instanceID, &amp;instance); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get instance: %w", err)
        }</span>

        // Verify instance belongs to the specified service
        <span class="cov0" title="0">if instance.ServiceID != serviceName </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance does not belong to service %s", serviceName)
        }</span>

        <span class="cov0" title="0">return &amp;InstanceStatusInfo{
                State:      instance.Status,
                InstanceID: instance.ID,
                NodeID:     instance.NodeID,
                CreatedAt:  instance.CreatedAt,
        }, nil</span>
}

// GetServiceLogs returns a stream of logs for a service
func (o *orchestrator) GetServiceLogs(ctx context.Context, namespace, name string, opts LogOptions) (io.ReadCloser, error) <span class="cov0" title="0">{
        // List instances for this service
        instances, err := o.listInstancesForService(ctx, namespace, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list instances: %w", err)
        }</span>

        <span class="cov0" title="0">if len(instances) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no instances found for service %s in namespace %s", name, namespace)
        }</span>

        // Collect log streams from all instances
        <span class="cov0" title="0">logInfos := make([]InstanceLogInfo, 0, len(instances))
        for _, instance := range instances </span><span class="cov0" title="0">{
                logReader, err := o.GetInstanceLogs(ctx, namespace, name, instance.Name, opts)
                if err != nil </span><span class="cov0" title="0">{
                        o.logger.Warn("Failed to get logs for instance",
                                log.Str("service", name),
                                log.Str("namespace", namespace),
                                log.Str("instance", instance.Name),
                                log.Err(err))
                        // Continue with other instances even if one fails
                        continue</span>
                }
                <span class="cov0" title="0">logInfos = append(logInfos, InstanceLogInfo{
                        InstanceID: instance.ID,
                        Reader:     logReader,
                })</span>
        }

        <span class="cov0" title="0">if len(logInfos) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get logs from any instance of service %s in namespace %s", name, namespace)
        }</span>

        // If only one reader is available, return it directly without metadata
        <span class="cov0" title="0">if len(logInfos) == 1 </span><span class="cov0" title="0">{
                return logInfos[0].Reader, nil
        }</span>

        // Create a multi-instance log streamer to combine logs
        <span class="cov0" title="0">return NewMultiLogStreamer(logInfos, true), nil</span>
}

// GetInstanceLogs returns a stream of logs for an instance
func (o *orchestrator) GetInstanceLogs(ctx context.Context, namespace, serviceName, instanceID string, opts LogOptions) (io.ReadCloser, error) <span class="cov0" title="0">{
        // Get instance from store
        var instance types.Instance
        if err := o.store.Get(ctx, types.ResourceTypeInstance, namespace, instanceID, &amp;instance); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get instance: %w", err)
        }</span>

        // Verify instance belongs to the specified service
        <span class="cov0" title="0">if instance.ServiceID != serviceName </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance does not belong to service %s", serviceName)
        }</span>

        // Get logs from instance controller
        <span class="cov0" title="0">return o.instanceController.GetInstanceLogs(ctx, &amp;instance, opts)</span>
}

// ExecInService executes a command in a running instance of the service
func (o *orchestrator) ExecInService(ctx context.Context, namespace, serviceName string, options ExecOptions) (ExecStream, error) <span class="cov8" title="1">{
        // List instances for this service
        instances, err := o.listInstancesForService(ctx, namespace, serviceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list instances: %w", err)
        }</span>

        <span class="cov8" title="1">if len(instances) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no instances found for service %s in namespace %s", serviceName, namespace)
        }</span>

        // Find a running instance
        <span class="cov8" title="1">var runningInstance *types.Instance
        for _, instance := range instances </span><span class="cov8" title="1">{
                if instance.Status == types.InstanceStatusRunning </span><span class="cov8" title="1">{
                        runningInstance = instance
                        break</span>
                }
        }

        <span class="cov8" title="1">if runningInstance == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no running instances found for service %s in namespace %s", serviceName, namespace)
        }</span>

        // Execute command in the selected instance
        <span class="cov8" title="1">return o.instanceController.Exec(ctx, runningInstance, options)</span>
}

// ExecInInstance executes a command in a specific instance
func (o *orchestrator) ExecInInstance(ctx context.Context, namespace, serviceName, instanceID string, options ExecOptions) (ExecStream, error) <span class="cov8" title="1">{
        // Get instance from store
        var instance types.Instance
        if err := o.store.Get(ctx, types.ResourceTypeInstance, namespace, instanceID, &amp;instance); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get instance: %w", err)
        }</span>

        // Verify instance belongs to the specified service
        <span class="cov8" title="1">if instance.ServiceID != serviceName </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("instance does not belong to service %s", serviceName)
        }</span>

        // Verify instance is running
        <span class="cov8" title="1">if instance.Status != types.InstanceStatusRunning </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance %s is not running, current status: %s", instanceID, instance.Status)
        }</span>

        // Execute command in the instance
        <span class="cov8" title="1">return o.instanceController.Exec(ctx, &amp;instance, options)</span>
}

// listInstancesForService lists all instances for a service
func (o *orchestrator) listInstancesForService(ctx context.Context, namespace, serviceName string) ([]*types.Instance, error) <span class="cov8" title="1">{
        // Get all instances
        var instances []types.Instance
        err := o.store.List(ctx, "instances", namespace, &amp;instances)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to list instances: %w", err)
        }</span>

        // Filter instances for this service
        <span class="cov8" title="1">filteredInstances := make([]*types.Instance, 0, len(instances))
        for _, instance := range instances </span><span class="cov8" title="1">{
                if instance.ServiceID == serviceName </span><span class="cov8" title="1">{
                        filteredInstances = append(filteredInstances, &amp;instance)
                }</span>
        }

        <span class="cov8" title="1">return filteredInstances, nil</span>
}

// GetInstanceController returns the instance controller for testing purposes
func (o *orchestrator) GetInstanceController() InstanceController <span class="cov8" title="1">{
        return o.instanceController
}</span>

// NewDefaultOrchestrator creates a new orchestrator with default components
func NewDefaultOrchestrator(store store.Store, logger log.Logger, runnerManager manager.IRunnerManager) (Orchestrator, error) <span class="cov0" title="0">{
        // Create the instance controller
        instanceController := NewInstanceController(store, runnerManager, logger)

        // Create the health controller
        healthController := NewHealthController(logger, store, runnerManager)

        // Setup the instance controller reference for health controller
        if hc, ok := healthController.(interface{ SetInstanceController(InstanceController) }); ok </span><span class="cov0" title="0">{
                hc.SetInstanceController(instanceController)
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Health controller does not support SetInstanceController method")
        }</span>

        // Create and return the orchestrator
        <span class="cov0" title="0">return NewOrchestrator(store, instanceController, healthController, runnerManager, logger), nil</span>
}

// RestartService restarts all instances of a service
func (o *orchestrator) RestartService(ctx context.Context, namespace, serviceName string) error <span class="cov8" title="1">{
        o.logger.Info("Restarting service",
                log.Str("namespace", namespace),
                log.Str("service", serviceName))

        // List instances for this service
        instances, err := o.listInstancesForService(ctx, namespace, serviceName)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to list instances for service: %w", err)
        }</span>

        <span class="cov8" title="1">if len(instances) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no instances found for service %s in namespace %s", serviceName, namespace)
        }</span>

        // Restart each instance
        <span class="cov8" title="1">var lastError error
        for _, instance := range instances </span><span class="cov8" title="1">{
                if err := o.RestartInstance(ctx, namespace, serviceName, instance.ID); err != nil </span><span class="cov0" title="0">{
                        o.logger.Error("Failed to restart instance",
                                log.Str("namespace", namespace),
                                log.Str("service", serviceName),
                                log.Str("instance", instance.ID),
                                log.Err(err))
                        lastError = err
                        // Continue with other instances even if one fails
                }</span>
        }

        // Return the last error encountered, if any
        <span class="cov8" title="1">if lastError != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("one or more instances failed to restart: %w", lastError)
        }</span>

        <span class="cov8" title="1">o.logger.Info("Successfully restarted service",
                log.Str("namespace", namespace),
                log.Str("service", serviceName))
        return nil</span>
}

// RestartInstance restarts a specific instance
func (o *orchestrator) RestartInstance(ctx context.Context, namespace, serviceName, instanceID string) error <span class="cov8" title="1">{
        o.logger.Info("Restarting instance",
                log.Str("namespace", namespace),
                log.Str("service", serviceName),
                log.Str("instance", instanceID))

        // Get instance from store
        var instance types.Instance
        if err := o.store.Get(ctx, types.ResourceTypeInstance, namespace, instanceID, &amp;instance); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get instance: %w", err)
        }</span>

        // Verify instance belongs to the specified service
        <span class="cov8" title="1">if instance.ServiceID != serviceName </span><span class="cov8" title="1">{
                return fmt.Errorf("instance does not belong to service %s", serviceName)
        }</span>

        // Restart the instance through instance controller
        <span class="cov8" title="1">if err := o.instanceController.RestartInstance(ctx, &amp;instance, InstanceRestartReasonManual); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restart instance: %w", err)
        }</span>

        <span class="cov8" title="1">o.logger.Info("Successfully restarted instance",
                log.Str("namespace", namespace),
                log.Str("service", serviceName),
                log.Str("instance", instanceID))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package orchestrator

import (
        "context"
        "fmt"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner/manager"
        "github.com/rzbill/rune/pkg/store"
        "github.com/rzbill/rune/pkg/types"
)

// reconciler is responsible for ensuring the actual state of instances
// matches the desired state defined in the services
type reconciler struct {
        store              store.Store
        instanceController InstanceController
        healthController   HealthController
        runnerManager      manager.IRunnerManager
        logger             log.Logger
        reconcileInterval  time.Duration
        mu                 sync.Mutex
        isRunning          bool
        ctx                context.Context
        cancel             context.CancelFunc
        ticker             *time.Ticker
        wg                 sync.WaitGroup
}

// newReconciler creates a new reconciler.
func newReconciler(
        store store.Store,
        instanceController InstanceController,
        healthController HealthController,
        runnerManager manager.IRunnerManager,
        logger log.Logger,
) *reconciler <span class="cov8" title="1">{
        return &amp;reconciler{
                store:              store,
                instanceController: instanceController,
                healthController:   healthController,
                runnerManager:      runnerManager,
                logger:             logger.WithComponent("reconciler"),
                reconcileInterval:  30 * time.Second,
                mu:                 sync.Mutex{},
                wg:                 sync.WaitGroup{},
        }
}</span>

// Start begins the periodic reconciliation loop
func (r *reconciler) Start(ctx context.Context) error <span class="cov0" title="0">{
        r.mu.Lock()
        if r.isRunning </span><span class="cov0" title="0">{
                r.mu.Unlock()
                return nil // Already running, nothing to do
        }</span>
        <span class="cov0" title="0">r.isRunning = true
        r.mu.Unlock()

        r.logger.Info("Starting reconciler")

        r.ctx, r.cancel = context.WithCancel(ctx)

        // Perform an initial reconciliation immediately
        if err := r.reconcileServices(r.ctx); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Initial reconciliation failed", log.Err(err))
                // Continue despite error as this will be retried by the ticker
        }</span>

        // Start periodic reconciliation
        <span class="cov0" title="0">r.ticker = time.NewTicker(r.reconcileInterval)
        r.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer r.wg.Done()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-r.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-r.ticker.C:<span class="cov0" title="0">
                                r.logger.Debug("Running periodic reconciliation")

                                // Reconcile all services
                                if err := r.reconcileServices(r.ctx); err != nil </span><span class="cov0" title="0">{
                                        r.logger.Error("Reconciliation failed", log.Err(err))
                                }</span>

                                // Clean up deleted services
                                <span class="cov0" title="0">if err := r.handleDeletedServices(r.ctx); err != nil </span><span class="cov0" title="0">{
                                        r.logger.Error("Failed to clean up deleted services", log.Err(err))
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the reconciliation loop.
func (r *reconciler) Stop() <span class="cov0" title="0">{
        r.mu.Lock()
        if !r.isRunning </span><span class="cov0" title="0">{
                r.mu.Unlock()
                return // Not running, nothing to do
        }</span>
        <span class="cov0" title="0">r.mu.Unlock()

        r.logger.Info("Stopping reconciler")

        // Cancel context to stop operations
        if r.cancel != nil </span><span class="cov0" title="0">{
                r.cancel()
        }</span>

        // Stop the ticker
        <span class="cov0" title="0">if r.ticker != nil </span><span class="cov0" title="0">{
                r.ticker.Stop()
        }</span>

        // Wait for goroutines to finish
        <span class="cov0" title="0">r.wg.Wait()

        // Mark as not running
        r.mu.Lock()
        r.isRunning = false
        r.mu.Unlock()

        r.logger.Info("Reconciler stopped")</span>
}

// reconcileServices compares the desired state of services with the actual state
// and makes any necessary adjustments
func (r *reconciler) reconcileServices(ctx context.Context) error <span class="cov0" title="0">{
        r.logger.Debug("Starting service reconciliation")

        // Get desired state from store
        var services []types.Service
        err := r.store.List(ctx, types.ResourceTypeService, "", &amp;services)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list services: %w", err)
        }</span>

        // Get actual state from runners
        <span class="cov0" title="0">runningInstances, err := r.collectRunningInstances(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to collect running instances: %w", err)
        }</span>

        // Reconcile each service's desired state with actual state
        <span class="cov0" title="0">for _, service := range services </span><span class="cov0" title="0">{
                if err := r.reconcileService(ctx, &amp;service, runningInstances); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to reconcile service",
                                log.Str("service", service.Name),
                                log.Str("namespace", service.Namespace),
                                log.Err(err))
                        // Continue with other services even if one fails
                }</span>
        }

        <span class="cov0" title="0">r.logger.Debug("Completed reconciliation for services", log.Int("count", len(services)))

        // Handle orphaned instances (running but not in desired state)
        for id, instance := range runningInstances </span><span class="cov0" title="0">{
                if instance.IsOrphaned </span><span class="cov0" title="0">{
                        r.logger.Info("Cleaning up orphaned instance",
                                log.Str("instance", id),
                                log.Str("service", instance.Instance.ServiceID))

                        if err := r.instanceController.DeleteInstance(ctx, instance.Instance); err != nil </span><span class="cov0" title="0">{
                                r.logger.Error("Failed to clean up orphaned instance",
                                        log.Str("instance", id),
                                        log.Err(err))
                        }</span>
                }
        }

        <span class="cov0" title="0">r.logger.Debug("Service reconciliation completed")
        return nil</span>
}

// collectRunningInstances gathers all running instances from all runners
func (r *reconciler) collectRunningInstances(ctx context.Context) (map[string]*RunningInstance, error) <span class="cov0" title="0">{
        instances := make(map[string]*RunningInstance)

        // Collect instances from docker runner
        dockerRunner, err := r.runnerManager.GetDockerRunner()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get docker runner: %w", err)
        }</span>
        <span class="cov0" title="0">dockerInstances, err := dockerRunner.List(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to list docker instances", log.Err(err))
                // Continue with other runners even if one fails
        }</span> else<span class="cov0" title="0"> {
                for _, instance := range dockerInstances </span><span class="cov0" title="0">{
                        instances[instance.ID] = &amp;RunningInstance{
                                Instance:   instance,
                                IsOrphaned: true, // Mark as orphaned initially, will be updated during reconciliation
                                Runner:     dockerRunner.Type(),
                        }
                }</span>
        }

        // Collect instances from process runner
        <span class="cov0" title="0">processRunner, err := r.runnerManager.GetProcessRunner()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get process runner: %w", err)
        }</span>
        <span class="cov0" title="0">processInstances, err := processRunner.List(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to list process instances", log.Err(err))
                // Continue with other runners even if one fails
        }</span> else<span class="cov0" title="0"> {
                for _, instance := range processInstances </span><span class="cov0" title="0">{
                        instances[instance.ID] = &amp;RunningInstance{
                                Instance:   instance,
                                IsOrphaned: true, // Mark as orphaned initially, will be updated during reconciliation
                                Runner:     processRunner.Type(),
                        }
                }</span>
        }

        <span class="cov0" title="0">return instances, nil</span>
}

// reconcileService ensures that a single service's instances match the desired state
func (r *reconciler) reconcileService(ctx context.Context, service *types.Service, runningInstances map[string]*RunningInstance) error <span class="cov8" title="1">{
        r.logger.Debug("Reconciling service",
                log.Str("service", service.Name),
                log.Str("namespace", service.Namespace))

        // Skip reconciliation if the service is marked as deleted
        if service.Status == types.ServiceStatusDeleted </span><span class="cov0" title="0">{
                r.logger.Debug("Skipping reconciliation for deleted service",
                        log.Str("service", service.Name),
                        log.Str("namespace", service.Namespace))
                return nil
        }</span>

        // Get existing instances for this service
        <span class="cov8" title="1">serviceInstances, err := r.getServiceInstances(ctx, service, runningInstances)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Scale down if needed
        <span class="cov8" title="1">if err := r.scaleDownService(ctx, service, serviceInstances); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error scaling down service",
                        log.Str("service", service.Name),
                        log.Err(err))
                // Continue with the rest of reconciliation
        }</span>

        // Ensure we have the right number of instances and they're up to date
        <span class="cov8" title="1">if err := r.ensureServiceInstances(ctx, service, serviceInstances); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error ensuring service instances",
                        log.Str("service", service.Name),
                        log.Err(err))
                // Continue with the rest of reconciliation
        }</span>

        // Update service status based on the latest instance data
        <span class="cov8" title="1">if err := r.updateServiceStatus(ctx, service); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to update service status",
                        log.Str("service", service.Name),
                        log.Err(err))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getServiceInstances retrieves and filters instances for a specific service
// Marks running instances that belong to this service as not orphaned
func (r *reconciler) getServiceInstances(ctx context.Context, service *types.Service, runningInstances map[string]*RunningInstance) ([]types.Instance, error) <span class="cov8" title="1">{
        // Get existing instances for this service from store
        var storeInstances []types.Instance
        err := r.store.List(ctx, types.ResourceTypeInstance, service.Namespace, &amp;storeInstances)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get instances for service: %w", err)
        }</span>

        <span class="cov8" title="1">r.logger.Debug("Retrieved instances for service",
                log.Str("service", service.Name),
                log.Int("count", len(storeInstances)))

        // Filter instances for this service
        var serviceInstances []types.Instance
        for _, instance := range storeInstances </span><span class="cov8" title="1">{
                if instance.ServiceID == service.ID </span><span class="cov8" title="1">{
                        serviceInstances = append(serviceInstances, instance)

                        // Mark running instances that belong to this service as not orphaned
                        if runningInst, exists := runningInstances[instance.ID]; exists </span><span class="cov0" title="0">{
                                runningInst.IsOrphaned = false
                        }</span>
                }
        }

        <span class="cov8" title="1">return serviceInstances, nil</span>
}

// scaleDownService removes excess instances when the desired scale is lower than current
func (r *reconciler) scaleDownService(ctx context.Context, service *types.Service, instances []types.Instance) error <span class="cov8" title="1">{
        if len(instances) &lt;= service.Scale </span><span class="cov8" title="1">{
                return nil // No scaling down needed
        }</span>

        <span class="cov8" title="1">r.logger.Info("Scaling down service",
                log.Str("service", service.Name),
                log.Int("current", len(instances)),
                log.Int("desired", service.Scale))

        // Sort instances by creation time (newest first)
        sort.Slice(instances, func(i, j int) bool </span><span class="cov8" title="1">{
                return instances[i].CreatedAt.After(instances[j].CreatedAt)
        }</span>)

        // For now we'll use a simple approach removing from the end
        <span class="cov8" title="1">for i := service.Scale; i &lt; len(instances); i++ </span><span class="cov8" title="1">{
                instance := instances[i]

                // Skip stopped instances
                if instance.Status == types.InstanceStatusStopped </span><span class="cov0" title="0">{
                        r.logger.Info("Skipping stopped instance",
                                log.Str("service", service.Name),
                                log.Str("instance", instance.ID))
                        continue</span>
                }

                <span class="cov8" title="1">r.logger.Info("Removing excess instance",
                        log.Str("service", service.Name),
                        log.Str("instance", instance.ID))

                // Remove from health monitoring
                if service.Health != nil </span><span class="cov8" title="1">{
                        r.healthController.RemoveInstance(instance.ID)
                }</span>

                <span class="cov8" title="1">if err := r.instanceController.DeleteInstance(ctx, &amp;instance); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to remove excess instance",
                                log.Str("instance", instance.ID),
                                log.Err(err))
                        // Continue with other instances even if one fails
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ensureServiceInstances makes sure we have the right number of instances and they're up to date
func (r *reconciler) ensureServiceInstances(ctx context.Context, service *types.Service, instances []types.Instance) error <span class="cov8" title="1">{
        r.logger.Debug("Ensuring service instances",
                log.Str("service", service.Name),
                log.Int("desired", service.Scale),
                log.Int("current", len(instances)))

        for i := 0; i &lt; service.Scale; i++ </span><span class="cov8" title="1">{
                // Generate instance name
                instanceName := fmt.Sprintf("%s-%d", service.Name, i)

                // Check if this instance already exists
                var existingInstance *types.Instance
                for j := range instances </span><span class="cov8" title="1">{
                        if instances[j].Name == instanceName </span><span class="cov8" title="1">{
                                existingInstance = &amp;instances[j]
                                break</span>
                        }
                }

                <span class="cov8" title="1">if existingInstance != nil </span><span class="cov8" title="1">{
                        // Update existing instance
                        if err := r.reconcileExistingInstance(ctx, service, existingInstance); err != nil </span><span class="cov0" title="0">{
                                r.logger.Error("Failed to reconcile existing instance",
                                        log.Str("service", service.Name),
                                        log.Str("instance", instanceName),
                                        log.Err(err))
                                // Continue with other instances
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">r.logger.Info("creating new instance", log.Json("instanceName", instanceName))
                // Create a new instance
                if err := r.createNewInstance(ctx, service, instanceName); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to create new instance",
                                log.Str("service", service.Name),
                                log.Str("instance", instanceName),
                                log.Err(err))
                        // Continue with other instances
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// reconcileExistingInstance updates an existing instance, recreating it if necessary
func (r *reconciler) reconcileExistingInstance(ctx context.Context, service *types.Service, instance *types.Instance) error <span class="cov8" title="1">{
        r.logger.Debug("Reconciling existing instance",
                log.Str("service", service.Name),
                log.Str("instance", instance.ID))

        // Try to update the instance in-place
        if err := r.instanceController.UpdateInstance(ctx, service, instance); err != nil </span><span class="cov0" title="0">{
                // Check if the error indicates that recreation is needed
                if r.isRecreationRequired(err) </span><span class="cov0" title="0">{
                        return r.recreateInstance(ctx, service, instance)
                }</span>
                // Some other update error occurred
                <span class="cov0" title="0">return fmt.Errorf("failed to update instance: %w", err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// recreateInstance handles recreation of an instance that cannot be updated in-place
func (r *reconciler) recreateInstance(ctx context.Context, service *types.Service, instance *types.Instance) error <span class="cov0" title="0">{
        instanceName := instance.ID
        r.logger.Info("Instance requires recreation",
                log.Str("service", service.Name),
                log.Str("instance", instanceName))

        // First remove from health monitoring if applicable
        if service.Health != nil </span><span class="cov0" title="0">{
                r.healthController.RemoveInstance(instance.ID)
        }</span>

        // Recreate the instance
        <span class="cov0" title="0">r.logger.Info("Recreating instance",
                log.Str("service", service.Name),
                log.Str("instance", instanceName))

        newInstance, err := r.instanceController.RecreateInstance(ctx, service, instance)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to recreate instance: %w", err)
        }</span>

        // Add the new instance to health monitoring if needed
        <span class="cov0" title="0">if service.Health != nil </span><span class="cov0" title="0">{
                if err := r.healthController.AddInstance(newInstance); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to add recreated instance to health monitoring",
                                log.Str("instance", instanceName),
                                log.Err(err))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// createNewInstance creates a new instance for a service
func (r *reconciler) createNewInstance(ctx context.Context, service *types.Service, instanceName string) error <span class="cov8" title="1">{
        r.logger.Info("Creating instance to achieve desired scale",
                log.Str("service", service.Name),
                log.Str("instance", instanceName))

        newInstance, err := r.instanceController.CreateInstance(ctx, service, instanceName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create instance: %w", err)
        }</span>

        // Add the instance to health monitoring if applicable
        <span class="cov8" title="1">if service.Health != nil </span><span class="cov8" title="1">{
                if err := r.healthController.AddInstance(newInstance); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to add instance to health monitoring",
                                log.Str("instance", instanceName),
                                log.Err(err))
                        // Continue anyway
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// updateServiceStatus updates a service's status based on its instances
func (r *reconciler) updateServiceStatus(ctx context.Context, service *types.Service) error <span class="cov8" title="1">{
        // Don't change the status if service is already marked as deleted
        if service.Status == types.ServiceStatusDeleted </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Fetch the latest instance data directly from the store
        <span class="cov8" title="1">serviceInstances, err := r.getServiceInstances(ctx, service, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get latest instances for status update: %w", err)
        }</span>

        <span class="cov8" title="1">var newStatus types.ServiceStatus

        if len(serviceInstances) == 0 </span><span class="cov0" title="0">{
                // No instances yet
                newStatus = types.ServiceStatusPending
        }</span> else<span class="cov8" title="1"> {
                // Count instances in each state
                pending := 0
                running := 0
                failed := 0

                for _, instance := range serviceInstances </span><span class="cov8" title="1">{
                        switch instance.Status </span>{
                        case types.InstanceStatusPending, types.InstanceStatusCreated, types.InstanceStatusStarting:<span class="cov0" title="0">
                                pending++</span>
                        case types.InstanceStatusRunning:<span class="cov8" title="1">
                                running++</span>
                        case types.InstanceStatusFailed, types.InstanceStatusExited, types.InstanceStatusUnknown:<span class="cov0" title="0">
                                failed++</span>
                        }
                }

                <span class="cov8" title="1">r.logger.Debug("Instance status counts",
                        log.Str("service", service.Name),
                        log.Int("pending", pending),
                        log.Int("running", running),
                        log.Int("failed", failed),
                        log.Int("total", len(serviceInstances)))

                // Determine overall service status
                if failed &gt; 0 </span><span class="cov0" title="0">{
                        newStatus = types.ServiceStatusFailed
                }</span> else<span class="cov8" title="1"> if pending &gt; 0 </span><span class="cov0" title="0">{
                        newStatus = types.ServiceStatusDeploying
                }</span> else<span class="cov8" title="1"> if running == len(serviceInstances) </span><span class="cov8" title="1">{
                        newStatus = types.ServiceStatusRunning
                }</span> else<span class="cov0" title="0"> {
                        newStatus = types.ServiceStatusPending
                }</span>
        }

        // Update service status if changed
        <span class="cov8" title="1">if service.Status != newStatus </span><span class="cov8" title="1">{
                r.logger.Info("Updating service status",
                        log.Str("service", service.Name),
                        log.Str("from", string(service.Status)),
                        log.Str("to", string(newStatus)))

                service.Status = newStatus
                if err := r.store.Update(ctx, types.ResourceTypeService, service.Namespace, service.Name, service); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update service status: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// RunningInstance represents an instance found running in a runner
type RunningInstance struct {
        Instance   *types.Instance
        IsOrphaned bool
        Runner     types.RunnerType
}

// handleDeletedServices cleans up services that are marked as deleted
func (r *reconciler) handleDeletedServices(ctx context.Context) error <span class="cov0" title="0">{
        // Get all services from store
        var services []types.Service
        err := r.store.List(ctx, "services", "", &amp;services)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list services: %w", err)
        }</span>

        // Check for services marked as deleted
        <span class="cov0" title="0">for _, service := range services </span><span class="cov0" title="0">{
                // If service is marked as deleted, remove it from the store
                if service.Status == types.ServiceStatusDeleted </span><span class="cov0" title="0">{
                        // Check if all instances have been cleaned up
                        instances, err := r.listInstancesForService(ctx, service.Namespace, service.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                r.logger.Error("Failed to list instances for deleted service",
                                        log.Str("name", service.Name),
                                        log.Str("namespace", service.Namespace),
                                        log.Err(err))
                                continue</span>
                        }

                        <span class="cov0" title="0">if len(instances) == 0 </span><span class="cov0" title="0">{
                                // All instances are gone, we can remove the service from the store
                                r.logger.Info("Removing deleted service from store",
                                        log.Str("name", service.Name),
                                        log.Str("namespace", service.Namespace))

                                if err := r.store.Delete(ctx, "services", service.Namespace, service.Name); err != nil </span><span class="cov0" title="0">{
                                        r.logger.Error("Failed to remove deleted service from store",
                                                log.Str("name", service.Name),
                                                log.Str("namespace", service.Namespace),
                                                log.Err(err))
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// listInstancesForService lists all instances for a service
func (r *reconciler) listInstancesForService(ctx context.Context, namespace, serviceName string) ([]types.Instance, error) <span class="cov0" title="0">{
        // Get all instances
        var instances []types.Instance
        err := r.store.List(ctx, types.ResourceTypeInstance, namespace, &amp;instances)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list instances: %w", err)
        }</span>

        // Filter instances for this service
        <span class="cov0" title="0">for _, instance := range instances </span><span class="cov0" title="0">{
                if instance.ServiceID == serviceName </span><span class="cov0" title="0">{
                        instances = append(instances, instance)
                }</span>
        }

        <span class="cov0" title="0">return instances, nil</span>
}

// isRecreationRequired checks if an error from UpdateInstance indicates that
// the instance needs to be recreated rather than updated in-place
func (r *reconciler) isRecreationRequired(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for the specific error message pattern from UpdateInstance
        <span class="cov0" title="0">return strings.Contains(err.Error(), "requires recreation") ||
                strings.Contains(err.Error(), "incompatible") ||
                strings.Contains(err.Error(), "cannot be updated in-place")</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package orchestrator

import (
        "encoding/json"
        "fmt"
        "strconv"

        "github.com/rzbill/rune/pkg/types"
)

// generateInstanceName generates a unique instance name for a service
func generateInstanceName(service *types.Service, index int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%d", service.Name, index)
}</span>

func PrettyPrint(v ...interface{}) <span class="cov0" title="0">{
        prints := CapturePrettyPrint(v...)
        fmt.Println(prints...)
}</span>

func CapturePrettyPrint(v ...interface{}) []any <span class="cov0" title="0">{
        prints := []any{}
        for _, value := range v </span><span class="cov0" title="0">{
                // if v is a string then print it directly
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        prints = append(prints, str)
                        continue</span>
                }

                <span class="cov0" title="0">if str, ok := value.(*string); ok </span><span class="cov0" title="0">{
                        prints = append(prints, *str)
                        continue</span>
                }

                <span class="cov0" title="0">if intValue, ok := value.(int); ok </span><span class="cov0" title="0">{
                        prints = append(prints, strconv.Itoa(intValue))
                        continue</span>
                }

                <span class="cov0" title="0">if intValue, ok := value.(*int); ok </span><span class="cov0" title="0">{
                        prints = append(prints, strconv.Itoa(*intValue))
                        continue</span>
                }

                <span class="cov0" title="0">if intValue, ok := value.(int64); ok </span><span class="cov0" title="0">{
                        prints = append(prints, strconv.FormatInt(intValue, 10))
                        continue</span>
                }

                <span class="cov0" title="0">if intValue, ok := value.(*int64); ok </span><span class="cov0" title="0">{
                        prints = append(prints, strconv.FormatInt(*intValue, 10))
                        continue</span>
                }

                <span class="cov0" title="0">if floatValue, ok := value.(float64); ok </span><span class="cov0" title="0">{
                        prints = append(prints, strconv.FormatFloat(floatValue, 'f', -1, 64))
                        continue</span>
                }

                <span class="cov0" title="0">if floatValue, ok := value.(*float64); ok </span><span class="cov0" title="0">{
                        prints = append(prints, strconv.FormatFloat(*floatValue, 'f', -1, 64))
                        continue</span>
                }

                // default to pretty print
                <span class="cov0" title="0">prints = append(prints, MapToPretty(value))</span>
        }

        <span class="cov0" title="0">return prints</span>
}

func MapToPretty(v interface{}) string <span class="cov0" title="0">{
        b, err := json.MarshalIndent(v, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package docker

import (
        "context"
        "fmt"
        "io"
        "os"
        "strings"
        "sync"

        "github.com/docker/docker/api/types"
        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/pkg/stdcopy"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner"
)

// DockerClient defines the Docker API methods we need
type DockerClient interface {
        ContainerExecCreate(ctx context.Context, containerID string, config container.ExecOptions) (container.ExecCreateResponse, error)
        ContainerExecAttach(ctx context.Context, execID string, config container.ExecStartOptions) (types.HijackedResponse, error)
        ContainerExecInspect(ctx context.Context, execID string) (container.ExecInspect, error)
        ContainerExecResize(ctx context.Context, execID string, options container.ResizeOptions) error
}

// DockerExecStream implements the runner.ExecStream interface for Docker containers.
type DockerExecStream struct {
        cli           DockerClient
        execID        string
        containerID   string
        instanceID    string
        logger        log.Logger
        hijackedResp  types.HijackedResponse
        ctx           context.Context
        cancel        context.CancelFunc
        wg            sync.WaitGroup
        stdout        *readWritePipe
        stderr        *readWritePipe
        combined      io.Reader
        mutex         sync.Mutex
        tty           bool
        closed        bool
        exitCodeMutex sync.Mutex
        exitCode      int
        exitErr       error
}

// NewDockerExecStream creates a new DockerExecStream.
func NewDockerExecStream(
        ctx context.Context,
        cli DockerClient,
        containerID string,
        instanceID string,
        options runner.ExecOptions,
        logger log.Logger,
) (*DockerExecStream, error) <span class="cov0" title="0">{
        // Create cancellable context
        execCtx, cancel := context.WithCancel(ctx)

        // Prepare exec config - using the container package types
        config := container.ExecOptions{
                Cmd:          options.Command,
                AttachStdin:  true,
                AttachStdout: true,
                AttachStderr: true,
                Tty:          options.TTY,
                Detach:       false,
        }

        // Add environment variables if provided
        if len(options.Env) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range options.Env </span><span class="cov0" title="0">{
                        config.Env = append(config.Env, fmt.Sprintf("%s=%s", k, v))
                }</span>
        }

        // Add working directory if provided
        <span class="cov0" title="0">if options.WorkingDir != "" </span><span class="cov0" title="0">{
                config.WorkingDir = options.WorkingDir
        }</span>

        // Create exec instance
        <span class="cov0" title="0">logger.Debug("Creating exec instance",
                log.Str("containerId", containerID),
                log.Str("cmd", fmt.Sprintf("%v", options.Command)))
        resp, err := cli.ContainerExecCreate(execCtx, containerID, config)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to create exec: %w", err)
        }</span>

        // Connect to exec instance
        <span class="cov0" title="0">logger.Debug("Connecting to exec instance", log.Str("execId", resp.ID))
        attachResp, err := cli.ContainerExecAttach(execCtx, resp.ID, container.ExecStartOptions{
                Tty: options.TTY,
        })
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to attach to exec: %w", err)
        }</span>

        <span class="cov0" title="0">var stdout, stderr *readWritePipe
        var combined io.Reader

        // Set up I/O streams
        if options.TTY </span><span class="cov0" title="0">{
                // With TTY, stdout and stderr are combined
                stdout = newReadWritePipe()
                stderr = newReadWritePipe() // Will be mostly unused with TTY
                combined = attachResp.Reader
        }</span> else<span class="cov0" title="0"> {
                // Without TTY, use stdcopy to demultiplex
                stdout = newReadWritePipe()
                stderr = newReadWritePipe()

                // We don't need to set combined as we'll handle demuxing explicitly
        }</span>

        // Create the exec stream
        <span class="cov0" title="0">stream := &amp;DockerExecStream{
                cli:          cli,
                execID:       resp.ID,
                containerID:  containerID,
                instanceID:   instanceID,
                logger:       logger.WithComponent("docker-exec-stream"),
                hijackedResp: attachResp,
                ctx:          execCtx,
                cancel:       cancel,
                stdout:       stdout,
                stderr:       stderr,
                combined:     combined,
                tty:          options.TTY,
        }

        // Start handling I/O
        stream.startIOCopy()

        // Set up terminal size if using TTY
        if options.TTY &amp;&amp; options.TerminalWidth &gt; 0 &amp;&amp; options.TerminalHeight &gt; 0 </span><span class="cov0" title="0">{
                if err := stream.ResizeTerminal(options.TerminalWidth, options.TerminalHeight); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to set initial terminal size", log.Err(err))
                }</span>
        }

        <span class="cov0" title="0">return stream, nil</span>
}

// Write sends data to the standard input of the process.
func (s *DockerExecStream) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        if s.closed </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("exec stream is closed")
        }</span>

        <span class="cov0" title="0">return s.hijackedResp.Conn.Write(p)</span>
}

// Read reads data from the standard output of the process.
func (s *DockerExecStream) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if s.closed </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("exec stream is closed")
        }</span>

        <span class="cov0" title="0">return s.stdout.Read(p)</span>
}

// Stderr provides access to the standard error stream of the process.
func (s *DockerExecStream) Stderr() io.Reader <span class="cov0" title="0">{
        return s.stderr
}</span>

// ResizeTerminal resizes the terminal (if TTY was enabled).
func (s *DockerExecStream) ResizeTerminal(width, height uint32) error <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        if s.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("exec stream is closed")
        }</span>

        <span class="cov8" title="1">if !s.tty </span><span class="cov0" title="0">{
                return fmt.Errorf("terminal resize requires TTY mode")
        }</span>

        // Using the container package types
        <span class="cov8" title="1">return s.cli.ContainerExecResize(s.ctx, s.execID, container.ResizeOptions{
                Height: uint(height),
                Width:  uint(width),
        })</span>
}

// Signal sends a signal to the process.
func (s *DockerExecStream) Signal(sigName string) error <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        if s.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("exec stream is closed")
        }</span>

        // Docker doesn't have a direct way to send signals to exec processes
        // For SIGINT, we can send Ctrl+C if TTY is enabled
        <span class="cov8" title="1">if s.tty &amp;&amp; strings.ToUpper(sigName) == "SIGINT" </span><span class="cov0" title="0">{
                _, err := s.hijackedResp.Conn.Write([]byte{3}) // Ctrl+C
                return err
        }</span>

        // For other signals, we need to create a signal proxy in the container
        // This is a limitation of the Docker API
        <span class="cov8" title="1">s.logger.Warn("Signal not supported for Docker exec", log.Str("signal", sigName))
        return fmt.Errorf("sending signal %s not supported for Docker exec", sigName)</span>
}

// ExitCode returns the exit code after the process has completed.
func (s *DockerExecStream) ExitCode() (int, error) <span class="cov8" title="1">{
        s.exitCodeMutex.Lock()
        defer s.exitCodeMutex.Unlock()

        if s.exitErr != nil </span><span class="cov0" title="0">{
                return s.exitCode, s.exitErr
        }</span>

        // If exit code is already known, return it
        <span class="cov8" title="1">if s.exitCode != 0 || s.closed </span><span class="cov0" title="0">{
                return s.exitCode, nil
        }</span>

        // Inspect the exec instance to get exit code
        <span class="cov8" title="1">resp, err := s.cli.ContainerExecInspect(s.ctx, s.execID)
        if err != nil </span><span class="cov0" title="0">{
                s.exitErr = fmt.Errorf("failed to inspect exec: %w", err)
                return 0, s.exitErr
        }</span>

        // If the process is still running, return an error
        <span class="cov8" title="1">if resp.Running </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("process is still running")
        }</span>

        <span class="cov8" title="1">s.exitCode = resp.ExitCode
        return s.exitCode, nil</span>
}

// Close terminates the exec session and releases resources.
func (s *DockerExecStream) Close() error <span class="cov0" title="0">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        if s.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Mark as closed
        <span class="cov0" title="0">s.closed = true

        // Cancel context to stop all operations
        s.cancel()

        // Close hijacked connection
        s.hijackedResp.Close()

        // Wait for I/O goroutines to finish
        s.wg.Wait()

        // Close pipes
        s.stdout.Close()
        s.stderr.Close()

        return nil</span>
}

// startIOCopy starts goroutines to handle I/O copying.
func (s *DockerExecStream) startIOCopy() <span class="cov0" title="0">{
        s.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer s.wg.Done()
                defer func() </span><span class="cov0" title="0">{
                        s.hijackedResp.Close()
                }</span>()

                <span class="cov0" title="0">if s.tty </span><span class="cov0" title="0">{
                        // With TTY, stdout and stderr are combined
                        _, err := io.Copy(s.stdout, s.combined)
                        if err != nil &amp;&amp; !isClosedError(err) </span><span class="cov0" title="0">{
                                s.logger.Warn("Error copying output with TTY", log.Err(err))
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Without TTY, demultiplex stdout and stderr
                        _, err := stdcopy.StdCopy(s.stdout, s.stderr, s.hijackedResp.Reader)
                        if err != nil &amp;&amp; !isClosedError(err) </span><span class="cov0" title="0">{
                                s.logger.Warn("Error copying demultiplexed output", log.Err(err))
                        }</span>
                }

                // After I/O is done, get exit code
                <span class="cov0" title="0">s.exitCodeMutex.Lock()
                defer s.exitCodeMutex.Unlock()

                resp, err := s.cli.ContainerExecInspect(context.Background(), s.execID)
                if err != nil </span><span class="cov0" title="0">{
                        s.exitErr = fmt.Errorf("failed to inspect exec after completion: %w", err)
                        return
                }</span>
                <span class="cov0" title="0">s.exitCode = resp.ExitCode</span>
        }()
}

// readWritePipe is a pipe that can be read from and written to.
type readWritePipe struct {
        reader *io.PipeReader
        writer *io.PipeWriter
}

// newReadWritePipe creates a new readWritePipe.
func newReadWritePipe() *readWritePipe <span class="cov0" title="0">{
        r, w := io.Pipe()
        return &amp;readWritePipe{
                reader: r,
                writer: w,
        }
}</span>

// Read reads from the pipe.
func (p *readWritePipe) Read(data []byte) (int, error) <span class="cov0" title="0">{
        return p.reader.Read(data)
}</span>

// Write writes to the pipe.
func (p *readWritePipe) Write(data []byte) (int, error) <span class="cov0" title="0">{
        return p.writer.Write(data)
}</span>

// Close closes both ends of the pipe.
func (p *readWritePipe) Close() error <span class="cov0" title="0">{
        err1 := p.reader.Close()
        err2 := p.writer.Close()
        if err1 != nil </span><span class="cov0" title="0">{
                return err1
        }</span>
        <span class="cov0" title="0">return err2</span>
}

// isClosedError checks if an error is due to a closed connection.
func isClosedError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return err == io.EOF ||
                strings.Contains(err.Error(), "closed") ||
                strings.Contains(err.Error(), "EOF") ||
                err == io.ErrClosedPipe ||
                err == os.ErrClosed</span>
}

// SliceStringer creates a string formatter for string slices.
type SliceStringer []string

// String implements the fmt.Stringer interface.
func (s SliceStringer) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v", []string(s))
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package docker

import (
        "bytes"
        "encoding/binary"
        "io"
)

// dockerLogReader is an io.ReadCloser that demultiplexes the Docker log format
// which interleaves stdout and stderr with headers.
type dockerLogReader struct {
        reader io.ReadCloser
        buffer *bytes.Buffer
        header [8]byte // Docker log header is 8 bytes
        remain int     // Remaining bytes in the current frame
}

// newLogReader creates a new log reader that demultiplexes Docker logs.
func newLogReader(reader io.ReadCloser) io.ReadCloser <span class="cov8" title="1">{
        return &amp;dockerLogReader{
                reader: reader,
                buffer: bytes.NewBuffer(nil),
                remain: 0,
        }
}</span>

// Read implements io.Reader for the log reader.
// This function handles the Docker log format, which consists of:
// - 8-byte header: [stream type byte][0 byte][0 byte][0 byte][frame size as uint32]
// - frame content: [frame size bytes]
// This repeats for each frame. We need to strip the headers and return just the content.
func (r *dockerLogReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        // Return any data we already have in the buffer
        if r.buffer.Len() &gt; 0 </span><span class="cov0" title="0">{
                return r.buffer.Read(p)
        }</span>

        // If we don't have any data remaining in the current frame, read a new frame
        <span class="cov8" title="1">if r.remain == 0 </span><span class="cov8" title="1">{
                // Read the 8-byte header
                if _, err := io.ReadFull(r.reader, r.header[:]); err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                return 0, io.EOF
                        }</span>
                        <span class="cov0" title="0">return 0, err</span>
                }

                // Extract the frame size from bytes 4-7 (uint32, big endian)
                <span class="cov8" title="1">r.remain = int(binary.BigEndian.Uint32(r.header[4:]))</span>
        }

        // Read up to the remaining bytes in the frame
        <span class="cov8" title="1">toRead := len(p)
        if toRead &gt; r.remain </span><span class="cov0" title="0">{
                toRead = r.remain
        }</span>

        // Read the content
        <span class="cov8" title="1">n, err := io.ReadFull(r.reader, p[:toRead])
        r.remain -= n

        if err != nil &amp;&amp; err != io.ErrUnexpectedEOF </span><span class="cov0" title="0">{
                return n, err
        }</span>

        <span class="cov8" title="1">return n, nil</span>
}

// Close implements io.Closer.
func (r *dockerLogReader) Close() error <span class="cov8" title="1">{
        return r.reader.Close()
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">// Package docker provides a Docker-based implementation of the runner interface.
package docker

import (
        "context"
        "fmt"
        "io"
        "time"

        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/api/types/filters"
        "github.com/docker/docker/client"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner"
        "github.com/rzbill/rune/pkg/types"
        runetypes "github.com/rzbill/rune/pkg/types"
)

// Validate that DockerRunner implements the runner.Runner interface
var _ runner.Runner = &amp;DockerRunner{}

// DockerRunner implements the runner.Runner interface for Docker.
type DockerRunner struct {
        client *client.Client
        logger log.Logger
}

func (r *DockerRunner) Type() types.RunnerType <span class="cov0" title="0">{
        return types.RunnerTypeDocker
}</span>

// NewDockerRunner creates a new DockerRunner instance.
func NewDockerRunner(logger log.Logger) (*DockerRunner, error) <span class="cov8" title="1">{
        // Default to use global logger if none provided
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.GetDefaultLogger().WithComponent("docker-runner")
        }</span>

        // Create Docker client with default configuration
        <span class="cov8" title="1">client, err := client.NewClientWithOpts(client.FromEnv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Docker client: %w", err)
        }</span>

        // Set API version to negotiate the highest supported version
        <span class="cov8" title="1">client.NegotiateAPIVersion(context.Background())

        return &amp;DockerRunner{
                client: client,
                logger: logger,
        }, nil</span>
}

// Create creates a new container but does not start it.
func (r *DockerRunner) Create(ctx context.Context, instance *runetypes.Instance) error <span class="cov8" title="1">{
        if instance == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid instance: nil pointer")
        }</span>

        // Create container config and host config
        <span class="cov8" title="1">containerConfig, hostConfig, err := r.instanceToContainerConfig(instance)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create container configuration: %w", err)
        }</span>

        // Create the container
        <span class="cov8" title="1">resp, err := r.client.ContainerCreate(
                ctx,
                containerConfig,
                hostConfig,
                nil,           // No network config for now
                nil,           // No platform config
                instance.Name, // Use instance name as container name
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create container: %w", err)
        }</span>

        // Update instance with container ID
        <span class="cov8" title="1">instance.ContainerID = resp.ID

        r.logger.Info("Created container for instance",
                log.Str("container_id", resp.ID),
                log.Str("instance_id", instance.ID))

        return nil</span>
}

// Start starts an existing container.
func (r *DockerRunner) Start(ctx context.Context, instance *runetypes.Instance) error <span class="cov8" title="1">{
        containerID, err := r.getContainerID(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get container ID: %w", err)
        }</span>

        // Start the container - using empty StartOptions as we don't need any special configuration
        <span class="cov8" title="1">if err := r.client.ContainerStart(ctx, containerID, container.StartOptions{}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start container: %w", err)
        }</span>

        <span class="cov8" title="1">r.logger.Info("Started container for instance",
                log.Str("container_id", containerID),
                log.Str("instance_id", instance.ID),
                log.Str("instance_name", instance.Name),
                log.Str("instance_status", string(instance.Status)))

        return nil</span>
}

// Stop stops a running container.
func (r *DockerRunner) Stop(ctx context.Context, instance *runetypes.Instance, timeout time.Duration) error <span class="cov0" title="0">{
        containerID, err := r.getContainerID(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get container ID: %w", err)
        }</span>

        // Convert timeout to seconds
        <span class="cov0" title="0">timeoutSeconds := int(timeout.Seconds())

        // Stop the container
        if err := r.client.ContainerStop(ctx, containerID, container.StopOptions{Timeout: &amp;timeoutSeconds}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop container: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.Info("Stopped container for instance",
                log.Str("container_id", containerID),
                log.Str("instance_id", instance.ID))

        return nil</span>
}

// Remove removes a container.
func (r *DockerRunner) Remove(ctx context.Context, instance *runetypes.Instance, force bool) error <span class="cov8" title="1">{
        containerID, err := r.getContainerID(ctx, instance)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get container ID: %w", err)
        }</span>

        // Remove the container
        <span class="cov8" title="1">options := container.RemoveOptions{
                Force: force,
        }

        if err := r.client.ContainerRemove(ctx, containerID, options); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove container: %w", err)
        }</span>

        <span class="cov8" title="1">r.logger.Info("Removed container for instance",
                log.Str("container_id", containerID),
                log.Str("instance_id", instance.ID))

        return nil</span>
}

// GetLogs retrieves logs from a container.
func (r *DockerRunner) GetLogs(ctx context.Context, instance *runetypes.Instance, options runner.LogOptions) (io.ReadCloser, error) <span class="cov0" title="0">{
        containerID, err := r.getContainerID(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get container ID: %w", err)
        }</span>

        // Convert our options to Docker options
        <span class="cov0" title="0">since := options.Since.Format(time.RFC3339Nano)
        until := options.Until.Format(time.RFC3339Nano)

        // Convert tail option to string
        var tail string
        if options.Tail &lt;= 0 </span><span class="cov0" title="0">{
                tail = "all"
        }</span> else<span class="cov0" title="0"> {
                tail = fmt.Sprintf("%d", options.Tail)
        }</span>

        // Prepare Docker API log options
        <span class="cov0" title="0">logsOptions := container.LogsOptions{
                ShowStdout: true,
                ShowStderr: true,
                Follow:     options.Follow,
                Timestamps: options.Timestamps,
                Since:      since,
                Until:      until,
                Tail:       tail,
        }

        // Get logs from Docker
        logs, err := r.client.ContainerLogs(ctx, containerID, logsOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get container logs: %w", err)
        }</span>

        // Docker multiplexes stdout and stderr, so we need to demultiplex
        <span class="cov0" title="0">return newLogReader(logs), nil</span>
}

// Status retrieves the current status of a container.
func (r *DockerRunner) Status(ctx context.Context, instance *runetypes.Instance) (runetypes.InstanceStatus, error) <span class="cov8" title="1">{
        containerID, err := r.getContainerID(ctx, instance)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to get container ID: %w", err)
        }</span>

        // Get container information
        <span class="cov0" title="0">container, err := r.client.ContainerInspect(ctx, containerID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to inspect container: %w", err)
        }</span>

        // Map Docker state to Rune instance status
        <span class="cov0" title="0">if container.State.Running </span><span class="cov0" title="0">{
                return runetypes.InstanceStatusRunning, nil
        }</span> else<span class="cov0" title="0"> if container.State.ExitCode != 0 </span><span class="cov0" title="0">{
                return runetypes.InstanceStatusFailed, nil
        }</span> else<span class="cov0" title="0"> {
                return runetypes.InstanceStatusStopped, nil
        }</span>
}

// List lists all service instances managed by this runner.
func (r *DockerRunner) List(ctx context.Context, namespace string) ([]*runetypes.Instance, error) <span class="cov8" title="1">{
        // Filter containers managed by this runner
        args := filters.NewArgs(
                filters.Arg("label", "rune.managed=true"),
        )

        if namespace != "" </span><span class="cov8" title="1">{
                args.Add("label", "rune.namespace="+namespace)
        }</span>

        <span class="cov8" title="1">containers, err := r.client.ContainerList(ctx, container.ListOptions{
                All:     true, // Include stopped containers
                Filters: args,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list containers: %w", err)
        }</span>

        // Convert Docker API types to Rune types
        <span class="cov8" title="1">instances := make([]*runetypes.Instance, 0, len(containers))

        for _, c := range containers </span><span class="cov8" title="1">{
                // Extract instance information from container labels
                instanceID := c.Labels["rune.instance.id"]
                if instanceID == "" </span><span class="cov0" title="0">{
                        r.logger.Warn("Found container without instance ID",
                                log.Str("container_id", c.ID),
                                log.Str("container_name", c.Names[0]))
                        continue</span>
                }

                // Create instance object
                <span class="cov8" title="1">instance := &amp;runetypes.Instance{
                        ID:          instanceID,
                        ContainerID: c.ID,
                        Name:        c.Names[0][1:], // Remove leading slash from container name
                        ServiceID:   c.Labels["rune.service.id"],
                        NodeID:      "local", // Assume local node for now
                }

                // Set status based on container state
                switch c.State </span>{
                case "running":<span class="cov0" title="0">
                        instance.Status = runetypes.InstanceStatusRunning</span>
                case "exited":<span class="cov0" title="0">
                        // For exited containers, we need to inspect to get the exit code
                        inspect, err := r.client.ContainerInspect(ctx, c.ID)
                        if err == nil &amp;&amp; inspect.State.ExitCode != 0 </span><span class="cov0" title="0">{
                                instance.Status = runetypes.InstanceStatusFailed
                        }</span> else<span class="cov0" title="0"> {
                                instance.Status = runetypes.InstanceStatusStopped
                        }</span>
                case "created":<span class="cov8" title="1">
                        instance.Status = runetypes.InstanceStatusPending</span>
                default:<span class="cov0" title="0">
                        instance.Status = ""</span>
                }

                <span class="cov8" title="1">instances = append(instances, instance)</span>
        }

        <span class="cov8" title="1">return instances, nil</span>
}

// Exec creates an interactive exec session with a running container.
func (r *DockerRunner) Exec(ctx context.Context, instance *runetypes.Instance, options runner.ExecOptions) (runner.ExecStream, error) <span class="cov0" title="0">{
        containerID, err := r.getContainerID(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get container ID: %w", err)
        }</span>

        // Check if the container is running
        <span class="cov0" title="0">container, err := r.client.ContainerInspect(ctx, containerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to inspect container: %w", err)
        }</span>

        <span class="cov0" title="0">if !container.State.Running </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container is not running")
        }</span>

        // Create the exec stream
        <span class="cov0" title="0">execStream, err := NewDockerExecStream(ctx, r.client, containerID, instance.ID, options, r.logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create exec stream: %w", err)
        }</span>

        <span class="cov0" title="0">return execStream, nil</span>
}

// getContainerID gets the container ID for an instance.
func (r *DockerRunner) getContainerID(ctx context.Context, instance *runetypes.Instance) (string, error) <span class="cov8" title="1">{
        // Try to get the container directly from the instance ID using labels
        args := filters.NewArgs(
                filters.Arg("label", "rune.managed=true"),
                filters.Arg("label", "rune.instance.id="+instance.ID),
        )

        if instance.Namespace != "" </span><span class="cov8" title="1">{
                args.Add("label", "rune.namespace="+instance.Namespace)
        }</span>

        <span class="cov8" title="1">containers, err := r.client.ContainerList(ctx, container.ListOptions{
                All:     true, // Include stopped containers
                Filters: args,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to list containers: %w", err)
        }</span>

        <span class="cov8" title="1">if len(containers) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no container found for instance ID: %s", instance.ID)
        }</span>

        <span class="cov8" title="1">if len(containers) &gt; 1 </span><span class="cov0" title="0">{
                r.logger.Warn("Multiple containers found for instance ID",
                        log.Str("instance_id", instance.ID),
                        log.Int("container_count", len(containers)))
        }</span>

        // Return the first matching container
        <span class="cov8" title="1">return containers[0].ID, nil</span>
}

// instanceToContainerConfig converts a Rune instance to Docker container config.
func (r *DockerRunner) instanceToContainerConfig(instance *runetypes.Instance) (*container.Config, *container.HostConfig, error) <span class="cov8" title="1">{
        // Extract service ID from the instance
        serviceID := instance.ServiceID
        if serviceID == "" </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("service ID is required")
        }</span>

        // For now, use a simple container configuration with a fixed image
        // In a real implementation, this would be derived from the service definition
        <span class="cov8" title="1">containerConfig := &amp;container.Config{
                Image: "nginx:latest", // Fixed image for testing
                Labels: map[string]string{
                        "rune.managed":      "true",
                        "rune.namespace":    instance.Namespace,
                        "rune.instance.id":  instance.ID,
                        "rune.service.id":   serviceID,
                        "rune.service.name": instance.Name,
                },
                Env: formatEnvVars(instance.Environment),
        }

        // Simple host config with no special settings
        hostConfig := &amp;container.HostConfig{}

        return containerConfig, hostConfig, nil</span>
}

// formatEnvVars formats a map of environment variables into a slice of "key=value" strings.
func formatEnvVars(env map[string]string) []string <span class="cov8" title="1">{
        result := make([]string, 0, len(env))
        for k, v := range env </span><span class="cov0" title="0">{
                result = append(result, fmt.Sprintf("%s=%s", k, v))
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">// Package runner provides interfaces and implementations for managing service instances.
package runner

import (
        "context"
        "io"
        "time"

        "github.com/rzbill/rune/pkg/types"
)

// Runner defines the interface for service runners, which are responsible for
// managing the lifecycle of service instances (containers, processes, etc.).
type Runner interface {
        // Type returns the type of runner.
        Type() types.RunnerType

        // Create creates a new service instance but does not start it.
        Create(ctx context.Context, instance *types.Instance) error

        // Start starts an existing service instance.
        Start(ctx context.Context, instance *types.Instance) error

        // Stop stops a running service instance.
        Stop(ctx context.Context, instance *types.Instance, timeout time.Duration) error

        // Remove removes a service instance.
        Remove(ctx context.Context, instance *types.Instance, force bool) error

        // GetLogs retrieves logs from a service instance.
        GetLogs(ctx context.Context, instance *types.Instance, options LogOptions) (io.ReadCloser, error)

        // Status retrieves the current status of a service instance.
        Status(ctx context.Context, instance *types.Instance) (types.InstanceStatus, error)

        // List lists all service instances managed by this runner.
        List(ctx context.Context, namespace string) ([]*types.Instance, error)

        // Exec creates an interactive exec session with a running instance.
        // Returns an ExecStream for bidirectional communication.
        Exec(ctx context.Context, instance *types.Instance, options ExecOptions) (ExecStream, error)
}

// LogOptions defines options for retrieving logs.
type LogOptions struct {
        // Follow indicates whether to follow the log output (like tail -f).
        Follow bool

        // Tail indicates the number of lines to show from the end of the logs (0 for all).
        Tail int

        // Since shows logs since a specific timestamp.
        Since time.Time

        // Until shows logs until a specific timestamp.
        Until time.Time

        // Timestamps indicates whether to include timestamps.
        Timestamps bool
}

// InstanceStatus extends types.InstanceStatus with additional details needed by runners.
type InstanceStatus struct {
        // State is the current state of the instance.
        State types.InstanceStatus

        // ContainerID is the ID of the container (if applicable).
        ContainerID string

        // InstanceID is the ID of the Rune instance.
        InstanceID string

        // CreatedAt is when the instance was created.
        CreatedAt time.Time

        // StartedAt is when the instance was started.
        StartedAt time.Time

        // FinishedAt is when the instance finished or failed.
        FinishedAt time.Time

        // ExitCode is the exit code if the instance has stopped.
        ExitCode int

        // ErrorMessage contains any error information.
        ErrorMessage string
}

// ExecOptions defines options for executing a command in a running instance.
type ExecOptions struct {
        // Command is the command to execute.
        Command []string

        // Env is a map of environment variables to set for the command.
        Env map[string]string

        // WorkingDir is the working directory for the command.
        WorkingDir string

        // TTY indicates whether to allocate a pseudo-TTY.
        TTY bool

        // TerminalWidth is the initial width of the terminal.
        TerminalWidth uint32

        // TerminalHeight is the initial height of the terminal.
        TerminalHeight uint32
}

// ExecStream provides bidirectional communication with an exec session.
type ExecStream interface {
        // Write writes data to the standard input of the process.
        Write(p []byte) (n int, err error)

        // Read reads data from the standard output of the process.
        Read(p []byte) (n int, err error)

        // Stderr provides access to the standard error stream of the process.
        Stderr() io.Reader

        // ResizeTerminal resizes the terminal (if TTY was enabled).
        ResizeTerminal(width, height uint32) error

        // Signal sends a signal to the process.
        Signal(sigName string) error

        // ExitCode returns the exit code after the process has completed.
        // Returns an error if the process has not completed or if there was an error.
        ExitCode() (int, error)

        // Close terminates the exec session and releases resources.
        Close() error
}

// GetExecOptions returns ExecOptions using values from the instance
func GetExecOptions(command []string, instance *types.Instance) ExecOptions <span class="cov0" title="0">{
        opts := ExecOptions{
                Command: command,
                TTY:     false,
        }

        // Use instance environment if available
        if instance != nil &amp;&amp; instance.Environment != nil </span><span class="cov0" title="0">{
                opts.Env = instance.Environment
        }</span> else<span class="cov0" title="0"> {
                opts.Env = make(map[string]string)
        }</span>

        <span class="cov0" title="0">return opts</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package manager

import (
        "sync"

        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner"
        "github.com/rzbill/rune/pkg/runner/docker"
        "github.com/rzbill/rune/pkg/runner/process"
        "github.com/rzbill/rune/pkg/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// Error is a simple error type
type Error string

func (e Error) Error() string <span class="cov0" title="0">{ return string(e) }</span>

// Define errors
var (
        ErrNotInitialized            = Error("runner manager not initialized")
        ErrDockerRunnerNotAvailable  = Error("docker runner not available")
        ErrProcessRunnerNotAvailable = Error("process runner not available")
)

// RunnerManager provides centralized access to various runners
type RunnerManager struct {
        dockerRunner  runner.Runner
        processRunner runner.Runner
        logger        log.Logger
        mutex         sync.RWMutex
        initialized   bool
}

// NewRunnerManager creates a new runner manager
func NewRunnerManager(logger log.Logger) *RunnerManager <span class="cov8" title="1">{
        return &amp;RunnerManager{
                logger: logger.WithComponent("runner-manager"),
        }
}</span>

// Initialize initializes all runners
func (m *RunnerManager) Initialize() error <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if m.initialized </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create Docker runner
        <span class="cov8" title="1">dockerRunner, err := docker.NewDockerRunner(m.logger.WithComponent("docker-runner"))
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Warn("Failed to initialize Docker runner", log.Err(err))
        }</span> else<span class="cov8" title="1"> {
                m.dockerRunner = dockerRunner
        }</span>

        // Create Process runner
        <span class="cov8" title="1">processRunner, err := process.NewProcessRunner(
                process.WithLogger(m.logger.WithComponent("process-runner")),
        )
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Warn("Failed to initialize Process runner", log.Err(err))
        }</span> else<span class="cov8" title="1"> {
                m.processRunner = processRunner
        }</span>

        <span class="cov8" title="1">m.initialized = true
        return nil</span>
}

// GetDockerRunner returns the Docker runner
func (m *RunnerManager) GetDockerRunner() (runner.Runner, error) <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if !m.initialized </span><span class="cov0" title="0">{
                return nil, ErrNotInitialized
        }</span>

        <span class="cov8" title="1">if m.dockerRunner == nil </span><span class="cov0" title="0">{
                return nil, ErrDockerRunnerNotAvailable
        }</span>

        <span class="cov8" title="1">return m.dockerRunner, nil</span>
}

// GetProcessRunner returns the Process runner
func (m *RunnerManager) GetProcessRunner() (runner.Runner, error) <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if !m.initialized </span><span class="cov0" title="0">{
                return nil, ErrNotInitialized
        }</span>

        <span class="cov8" title="1">if m.processRunner == nil </span><span class="cov0" title="0">{
                return nil, ErrProcessRunnerNotAvailable
        }</span>

        <span class="cov8" title="1">return m.processRunner, nil</span>
}

// Close closes all runners
func (m *RunnerManager) Close() error <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        // Close runners if they implement a Close method
        if closer, ok := m.dockerRunner.(interface{ Close() error }); ok </span><span class="cov0" title="0">{
                if err := closer.Close(); err != nil </span><span class="cov0" title="0">{
                        m.logger.Warn("Error closing Docker runner", log.Err(err))
                }</span>
        }

        <span class="cov0" title="0">if closer, ok := m.processRunner.(interface{ Close() error }); ok </span><span class="cov0" title="0">{
                if err := closer.Close(); err != nil </span><span class="cov0" title="0">{
                        m.logger.Warn("Error closing Process runner", log.Err(err))
                }</span>
        }

        <span class="cov0" title="0">m.initialized = false
        return nil</span>
}

// GetInstanceRunner returns the appropriate runner to use for the given instance.
func (m *RunnerManager) GetInstanceRunner(instance *types.Instance) (runner.Runner, error) <span class="cov8" title="1">{
        switch instance.Runner </span>{
        case types.RunnerTypeDocker:<span class="cov0" title="0">
                dockerRunner, err := m.GetDockerRunner()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Unavailable, "docker runner not available")
                }</span>
                <span class="cov0" title="0">return dockerRunner, nil</span>

        case types.RunnerTypeProcess:<span class="cov0" title="0">
                processRunner, err := m.GetProcessRunner()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Unavailable, "process runner not available")
                }</span>
                <span class="cov0" title="0">return processRunner, nil</span>

        default:<span class="cov8" title="1">
                // Fallback to existing heuristic for backward compatibility
                if instance.ContainerID != "" </span><span class="cov8" title="1">{
                        dockerRunner, err := m.GetDockerRunner()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Unavailable, "docker runner not available")
                        }</span>
                        <span class="cov8" title="1">return dockerRunner, nil</span>
                } else<span class="cov0" title="0"> {
                        processRunner, err := m.GetProcessRunner()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Unavailable, "process runner not available")
                        }</span>
                        <span class="cov0" title="0">return processRunner, nil</span>
                }
        }
}

// GetServiceRunner returns the appropriate runner to use for the given service.
func (m *RunnerManager) GetServiceRunner(service *types.Service) (runner.Runner, error) <span class="cov0" title="0">{
        if service.Runtime == types.RuntimeTypeProcess </span><span class="cov0" title="0">{
                processRunner, err := m.GetProcessRunner()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Unavailable, "process runner not available")
                }</span>
                <span class="cov0" title="0">return processRunner, nil</span>
        }

        <span class="cov0" title="0">dockerRunner, err := m.GetDockerRunner()
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unavailable, "docker runner not available")
        }</span>

        <span class="cov0" title="0">return dockerRunner, nil</span>
}

/*
// SetDockerRunner sets a custom Docker runner (for testing)
func (m *RunnerManager) SetDockerRunner(runner runner.Runner) {
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.dockerRunner = runner
        if !m.initialized {
                m.initialized = true
        }
}

// SetProcessRunner sets a custom Process runner (for testing)
func (m *RunnerManager) SetProcessRunner(runner runner.Runner) {
        m.mutex.Lock()
        defer m.mutex.Unlock()
        m.processRunner = runner
        if !m.initialized {
                m.initialized = true
        }
}*/
</pre>
		
		<pre class="file" id="file75" style="display: none">package manager

import (
        "github.com/rzbill/rune/pkg/runner"
        "github.com/rzbill/rune/pkg/types"
)

// Ensure TestRunnerManager implements the IRunnerManager interface
var _ IRunnerManager = (*TestRunnerManager)(nil)

// TestRunnerManager is a mock implementation of IRunnerManager for testing purposes
type TestRunnerManager struct {
        // Test runners that will be returned by the respective getter methods
        MockDockerRunner  runner.Runner
        MockProcessRunner runner.Runner
        DefaultRunner     runner.Runner // Used when neither is specified

        // Track calls for testing assertions
        GetDockerCalled   bool
        GetProcessCalled  bool
        GetInstanceCalled bool
        GetServiceCalled  bool
        InitializeCalled  bool
        CloseCalled       bool
}

// Initialize implements the RunnerManager interface
func (m *TestRunnerManager) Initialize() error <span class="cov0" title="0">{
        m.InitializeCalled = true
        return nil
}</span>

// GetDockerRunner implements the RunnerManager interface
func (m *TestRunnerManager) GetDockerRunner() (runner.Runner, error) <span class="cov8" title="1">{
        m.GetDockerCalled = true
        if m.MockDockerRunner != nil </span><span class="cov8" title="1">{
                return m.MockDockerRunner, nil
        }</span>
        <span class="cov0" title="0">return m.DefaultRunner, nil</span>
}

// GetProcessRunner implements the RunnerManager interface
func (m *TestRunnerManager) GetProcessRunner() (runner.Runner, error) <span class="cov8" title="1">{
        m.GetProcessCalled = true
        if m.MockProcessRunner != nil </span><span class="cov8" title="1">{
                return m.MockProcessRunner, nil
        }</span>
        <span class="cov0" title="0">return m.DefaultRunner, nil</span>
}

// GetInstanceRunner implements the RunnerManager interface
func (m *TestRunnerManager) GetInstanceRunner(instance *types.Instance) (runner.Runner, error) <span class="cov8" title="1">{
        m.GetInstanceCalled = true
        if instance.ContainerID != "" </span><span class="cov8" title="1">{
                return m.GetDockerRunner()
        }</span>
        <span class="cov8" title="1">return m.GetProcessRunner()</span>
}

// GetServiceRunner implements the RunnerManager interface
func (m *TestRunnerManager) GetServiceRunner(service *types.Service) (runner.Runner, error) <span class="cov8" title="1">{
        m.GetServiceCalled = true
        if service.Runtime == "container" </span><span class="cov8" title="1">{
                return m.GetDockerRunner()
        }</span>
        <span class="cov0" title="0">return m.GetProcessRunner()</span>
}

// Close implements the RunnerManager interface
func (m *TestRunnerManager) Close() error <span class="cov0" title="0">{
        m.CloseCalled = true
        return nil
}</span>

// SetDockerRunner sets the Docker runner for testing
func (m *TestRunnerManager) SetDockerRunner(r runner.Runner) <span class="cov8" title="1">{
        m.MockDockerRunner = r
}</span>

// SetProcessRunner sets the Process runner for testing
func (m *TestRunnerManager) SetProcessRunner(r runner.Runner) <span class="cov8" title="1">{
        m.MockProcessRunner = r
}</span>

// NewTestRunnerManager creates a new test runner manager
func NewTestRunnerManager(defaultRunner runner.Runner) *TestRunnerManager <span class="cov8" title="1">{
        return &amp;TestRunnerManager{
                DefaultRunner: defaultRunner,
        }
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package runner

import (
        "context"
        "io"
        "time"

        "github.com/rzbill/rune/pkg/types"
        "github.com/stretchr/testify/mock"
)

// MockRunner is a mock implementation of the runner.Runner interface for testing
type MockRunner struct {
        mock.Mock
}

func (m *MockRunner) Create(ctx context.Context, instance *types.Instance) error <span class="cov0" title="0">{
        args := m.Called(ctx, instance)
        return args.Error(0)
}</span>

func (m *MockRunner) Start(ctx context.Context, instance *types.Instance) error <span class="cov0" title="0">{
        args := m.Called(ctx, instance)
        return args.Error(0)
}</span>

func (m *MockRunner) Stop(ctx context.Context, instance *types.Instance, timeout time.Duration) error <span class="cov0" title="0">{
        args := m.Called(ctx, instance, timeout)
        return args.Error(0)
}</span>

func (m *MockRunner) Remove(ctx context.Context, instance *types.Instance, force bool) error <span class="cov0" title="0">{
        args := m.Called(ctx, instance, force)
        return args.Error(0)
}</span>

func (m *MockRunner) GetLogs(ctx context.Context, instance *types.Instance, options LogOptions) (io.ReadCloser, error) <span class="cov0" title="0">{
        args := m.Called(ctx, instance, options)
        return args.Get(0).(io.ReadCloser), args.Error(1)
}</span>

func (m *MockRunner) Status(ctx context.Context, instance *types.Instance) (types.InstanceStatus, error) <span class="cov0" title="0">{
        args := m.Called(ctx, instance)
        return args.Get(0).(types.InstanceStatus), args.Error(1)
}</span>

func (m *MockRunner) List(ctx context.Context, namespace string) ([]*types.Instance, error) <span class="cov0" title="0">{
        args := m.Called(ctx, namespace)
        return args.Get(0).([]*types.Instance), args.Error(1)
}</span>

func (m *MockRunner) Exec(ctx context.Context, instance *types.Instance, options ExecOptions) (ExecStream, error) <span class="cov0" title="0">{
        args := m.Called(ctx, instance, options)
        return args.Get(0).(ExecStream), args.Error(1)
}</span>

// MockExecStream is a mock implementation of the runner.ExecStream interface
type MockExecStream struct {
        mock.Mock
}

func (m *MockExecStream) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        args := m.Called(p)
        return args.Int(0), args.Error(1)
}</span>

func (m *MockExecStream) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        args := m.Called(p)
        return args.Int(0), args.Error(1)
}</span>

func (m *MockExecStream) Stderr() io.Reader <span class="cov0" title="0">{
        args := m.Called()
        return args.Get(0).(io.Reader)
}</span>

func (m *MockExecStream) ResizeTerminal(width, height uint32) error <span class="cov0" title="0">{
        args := m.Called(width, height)
        return args.Error(0)
}</span>

func (m *MockExecStream) Signal(sigName string) error <span class="cov0" title="0">{
        args := m.Called(sigName)
        return args.Error(0)
}</span>

func (m *MockExecStream) ExitCode() (int, error) <span class="cov0" title="0">{
        args := m.Called()
        return args.Int(0), args.Error(1)
}</span>

func (m *MockExecStream) Close() error <span class="cov0" title="0">{
        args := m.Called()
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package process

import (
        "context"
        "fmt"
        "io"
        "os"
        "os/exec"
        "sync"
        "syscall"

        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner"
)

// ProcessExecStream implements the runner.ExecStream interface for processes.
type ProcessExecStream struct {
        ctx           context.Context
        cancel        context.CancelFunc
        cmd           *exec.Cmd
        instanceID    string
        logger        log.Logger
        stdin         io.WriteCloser
        stdout        io.ReadCloser
        stderr        io.ReadCloser
        mutex         sync.Mutex
        closed        bool
        exitCodeMutex sync.Mutex
        exitCode      int
        exitErr       error
        wg            sync.WaitGroup
        doneCh        chan struct{}
}

// NewProcessExecStream creates a new ProcessExecStream.
func NewProcessExecStream(
        ctx context.Context,
        instanceID string,
        options runner.ExecOptions,
        logger log.Logger,
) (*ProcessExecStream, error) <span class="cov8" title="1">{
        // Create cancellable context
        execCtx, cancel := context.WithCancel(ctx)

        // Create command
        cmd := exec.CommandContext(execCtx, options.Command[0], options.Command[1:]...)

        // Set up environment variables
        if len(options.Env) &gt; 0 </span><span class="cov8" title="1">{
                env := os.Environ() // Start with current environment
                for k, v := range options.Env </span><span class="cov8" title="1">{
                        env = append(env, fmt.Sprintf("%s=%s", k, v))
                }</span>
                <span class="cov8" title="1">cmd.Env = env</span>
        }

        // Set working directory if provided
        <span class="cov8" title="1">if options.WorkingDir != "" </span><span class="cov0" title="0">{
                cmd.Dir = options.WorkingDir
        }</span>

        // Set up I/O streams
        <span class="cov8" title="1">stdin, err := cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to create stdin pipe: %w", err)
        }</span>

        <span class="cov8" title="1">stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>

        <span class="cov8" title="1">stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to create stderr pipe: %w", err)
        }</span>

        // Create the exec stream
        <span class="cov8" title="1">stream := &amp;ProcessExecStream{
                ctx:        execCtx,
                cancel:     cancel,
                cmd:        cmd,
                instanceID: instanceID,
                logger:     logger.WithComponent("process-exec-stream"),
                stdin:      stdin,
                stdout:     stdout,
                stderr:     stderr,
                doneCh:     make(chan struct{}),
        }

        // Start the command
        logger.Debug("Starting command",
                log.Str("instanceId", instanceID),
                log.Str("cmd", fmt.Sprintf("%v", options.Command)))

        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to start command: %w", err)
        }</span>

        // Start a goroutine to wait for command completion
        <span class="cov8" title="1">stream.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer stream.wg.Done()
                defer close(stream.doneCh)

                err := cmd.Wait()

                stream.exitCodeMutex.Lock()
                defer stream.exitCodeMutex.Unlock()

                if err != nil </span><span class="cov8" title="1">{
                        stream.exitErr = err
                        if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov8" title="1">{
                                if status, ok := exitErr.Sys().(syscall.WaitStatus); ok </span><span class="cov8" title="1">{
                                        stream.exitCode = status.ExitStatus()
                                        return
                                }</span>
                        }
                        <span class="cov8" title="1">stream.exitCode = 1</span> // Default to 1 for errors
                } else<span class="cov8" title="1"> {
                        stream.exitCode = 0
                }</span>
        }()

        <span class="cov8" title="1">return stream, nil</span>
}

// Write sends data to the standard input of the process.
func (s *ProcessExecStream) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        if s.closed </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("exec stream is closed")
        }</span>

        <span class="cov0" title="0">return s.stdin.Write(p)</span>
}

// Read reads data from the standard output of the process.
func (s *ProcessExecStream) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        if s.closed </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("exec stream is closed")
        }</span>

        <span class="cov8" title="1">return s.stdout.Read(p)</span>
}

// Stderr provides access to the standard error stream of the process.
func (s *ProcessExecStream) Stderr() io.Reader <span class="cov8" title="1">{
        return s.stderr
}</span>

// ResizeTerminal resizes the terminal (if TTY was enabled).
// For processes, terminal resizing isn't typically supported through the Go API.
func (s *ProcessExecStream) ResizeTerminal(width, height uint32) error <span class="cov0" title="0">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        if s.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("exec stream is closed")
        }</span>

        // This is a stub - process TTY resizing requires additional platform-specific code
        <span class="cov0" title="0">s.logger.Warn("Terminal resize not supported for processes")
        return fmt.Errorf("terminal resize not supported for processes")</span>
}

// Signal sends a signal to the process.
func (s *ProcessExecStream) Signal(sigName string) error <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        if s.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("exec stream is closed")
        }</span>

        // Map signal name to syscall signal
        <span class="cov8" title="1">var sig syscall.Signal
        switch sigName </span>{
        case "SIGINT":<span class="cov0" title="0">
                sig = syscall.SIGINT</span>
        case "SIGTERM":<span class="cov8" title="1">
                sig = syscall.SIGTERM</span>
        case "SIGKILL":<span class="cov0" title="0">
                sig = syscall.SIGKILL</span>
        case "SIGHUP":<span class="cov0" title="0">
                sig = syscall.SIGHUP</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown signal: %s", sigName)</span>
        }

        <span class="cov8" title="1">if s.cmd == nil || s.cmd.Process == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("process not started")
        }</span>

        <span class="cov8" title="1">return s.cmd.Process.Signal(sig)</span>
}

// ExitCode returns the exit code after the process has completed.
func (s *ProcessExecStream) ExitCode() (int, error) <span class="cov8" title="1">{
        s.exitCodeMutex.Lock()
        defer s.exitCodeMutex.Unlock()

        // If there's an error, return it
        if s.exitErr != nil &amp;&amp; s.exitCode == 0 </span><span class="cov0" title="0">{
                return s.exitCode, s.exitErr
        }</span>

        // If the process is still running, check
        <span class="cov8" title="1">select </span>{
        case &lt;-s.doneCh:<span class="cov8" title="1">
                // Process has completed
                return s.exitCode, nil</span>
        default:<span class="cov0" title="0">
                // Process is still running
                return 0, fmt.Errorf("process is still running")</span>
        }
}

// Close terminates the exec session and releases resources.
func (s *ProcessExecStream) Close() error <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        if s.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Mark as closed
        <span class="cov8" title="1">s.closed = true

        // Cancel context to stop the command
        s.cancel()

        // Close I/O pipes
        if s.stdin != nil </span><span class="cov8" title="1">{
                s.stdin.Close()
        }</span>

        // We don't close stdout/stderr here as they're automatically closed when the process terminates

        // Wait for all goroutines to finish
        <span class="cov8" title="1">s.wg.Wait()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package process

import (
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strconv"

        "github.com/rzbill/rune/pkg/types"
)

// resourceController handles resource limits for a process.
type resourceController struct {
        pid        int              // Process ID
        cgroupPath string           // Path to cgroup directory
        resources  *types.Resources // Resource limits
}

// newResourceController creates a new resource controller for a process.
func newResourceController(pid int, resources *types.Resources) (*resourceController, error) <span class="cov0" title="0">{
        // This would use OS-specific mechanisms
        // On Linux, this would use cgroups
        // On other platforms, we might have more limited functionality

        // For now, we'll only support Linux cgroups v2
        if runtime.GOOS != "linux" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resource control is only supported on Linux")
        }</span>

        // Check if cgroups v2 is available
        <span class="cov0" title="0">if _, err := os.Stat("/sys/fs/cgroup/cgroup.controllers"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cgroups v2 not available on this system")
        }</span>

        // Create cgroup path
        <span class="cov0" title="0">cgroupPath := fmt.Sprintf("/sys/fs/cgroup/rune/process-%d", pid)

        // Create cgroup directory
        if err := os.MkdirAll(cgroupPath, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cgroup directory: %w", err)
        }</span>

        <span class="cov0" title="0">ctrl := &amp;resourceController{
                pid:        pid,
                cgroupPath: cgroupPath,
                resources:  resources,
        }

        // Apply CPU limits
        if resources != nil &amp;&amp; resources.CPU.Limit != "" || resources.CPU.Request != "" </span><span class="cov0" title="0">{
                limit := resources.CPU.Limit
                if limit == "" </span><span class="cov0" title="0">{
                        limit = resources.CPU.Request
                }</span>

                // Parse and apply the CPU limit
                <span class="cov0" title="0">if err := ctrl.applyCPULimit(limit); err != nil </span><span class="cov0" title="0">{
                        // Log error but continue
                        return ctrl, err
                }</span>
        }

        // Apply memory limits
        <span class="cov0" title="0">if resources != nil &amp;&amp; resources.Memory.Limit != "" || resources.Memory.Request != "" </span><span class="cov0" title="0">{
                limit := resources.Memory.Limit
                if limit == "" </span><span class="cov0" title="0">{
                        limit = resources.Memory.Request
                }</span>

                // Parse and apply the memory limit
                <span class="cov0" title="0">if err := ctrl.applyMemoryLimit(limit); err != nil </span><span class="cov0" title="0">{
                        // Log error but continue
                        return ctrl, err
                }</span>
        }

        // Add process to cgroup
        <span class="cov0" title="0">if err := ctrl.addProcess(); err != nil </span><span class="cov0" title="0">{
                return ctrl, err
        }</span>

        <span class="cov0" title="0">return ctrl, nil</span>
}

// applyCPULimit applies CPU limits to the cgroup.
func (c *resourceController) applyCPULimit(cpuLimit string) error <span class="cov0" title="0">{
        // Parse CPU limit using the helper function
        cpuValue, err := types.ParseCPU(cpuLimit)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid CPU limit format: %w", err)
        }</span>

        // For cgroups v2, we'd write to cpu.max
        <span class="cov0" title="0">cpuMaxPath := filepath.Join(c.cgroupPath, "cpu.max")

        // Convert CPU cores to the appropriate format
        // cgroups v2 uses a quota/period format
        // For 1 CPU core, quota = period (100% of 1 CPU)
        // For 0.5 CPU cores, quota = period/2 (50% of 1 CPU)
        period := 100000
        quota := int(cpuValue * float64(period))
        value := fmt.Sprintf("%d %d", quota, period)

        if err := os.WriteFile(cpuMaxPath, []byte(value), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write CPU limit: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// applyMemoryLimit applies memory limits to the cgroup.
func (c *resourceController) applyMemoryLimit(memoryLimit string) error <span class="cov0" title="0">{
        // Parse memory limit using the helper function
        memoryBytes, err := types.ParseMemory(memoryLimit)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid memory limit format: %w", err)
        }</span>

        // For cgroups v2, we'd write to memory.max
        <span class="cov0" title="0">memoryMaxPath := filepath.Join(c.cgroupPath, "memory.max")

        // Write the memory limit in bytes
        if err := os.WriteFile(memoryMaxPath, []byte(strconv.FormatInt(memoryBytes, 10)), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write memory limit: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// addProcess adds the process to the cgroup.
func (c *resourceController) addProcess() error <span class="cov0" title="0">{
        // For cgroups v2, we'd write the PID to cgroup.procs
        procsPath := filepath.Join(c.cgroupPath, "cgroup.procs")

        // Write the PID
        if err := os.WriteFile(procsPath, []byte(strconv.Itoa(c.pid)), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add process to cgroup: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// cleanup removes the cgroup.
func (c *resourceController) cleanup() error <span class="cov0" title="0">{
        // For cgroups v2, we can simply remove the directory
        if err := os.RemoveAll(c.cgroupPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove cgroup: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">// Package process implements a Runner interface for local processes
package process

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/google/uuid"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/runner"
        "github.com/rzbill/rune/pkg/runner/process/security"
        "github.com/rzbill/rune/pkg/types"
)

// Validate that ProcessRunner implements the runner.Runner interface
var _ runner.Runner = &amp;ProcessRunner{}

// ProcessRunner implements the runner.Runner interface for local processes
type ProcessRunner struct {
        baseDir   string
        logger    log.Logger
        processes map[string]*managedProcess
        mu        sync.RWMutex
}

// managedProcess holds internal state for a process managed by ProcessRunner
type managedProcess struct {
        instance     *types.Instance
        cmd          *exec.Cmd
        status       runner.InstanceStatus
        logFile      *os.File
        workDir      string
        mu           sync.RWMutex
        stopCh       chan struct{}
        cleanupFiles []string
}

// ProcessOption is a function that configures a ProcessRunner
type ProcessOption func(*ProcessRunner)

// WithBaseDir sets the base directory for process workspaces and logs
func WithBaseDir(dir string) ProcessOption <span class="cov8" title="1">{
        return func(r *ProcessRunner) </span><span class="cov8" title="1">{
                r.baseDir = dir
        }</span>
}

// WithLogger sets the logger for the runner
func WithLogger(logger log.Logger) ProcessOption <span class="cov8" title="1">{
        return func(r *ProcessRunner) </span><span class="cov8" title="1">{
                r.logger = logger
        }</span>
}

// NewProcessRunner creates a new ProcessRunner with the given options
func NewProcessRunner(options ...ProcessOption) (*ProcessRunner, error) <span class="cov8" title="1">{
        // Create a default logger
        defaultLogger := log.NewLogger()

        runner := &amp;ProcessRunner{
                baseDir:   os.TempDir(),
                logger:    defaultLogger,
                processes: make(map[string]*managedProcess),
        }

        for _, option := range options </span><span class="cov8" title="1">{
                option(runner)
        }</span>

        // Ensure base directory exists
        <span class="cov8" title="1">if err := os.MkdirAll(runner.baseDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create base directory: %w", err)
        }</span>

        <span class="cov8" title="1">return runner, nil</span>
}

func (r *ProcessRunner) Type() types.RunnerType <span class="cov0" title="0">{
        return types.RunnerTypeProcess
}</span>

// Create creates a new process but does not start it
func (r *ProcessRunner) Create(ctx context.Context, instance *types.Instance) error <span class="cov8" title="1">{
        if instance == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("instance cannot be nil")
        }</span>

        <span class="cov8" title="1">if instance.ID == "" </span><span class="cov0" title="0">{
                instance.ID = uuid.New().String()
        }</span>

        <span class="cov8" title="1">if instance.Namespace == "" </span><span class="cov8" title="1">{
                instance.Namespace = instance.ServiceID
        }</span>

        <span class="cov8" title="1">if err := instance.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid instance: %w", err)
        }</span>

        // Ensure we have process spec
        <span class="cov8" title="1">if instance.Process == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("process spec is required")
        }</span>

        // Use our enhanced validation that also checks executable path
        <span class="cov8" title="1">if err := ValidateProcessSpec(instance.Process); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid process spec: %w", err)
        }</span>

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        // Check if instance already exists
        if _, exists := r.processes[instance.ID]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("instance with ID %s already exists", instance.ID)
        }</span>

        // Create workspace directory
        <span class="cov8" title="1">workDir := filepath.Join(r.baseDir, "rune", instance.Namespace, instance.ID)
        if err := os.MkdirAll(workDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create workspace directory: %w", err)
        }</span>

        // Create log file
        <span class="cov8" title="1">logPath := filepath.Join(workDir, "process.log")
        logFile, err := os.Create(logPath)
        if err != nil </span><span class="cov0" title="0">{
                // Clean up the workspace if we fail
                _ = os.RemoveAll(workDir)
                return fmt.Errorf("failed to create log file: %w", err)
        }</span>

        // Prepare command (but don't start it)
        <span class="cov8" title="1">cmd := exec.CommandContext(ctx, instance.Process.Command, instance.Process.Args...)

        // Set environment variables
        if instance.Environment != nil &amp;&amp; len(instance.Environment) &gt; 0 </span><span class="cov0" title="0">{
                // Convert map to slice of KEY=VALUE strings
                env := os.Environ() // Include parent environment
                for key, value := range instance.Environment </span><span class="cov0" title="0">{
                        env = append(env, fmt.Sprintf("%s=%s", key, value))
                }</span>
                <span class="cov0" title="0">cmd.Env = env</span>
        }

        // Set working directory if specified
        <span class="cov8" title="1">if instance.Process.WorkingDir != "" </span><span class="cov0" title="0">{
                cmd.Dir = instance.Process.WorkingDir
        }</span> else<span class="cov8" title="1"> {
                cmd.Dir = workDir
        }</span>

        // Apply security context if specified
        <span class="cov8" title="1">if instance.Process.SecurityContext != nil </span><span class="cov0" title="0">{
                if err := security.ApplySecurityContext(cmd, instance.Process.SecurityContext, r.logger); err != nil </span><span class="cov0" title="0">{
                        // Clean up resources if security context fails
                        _ = logFile.Close()
                        _ = os.RemoveAll(workDir)
                        return fmt.Errorf("failed to apply security context: %w", err)
                }</span>
        }

        // Record creation time
        <span class="cov8" title="1">now := time.Now()

        // Create managed process entry
        proc := &amp;managedProcess{
                instance:     instance,
                cmd:          cmd,
                workDir:      workDir,
                logFile:      logFile,
                cleanupFiles: []string{logPath},
                stopCh:       make(chan struct{}),
                status: runner.InstanceStatus{
                        State:      types.InstanceStatusCreated,
                        InstanceID: instance.ID,
                        CreatedAt:  now,
                },
        }

        // Store the process
        r.processes[instance.ID] = proc

        // Update instance status
        instance.Status = types.InstanceStatusCreated
        instance.UpdatedAt = now
        instance.CreatedAt = now

        r.logger.Info("Created process instance",
                log.Str("instance_id", instance.ID),
                log.Str("name", instance.Name),
                log.Str("command", instance.Process.Command))

        return nil</span>
}

// Start starts an existing process instance
func (r *ProcessRunner) Start(ctx context.Context, instance *types.Instance) error <span class="cov8" title="1">{
        r.mu.RLock()
        proc, exists := r.processes[instance.ID]
        r.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("instance with ID %s not found", instance.ID)
        }</span>

        <span class="cov8" title="1">proc.mu.Lock()
        defer proc.mu.Unlock()

        // Ensure instance is in a valid state to start
        if proc.status.State != types.InstanceStatusCreated &amp;&amp;
                proc.status.State != types.InstanceStatusStopped </span><span class="cov0" title="0">{
                return fmt.Errorf("instance in state %s cannot be started", proc.status.State)
        }</span>

        // Set up command stdout/stderr redirection to log file
        <span class="cov8" title="1">proc.cmd.Stdout = proc.logFile
        proc.cmd.Stderr = proc.logFile

        // Start the command
        if err := proc.cmd.Start(); err != nil </span><span class="cov0" title="0">{
                proc.status.State = types.InstanceStatusFailed
                proc.status.ErrorMessage = err.Error()
                return fmt.Errorf("failed to start process: %w", err)
        }</span>

        // Update status
        <span class="cov8" title="1">now := time.Now()
        proc.status.State = types.InstanceStatusRunning
        proc.status.StartedAt = now

        // Update instance status
        proc.instance.Status = types.InstanceStatusRunning
        proc.instance.UpdatedAt = now

        // Monitor the process completion to update status
        go func() </span><span class="cov8" title="1">{
                // Wait for process to complete
                err := proc.cmd.Wait()

                proc.mu.Lock()
                defer proc.mu.Unlock()

                // Get exit code and update status
                exitCode := 0
                if err != nil </span><span class="cov8" title="1">{
                        // Check if it's an exit error
                        if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov8" title="1">{
                                if status, ok := exitErr.Sys().(syscall.WaitStatus); ok </span><span class="cov8" title="1">{
                                        exitCode = status.ExitStatus()
                                }</span>
                        }
                        <span class="cov8" title="1">proc.status.ErrorMessage = err.Error()</span>
                }

                <span class="cov8" title="1">now := time.Now()
                proc.status.State = types.InstanceStatusStopped
                proc.status.ExitCode = exitCode
                proc.status.FinishedAt = now

                // Update instance
                proc.instance.Status = types.InstanceStatusStopped
                proc.instance.UpdatedAt = now

                r.logger.Info("Process completed",
                        log.Str("instance_id", proc.instance.ID),
                        log.Str("name", proc.instance.Name),
                        log.Int("exit_code", exitCode))</span>
        }()

        <span class="cov8" title="1">r.logger.Info("Started process instance",
                log.Str("instance_id", proc.instance.ID),
                log.Str("name", proc.instance.Name),
                log.Int("pid", proc.cmd.Process.Pid))

        return nil</span>
}

// Stop stops a running process instance
func (r *ProcessRunner) Stop(ctx context.Context, instance *types.Instance, timeout time.Duration) error <span class="cov8" title="1">{
        r.mu.RLock()
        proc, exists := r.processes[instance.ID]
        r.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("instance with ID %s not found", instance.ID)
        }</span>

        <span class="cov8" title="1">proc.mu.Lock()
        defer proc.mu.Unlock()

        // Check if the process is running
        if proc.status.State != types.InstanceStatusRunning </span><span class="cov0" title="0">{
                return nil // Already stopped
        }</span>

        <span class="cov8" title="1">if proc.cmd.Process == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("process is not running")
        }</span>

        // Try graceful shutdown first (SIGTERM)
        <span class="cov8" title="1">if err := proc.cmd.Process.Signal(syscall.SIGTERM); err != nil </span><span class="cov0" title="0">{
                r.logger.Warn("Failed to send SIGTERM to process",
                        log.Str("instance_id", proc.instance.ID),
                        log.Err(err))
        }</span>

        // Set up timer for timeout
        <span class="cov8" title="1">timer := time.NewTimer(timeout)
        defer timer.Stop()

        // Channel to indicate process has exited
        done := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                // Wait for the process to exit
                _, err := proc.cmd.Process.Wait()
                done &lt;- err
        }</span>()

        // Wait for process to exit or timeout
        <span class="cov8" title="1">select </span>{
        case &lt;-timer.C:<span class="cov0" title="0">
                // Timeout occurred, forcefully kill the process
                if err := proc.cmd.Process.Kill(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to kill process after timeout: %w", err)
                }</span>

                <span class="cov0" title="0">r.logger.Warn("Process killed after timeout",
                        log.Str("instance_id", proc.instance.ID),
                        log.Str("name", proc.instance.Name))</span>

        case err := &lt;-done:<span class="cov8" title="1">
                if err != nil </span><span class="cov8" title="1">{
                        r.logger.Warn("Process exited with error",
                                log.Str("instance_id", proc.instance.ID),
                                log.Err(err))
                }</span> else<span class="cov0" title="0"> {
                        r.logger.Info("Process stopped gracefully",
                                log.Str("instance_id", proc.instance.ID),
                                log.Str("name", proc.instance.Name))
                }</span>
        }

        // Update status
        <span class="cov8" title="1">now := time.Now()
        proc.status.State = types.InstanceStatusStopped
        proc.status.FinishedAt = now

        // Update instance
        proc.instance.Status = types.InstanceStatusStopped
        proc.instance.UpdatedAt = now

        return nil</span>
}

// Remove removes a process instance
func (r *ProcessRunner) Remove(ctx context.Context, instance *types.Instance, force bool) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        proc, exists := r.processes[instance.ID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("instance with ID %s not found", instance.ID)
        }</span>

        <span class="cov8" title="1">proc.mu.Lock()
        defer proc.mu.Unlock()

        // If the process is still running and force is not set, return error
        if proc.status.State == types.InstanceStatusRunning &amp;&amp; !force </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot remove running instance, use force to override")
        }</span>

        // If running and force is set, try to kill it
        <span class="cov8" title="1">if proc.status.State == types.InstanceStatusRunning &amp;&amp; force </span><span class="cov0" title="0">{
                if proc.cmd.Process != nil </span><span class="cov0" title="0">{
                        if err := proc.cmd.Process.Kill(); err != nil </span><span class="cov0" title="0">{
                                r.logger.Warn("Failed to kill process during forced removal",
                                        log.Str("instance_id", proc.instance.ID),
                                        log.Err(err))
                        }</span>
                }
        }

        // Close log file
        <span class="cov8" title="1">if proc.logFile != nil </span><span class="cov8" title="1">{
                _ = proc.logFile.Close()
        }</span>

        // Remove workspace directory
        <span class="cov8" title="1">if err := os.RemoveAll(proc.workDir); err != nil </span><span class="cov0" title="0">{
                r.logger.Warn("Failed to remove workspace directory",
                        log.Str("instance_id", proc.instance.ID),
                        log.Err(err))
        }</span>

        // Remove from process map
        <span class="cov8" title="1">delete(r.processes, instance.ID)

        r.logger.Info("Removed process instance",
                log.Str("instance_id", proc.instance.ID),
                log.Str("name", proc.instance.Name))

        return nil</span>
}

// GetLogs retrieves logs from a process instance
func (r *ProcessRunner) GetLogs(ctx context.Context, instance *types.Instance, options runner.LogOptions) (io.ReadCloser, error) <span class="cov8" title="1">{
        r.mu.RLock()
        proc, exists := r.processes[instance.ID]
        r.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance with ID %s not found", instance.ID)
        }</span>

        <span class="cov8" title="1">proc.mu.RLock()
        defer proc.mu.RUnlock()

        // Ensure log file exists
        if proc.logFile == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("log file not found for instance %s", instance.ID)
        }</span>

        // Get log file path
        <span class="cov8" title="1">logPath := proc.logFile.Name()

        // Open log file for reading
        file, err := os.Open(logPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open log file: %w", err)
        }</span>

        // If no filtering options are set, just return the file
        <span class="cov8" title="1">if !options.Follow &amp;&amp; options.Tail &lt;= 0 &amp;&amp; options.Since.IsZero() &amp;&amp; options.Until.IsZero() </span><span class="cov8" title="1">{
                return file, nil
        }</span>

        // Create a filtered reader
        <span class="cov8" title="1">pipeReader, pipeWriter := io.Pipe()

        go func() </span><span class="cov8" title="1">{
                defer pipeWriter.Close()
                defer file.Close()

                // Start at the beginning by default
                var startPos int64 = 0

                // Handle tail option
                if options.Tail &gt; 0 </span><span class="cov8" title="1">{
                        // Get file size
                        info, err := file.Stat()
                        if err != nil </span><span class="cov0" title="0">{
                                r.logger.Error("Failed to get log file info", log.Err(err))
                                return
                        }</span>

                        // Find start position by counting lines from the end
                        <span class="cov8" title="1">startPos = findStartPosition(file, info.Size(), options.Tail)</span>
                }

                // Seek to the start position
                <span class="cov8" title="1">_, err = file.Seek(startPos, 0)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to seek log file", log.Err(err))
                        return
                }</span>

                // Use a scanner to read the file line by line
                <span class="cov8" title="1">scanner := bufio.NewScanner(file)
                buffer := make([]byte, 4096)
                scanner.Buffer(buffer, 1024*1024) // Increase buffer size for longer lines

                // Channel to signal stop
                stopCh := make(chan struct{})

                // Setup context cancellation
                go func() </span><span class="cov8" title="1">{
                        &lt;-ctx.Done()
                        close(stopCh)
                }</span>()

                // Continuously read and filter lines
                <span class="cov8" title="1">for scanner.Scan() </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-stopCh:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov8" title="1">
                                line := scanner.Bytes()

                                // Check if we should filter this line based on timestamps
                                if shouldIncludeLine(line, options) </span><span class="cov8" title="1">{
                                        // Include this line
                                        _, writeErr := pipeWriter.Write(append(line, '\n'))
                                        if writeErr != nil </span><span class="cov0" title="0">{
                                                r.logger.Error("Failed to write to pipe", log.Err(writeErr))
                                                return
                                        }</span>
                                }
                        }
                }

                // Check for scanner errors
                <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Error scanning log file", log.Err(err))
                        return
                }</span>

                // If follow mode is enabled, continue watching the file
                <span class="cov8" title="1">if options.Follow &amp;&amp; proc.status.State == types.InstanceStatusRunning </span><span class="cov0" title="0">{
                        // Create a file watcher to detect changes
                        watcher := make(chan struct{})

                        // Start a goroutine to poll the file for changes
                        go func() </span><span class="cov0" title="0">{
                                defer close(watcher)

                                lastSize, err := file.Seek(0, io.SeekCurrent)
                                if err != nil </span><span class="cov0" title="0">{
                                        r.logger.Error("Failed to get file position", log.Err(err))
                                        return
                                }</span>

                                <span class="cov0" title="0">ticker := time.NewTicker(100 * time.Millisecond)
                                defer ticker.Stop()

                                for </span><span class="cov0" title="0">{
                                        select </span>{
                                        case &lt;-stopCh:<span class="cov0" title="0">
                                                return</span>
                                        case &lt;-ticker.C:<span class="cov0" title="0">
                                                // Get current file size
                                                info, err := file.Stat()
                                                if err != nil </span><span class="cov0" title="0">{
                                                        r.logger.Error("Failed to get file stats", log.Err(err))
                                                        return
                                                }</span>

                                                // If file has grown, signal the watcher
                                                <span class="cov0" title="0">if info.Size() &gt; lastSize </span><span class="cov0" title="0">{
                                                        lastSize = info.Size()
                                                        watcher &lt;- struct{}{}
                                                }</span>

                                                // If process is no longer running, stop watching
                                                <span class="cov0" title="0">if proc.status.State != types.InstanceStatusRunning </span><span class="cov0" title="0">{
                                                        return
                                                }</span>
                                        }
                                }
                        }()

                        // Continue reading when changes are detected
                        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-stopCh:<span class="cov0" title="0">
                                        return</span>
                                case _, ok := &lt;-watcher:<span class="cov0" title="0">
                                        if !ok </span><span class="cov0" title="0">{
                                                return // Watcher closed
                                        }</span>

                                        // Read new content
                                        <span class="cov0" title="0">scanner := bufio.NewScanner(file)
                                        for scanner.Scan() </span><span class="cov0" title="0">{
                                                line := scanner.Bytes()

                                                // Check if we should filter this line based on timestamps
                                                if shouldIncludeLine(line, options) </span><span class="cov0" title="0">{
                                                        // Include this line
                                                        _, writeErr := pipeWriter.Write(append(line, '\n'))
                                                        if writeErr != nil </span><span class="cov0" title="0">{
                                                                r.logger.Error("Failed to write to pipe", log.Err(writeErr))
                                                                return
                                                        }</span>
                                                }
                                        }

                                        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                                                r.logger.Error("Error scanning log file", log.Err(err))
                                                return
                                        }</span>
                                }
                        }
                }
        }()

        <span class="cov8" title="1">return pipeReader, nil</span>
}

// shouldIncludeLine determines whether a log line should be included based on timestamp filters
func shouldIncludeLine(line []byte, options runner.LogOptions) bool <span class="cov8" title="1">{
        // If no timestamp filters are set, include the line
        if options.Since.IsZero() &amp;&amp; options.Until.IsZero() </span><span class="cov8" title="1">{
                return true
        }</span>

        // Try to extract timestamp from the line
        <span class="cov8" title="1">timestamp, ok := extractTimestamp(line)
        if !ok </span><span class="cov0" title="0">{
                // If we can't extract a timestamp, include the line by default
                return true
        }</span>

        // For partial timestamps (without year or with zero year), use the current time's year
        // to avoid filtering based on incorrect dates
        <span class="cov8" title="1">if timestamp.Year() &lt; 1000 </span><span class="cov8" title="1">{
                currentYear := time.Now().Year()
                // Create a new timestamp with the current year but preserve month, day, hour, etc.
                timestamp = time.Date(
                        currentYear,
                        timestamp.Month(),
                        timestamp.Day(),
                        timestamp.Hour(),
                        timestamp.Minute(),
                        timestamp.Second(),
                        timestamp.Nanosecond(),
                        timestamp.Location(),
                )
        }</span>

        // Apply Since filter
        <span class="cov8" title="1">if !options.Since.IsZero() &amp;&amp; timestamp.Before(options.Since) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Apply Until filter
        <span class="cov8" title="1">if !options.Until.IsZero() &amp;&amp; timestamp.After(options.Until) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// extractTimestamp attempts to extract a timestamp from a log line
// It looks for common timestamp formats at the beginning of the line
func extractTimestamp(line []byte) (time.Time, bool) <span class="cov8" title="1">{
        // Common timestamp formats to try
        formats := []string{
                "2006-01-02T15:04:05.999999999Z07:00", // RFC3339Nano
                "2006-01-02T15:04:05Z07:00",           // RFC3339
                "2006-01-02 15:04:05",                 // Common format
                "2006/01/02 15:04:05",                 // Common format
                "Jan 2 15:04:05",                      // Common syslog format
                "Jan 02 15:04:05",                     // Common syslog format
                "15:04:05",                            // Time only
        }

        // Convert to string for parsing
        lineStr := string(line)

        // Try to find a timestamp at the beginning of the line
        for _, format := range formats </span><span class="cov8" title="1">{
                // Look for timestamps with brackets
                if len(lineStr) &gt; 2 &amp;&amp; lineStr[0] == '[' </span><span class="cov8" title="1">{
                        closeBracket := strings.IndexByte(lineStr, ']')
                        if closeBracket &gt; 0 </span><span class="cov8" title="1">{
                                potentialTimestamp := lineStr[1:closeBracket]
                                timestamp, err := time.Parse(format, potentialTimestamp)
                                if err == nil </span><span class="cov8" title="1">{
                                        return timestamp, true
                                }</span>
                        }
                }

                // Try without brackets - directly at the beginning of the line
                <span class="cov8" title="1">if len(lineStr) &gt;= len(format) </span><span class="cov8" title="1">{
                        potentialTimestamp := lineStr
                        if len(potentialTimestamp) &gt; len(format) </span><span class="cov8" title="1">{
                                potentialTimestamp = potentialTimestamp[:len(format)]
                        }</span>
                        <span class="cov8" title="1">timestamp, err := time.Parse(format, potentialTimestamp)
                        if err == nil </span><span class="cov8" title="1">{
                                return timestamp, true
                        }</span>
                }
        }

        // Try to match timestamps anywhere in the string with common patterns
        <span class="cov8" title="1">timePatterns := []string{
                `\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:?\d{2})`, // RFC3339/ISO8601
                `\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}`,                             // Common format
                `\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2}`,                             // Common format
                `[A-Z][a-z]{2} \d{1,2} \d{2}:\d{2}:\d{2}`,                         // Syslog format
                `\d{2}:\d{2}:\d{2}`,                                               // Time only
        }

        for _, pattern := range timePatterns </span><span class="cov8" title="1">{
                matches := regexp.MustCompile(pattern).FindAllStringSubmatch(lineStr, 1)
                if len(matches) &gt; 0 &amp;&amp; len(matches[0]) &gt; 0 </span><span class="cov8" title="1">{
                        match := matches[0][0]
                        // Try to parse the matched time string with all formats
                        for _, format := range formats </span><span class="cov8" title="1">{
                                timestamp, err := time.Parse(format, match)
                                if err == nil </span><span class="cov8" title="1">{
                                        return timestamp, true
                                }</span>
                        }
                }
        }

        // Couldn't extract a timestamp
        <span class="cov8" title="1">return time.Time{}, false</span>
}

// min returns the smaller of x or y
func min(x, y int) int <span class="cov0" title="0">{
        if x &lt; y </span><span class="cov0" title="0">{
                return x
        }</span>
        <span class="cov0" title="0">return y</span>
}

// Status retrieves the current status of a process instance
func (r *ProcessRunner) Status(ctx context.Context, instance *types.Instance) (types.InstanceStatus, error) <span class="cov8" title="1">{
        r.mu.RLock()
        proc, exists := r.processes[instance.ID]
        r.mu.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                return types.InstanceStatusFailed, fmt.Errorf("instance with ID %s not found", instance.ID)
        }</span>

        <span class="cov8" title="1">proc.mu.RLock()
        defer proc.mu.RUnlock()

        return proc.status.State, nil</span>
}

// List lists all process instances
func (r *ProcessRunner) List(ctx context.Context, namespace string) ([]*types.Instance, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        instances := make([]*types.Instance, 0, len(r.processes))
        for _, proc := range r.processes </span><span class="cov8" title="1">{
                proc.mu.RLock()
                // Make a copy of the instance to avoid concurrent access issues
                instance := *proc.instance
                proc.mu.RUnlock()
                instances = append(instances, &amp;instance)
        }</span>

        <span class="cov8" title="1">return instances, nil</span>
}

// findStartPosition finds the position to start reading to get the last n lines
func findStartPosition(file *os.File, fileSize int64, numLines int) int64 <span class="cov8" title="1">{
        // Return to start after function
        defer file.Seek(0, 0)

        // If numLines is 0 or negative, return the start of the file
        if numLines &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // If the file is empty, return 0
        <span class="cov8" title="1">if fileSize == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Buffer for reading the file backwards
        <span class="cov8" title="1">buf := make([]byte, 1)
        lineCount := 0
        var pos int64

        // Start from the end of the file
        for pos = fileSize - 1; pos &gt;= 0; pos-- </span><span class="cov8" title="1">{
                // Seek to the current position
                _, err := file.Seek(pos, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return 0
                }</span>

                // Read one byte
                <span class="cov8" title="1">_, err = file.Read(buf)
                if err != nil </span><span class="cov0" title="0">{
                        return 0
                }</span>

                // Check if we found a newline
                <span class="cov8" title="1">if buf[0] == '\n' </span><span class="cov8" title="1">{
                        lineCount++
                        if lineCount &gt; numLines </span><span class="cov8" title="1">{
                                // We found the position, return the next byte
                                return pos + 1
                        }</span>
                }
        }

        // If we reached here, we didn't find enough lines, return the start of the file
        <span class="cov8" title="1">return 0</span>
}

// Exec creates an interactive exec session within a running process.
func (r *ProcessRunner) Exec(ctx context.Context, instance *types.Instance, options runner.ExecOptions) (runner.ExecStream, error) <span class="cov0" title="0">{
        r.mu.RLock()
        _, exists := r.processes[instance.ID]
        r.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance not found: %s", instance.ID)
        }</span>

        // Verify instance is running
        <span class="cov0" title="0">status, err := r.Status(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get instance status: %w", err)
        }</span>

        <span class="cov0" title="0">if status != types.InstanceStatusRunning </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("instance is not running, status: %s", status)
        }</span>

        // Create the exec stream
        // For a process, exec means starting a new process (we can't exec inside an existing process)
        // We could potentially use different methods like ptrace for more advanced use cases
        <span class="cov0" title="0">execStream, err := NewProcessExecStream(ctx, instance.ID, options, r.logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create exec stream: %w", err)
        }</span>

        <span class="cov0" title="0">return execStream, nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">// Package security provides security implementations for process runners
package security

import (
        "fmt"
        "os/exec"
        "os/user"
        "runtime"
        "strconv"
        "syscall"

        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/types"
)

// ApplySecurityContext applies security settings from a ProcessSecurityContext to a command
func ApplySecurityContext(cmd *exec.Cmd, sc *types.ProcessSecurityContext, logger log.Logger) error <span class="cov8" title="1">{
        if sc == nil </span><span class="cov8" title="1">{
                return nil // Nothing to apply
        }</span>

        // Apply user/group if specified
        <span class="cov8" title="1">if sc.User != "" </span><span class="cov8" title="1">{
                if err := applyUserAndGroup(cmd, sc.User, sc.Group); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to apply user/group: %w", err)
                }</span>
        }

        // Apply read-only filesystem if requested
        <span class="cov8" title="1">if sc.ReadOnlyFS </span><span class="cov8" title="1">{
                // This is platform-specific and would need more complex implementation
                // For now, we'll just log that it's requested but not fully implemented
                logger.Warn("Read-only filesystem requested but not fully implemented for process security context")
        }</span>

        // Apply capabilities and syscall restrictions
        // These are Linux-specific features
        <span class="cov8" title="1">if runtime.GOOS == "linux" </span><span class="cov0" title="0">{
                if len(sc.Capabilities) &gt; 0 || len(sc.AllowedSyscalls) &gt; 0 || len(sc.DeniedSyscalls) &gt; 0 </span><span class="cov0" title="0">{
                        logger.Warn("Linux capabilities and syscall restrictions requested but not fully implemented")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// applyUserAndGroup configures a command to run as the specified user and group
func applyUserAndGroup(cmd *exec.Cmd, username, groupname string) error <span class="cov8" title="1">{
        if username == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Look up the user
        <span class="cov8" title="1">u, err := user.Lookup(username)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to look up user %s: %w", username, err)
        }</span>

        // Convert user ID to integer
        <span class="cov8" title="1">uid, err := strconv.Atoi(u.Uid)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid user ID for %s: %w", username, err)
        }</span>

        // Get group ID
        <span class="cov8" title="1">gid := -1
        if groupname != "" </span><span class="cov8" title="1">{
                // Use specified group
                g, err := user.LookupGroup(groupname)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to look up group %s: %w", groupname, err)
                }</span>
                <span class="cov0" title="0">gid, err = strconv.Atoi(g.Gid)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid group ID for %s: %w", groupname, err)
                }</span>
        } else<span class="cov0" title="0"> if u.Gid != "" </span><span class="cov0" title="0">{
                // Use user's primary group
                gid, err = strconv.Atoi(u.Gid)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid primary group ID for %s: %w", username, err)
                }</span>
        }

        // Set credential in the command's SysProcAttr
        <span class="cov0" title="0">if cmd.SysProcAttr == nil </span><span class="cov0" title="0">{
                cmd.SysProcAttr = &amp;syscall.SysProcAttr{}
        }</span>

        // Apply credentials
        // This is OS-specific, for Unix-like systems
        <span class="cov0" title="0">if runtime.GOOS != "windows" </span><span class="cov0" title="0">{
                cmd.SysProcAttr.Credential = &amp;syscall.Credential{
                        Uid: uint32(uid),
                        Gid: uint32(gid),
                }
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("user/group switching not supported on Windows")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package process

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/rzbill/rune/pkg/types"
)

// ValidateProcessSpec validates the process specification, including checking if the command exists
// and is executable on the system
func ValidateProcessSpec(spec *types.ProcessSpec) error <span class="cov8" title="1">{
        if spec == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("process spec cannot be nil")
        }</span>

        // Basic validation already done by spec.Validate()
        <span class="cov8" title="1">if err := spec.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate that the command exists and is executable
        <span class="cov8" title="1">if err := validateExecutablePath(spec.Command); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("command validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateExecutablePath checks if the given command exists and is executable
func validateExecutablePath(command string) error <span class="cov8" title="1">{
        if command == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("command cannot be empty")
        }</span>

        // If command is an absolute path, check directly
        <span class="cov8" title="1">if filepath.IsAbs(command) </span><span class="cov8" title="1">{
                if err := checkFileExecutable(command); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("absolute path executable validation failed: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // If command contains path separators but isn't absolute,
        // it's a relative path - check in current directory
        <span class="cov8" title="1">if strings.ContainsRune(command, os.PathSeparator) </span><span class="cov0" title="0">{
                // Convert to absolute path based on current directory
                absPath, err := filepath.Abs(command)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert to absolute path: %w", err)
                }</span>

                <span class="cov0" title="0">if err := checkFileExecutable(absPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("relative path executable validation failed: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Otherwise, check if command is in PATH
        <span class="cov8" title="1">_, err := exec.LookPath(command)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("command '%s' not found in PATH: %w", command, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// checkFileExecutable checks if a file exists and is executable
func checkFileExecutable(path string) error <span class="cov8" title="1">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return fmt.Errorf("file does not exist: %s", path)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to access file: %w", err)</span>
        }

        // Check if it's a regular file (not a directory)
        <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                return fmt.Errorf("path is a directory, not an executable file: %s", path)
        }</span>

        // Check if file is executable
        // This is platform-specific, but we can approximate
        <span class="cov8" title="1">if info.Mode()&amp;0111 == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("file is not executable: %s", path)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package runner

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "sync"
        "time"

        "github.com/rzbill/rune/pkg/types"
)

// TestRunner is a simplified, predictable implementation of Runner for testing.
// Instead of requiring expectations to be set up, it returns predefined responses.
type TestRunner struct {
        // Configurable test behavior
        StatusResults map[string]types.InstanceStatus
        Instances     map[string]*types.Instance
        ExecOutput    []byte
        ExecErrOutput []byte
        ExitCodeVal   int
        LogOutput     []byte
        ErrorToReturn error

        // Optional tracking for verification
        CreatedInstances []*types.Instance
        StartedInstances []string
        StoppedInstances []string
        RemovedInstances []string
        ExecCalls        []string
        ExecOptions      []ExecOptions
        LogCalls         []string
        StatusCalls      []string
        mu               sync.Mutex // protects the tracking fields
}

// NewTestRunner creates a new TestRunner with default behavior
func NewTestRunner() *TestRunner <span class="cov0" title="0">{
        return &amp;TestRunner{
                StatusResults:    make(map[string]types.InstanceStatus),
                Instances:        make(map[string]*types.Instance),
                ExitCodeVal:      0,
                ExecOutput:       []byte("test stdout"),
                ExecErrOutput:    []byte("test stderr"),
                CreatedInstances: make([]*types.Instance, 0),
                StartedInstances: make([]string, 0),
                StoppedInstances: make([]string, 0),
                RemovedInstances: make([]string, 0),
                ExecCalls:        make([]string, 0),
                ExecOptions:      make([]ExecOptions, 0),
                LogCalls:         make([]string, 0),
                StatusCalls:      make([]string, 0),
        }
}</span>

func (r *TestRunner) Type() types.RunnerType <span class="cov0" title="0">{
        return types.RunnerTypeTest
}</span>

// Create tracks instance creation
func (r *TestRunner) Create(ctx context.Context, instance *types.Instance) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return r.ErrorToReturn
        }</span>

        <span class="cov0" title="0">r.CreatedInstances = append(r.CreatedInstances, instance)
        r.Instances[instance.ID] = instance
        return nil</span>
}

// Start tracks instance starting
func (r *TestRunner) Start(ctx context.Context, instance *types.Instance) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return r.ErrorToReturn
        }</span>

        <span class="cov0" title="0">r.StartedInstances = append(r.StartedInstances, instance.ID)

        // Update status if we're tracking this instance
        if instance, ok := r.Instances[instance.ID]; ok </span><span class="cov0" title="0">{
                instance.Status = types.InstanceStatusRunning
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop tracks instance stopping
func (r *TestRunner) Stop(ctx context.Context, instance *types.Instance, timeout time.Duration) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return r.ErrorToReturn
        }</span>

        <span class="cov0" title="0">r.StoppedInstances = append(r.StoppedInstances, instance.ID)

        // Update status if we're tracking this instance
        if instance, ok := r.Instances[instance.ID]; ok </span><span class="cov0" title="0">{
                instance.Status = types.InstanceStatusStopped
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Remove tracks instance removal
func (r *TestRunner) Remove(ctx context.Context, instance *types.Instance, force bool) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return r.ErrorToReturn
        }</span>

        <span class="cov0" title="0">r.RemovedInstances = append(r.RemovedInstances, instance.ID)
        delete(r.Instances, instance.ID)
        return nil</span>
}

// GetLogs returns predefined log output
func (r *TestRunner) GetLogs(ctx context.Context, instance *types.Instance, options LogOptions) (io.ReadCloser, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.LogCalls = append(r.LogCalls, instance.ID)

        if r.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return nil, r.ErrorToReturn
        }</span>

        <span class="cov0" title="0">return io.NopCloser(bytes.NewReader(r.LogOutput)), nil</span>
}

// Status returns predefined status or Running as default
func (r *TestRunner) Status(ctx context.Context, instance *types.Instance) (types.InstanceStatus, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.StatusCalls = append(r.StatusCalls, instance.ID)

        if r.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return types.InstanceStatusFailed, r.ErrorToReturn
        }</span>

        <span class="cov0" title="0">if status, ok := r.StatusResults[instance.ID]; ok </span><span class="cov0" title="0">{
                return status, nil
        }</span>

        <span class="cov0" title="0">if instance, ok := r.Instances[instance.ID]; ok </span><span class="cov0" title="0">{
                return instance.Status, nil
        }</span>

        // Default status
        <span class="cov0" title="0">return types.InstanceStatusRunning, nil</span>
}

// List returns all registered instances
func (r *TestRunner) List(ctx context.Context, namespace string) ([]*types.Instance, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return nil, r.ErrorToReturn
        }</span>

        <span class="cov0" title="0">instances := make([]*types.Instance, 0, len(r.Instances))
        for _, instance := range r.Instances </span><span class="cov0" title="0">{
                instances = append(instances, instance)
        }</span>

        <span class="cov0" title="0">return instances, nil</span>
}

// Exec returns a predefined TestExecStream
func (r *TestRunner) Exec(ctx context.Context, instance *types.Instance, options ExecOptions) (ExecStream, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.ExecCalls = append(r.ExecCalls, instance.ID)
        r.ExecOptions = append(r.ExecOptions, options)

        if r.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return nil, r.ErrorToReturn
        }</span>

        // Return a fake exec stream with our predefined behavior
        <span class="cov0" title="0">return &amp;TestExecStream{
                StdoutContent: r.ExecOutput,
                StderrContent: r.ExecErrOutput,
                ExitCodeVal:   r.ExitCodeVal,
        }, nil</span>
}

// TestExecStream is a predictable implementation of ExecStream for testing
type TestExecStream struct {
        StdoutContent []byte
        StderrContent []byte
        ExitCodeVal   int
        InputCapture  []byte
        SignalsSent   []string
        Resizes       []struct{ Width, Height uint32 }

        stdoutPos    int
        stderrPos    int
        stderrReader *bytes.Reader
        closed       bool
        mu           sync.Mutex
}

// Write captures input that would be sent to the exec process
func (s *TestExecStream) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.closed </span><span class="cov0" title="0">{
                return 0, io.ErrClosedPipe
        }</span>

        // Capture the input
        <span class="cov0" title="0">s.InputCapture = append(s.InputCapture, p...)
        return len(p), nil</span>
}

// Read returns predefined output content in chunks
func (s *TestExecStream) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.closed </span><span class="cov0" title="0">{
                return 0, io.ErrClosedPipe
        }</span>

        // If we've read everything, return EOF
        <span class="cov0" title="0">if s.stdoutPos &gt;= len(s.StdoutContent) </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>

        // Calculate how much to read
        <span class="cov0" title="0">remaining := len(s.StdoutContent) - s.stdoutPos
        toRead := len(p)
        if toRead &gt; remaining </span><span class="cov0" title="0">{
                toRead = remaining
        }</span>

        // Copy the data
        <span class="cov0" title="0">copy(p, s.StdoutContent[s.stdoutPos:s.stdoutPos+toRead])
        s.stdoutPos += toRead

        return toRead, nil</span>
}

// Stderr returns an io.Reader for the stderr stream
func (s *TestExecStream) Stderr() io.Reader <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.stderrReader == nil </span><span class="cov0" title="0">{
                s.stderrReader = bytes.NewReader(s.StderrContent)
        }</span>

        <span class="cov0" title="0">return s.stderrReader</span>
}

// ResizeTerminal records terminal resize events
func (s *TestExecStream) ResizeTerminal(width, height uint32) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("exec session closed")
        }</span>

        <span class="cov0" title="0">s.Resizes = append(s.Resizes, struct{ Width, Height uint32 }{width, height})
        return nil</span>
}

// Signal records signals sent to the process
func (s *TestExecStream) Signal(sigName string) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("exec session closed")
        }</span>

        <span class="cov0" title="0">s.SignalsSent = append(s.SignalsSent, sigName)
        return nil</span>
}

// ExitCode returns the predefined exit code
func (s *TestExecStream) ExitCode() (int, error) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // If we haven't read all output yet, return an error
        if !s.closed &amp;&amp; s.stdoutPos &lt; len(s.StdoutContent) </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("process still running")
        }</span>

        <span class="cov0" title="0">return s.ExitCodeVal, nil</span>
}

// Close marks the stream as closed
func (s *TestExecStream) Close() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.closed = true
        return nil
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">// Package types defines the core data structures for the Rune orchestration platform.
package types

import (
        "time"
)

// Cluster represents a collection of nodes running services.
type Cluster struct {
        // Unique identifier for the cluster
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the cluster
        Name string `json:"name" yaml:"name"`

        // Version of the cluster schema
        Version string `json:"version" yaml:"version"`

        // Nodes that are part of this cluster
        Nodes []Node `json:"nodes,omitempty" yaml:"nodes,omitempty"`

        // Services deployed in this cluster
        Services []Service `json:"services,omitempty" yaml:"services,omitempty"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// Validate validates the cluster configuration.
func (c *Cluster) Validate() error <span class="cov0" title="0">{
        if c.ID == "" </span><span class="cov0" title="0">{
                return NewValidationError("cluster ID is required")
        }</span>

        <span class="cov0" title="0">if c.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("cluster name is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package types

import (
        "strconv"
        "time"

        "github.com/google/uuid"
)

// Gateway represents an ingress/egress gateway for the service mesh.
type Gateway struct {
        // Unique identifier for the gateway
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the gateway
        Name string `json:"name" yaml:"name"`

        // Namespace the gateway belongs to
        Namespace string `json:"namespace" yaml:"namespace"`

        // Hostname for the gateway (for virtual hosting)
        Hostname string `json:"hostname,omitempty" yaml:"hostname,omitempty"`

        // Whether this is an internal gateway (not exposed outside the mesh)
        Internal bool `json:"internal" yaml:"internal"`

        // Port configurations for the gateway
        Ports []GatewayPort `json:"ports" yaml:"ports"`

        // TLS configuration options
        TLS *GatewayTLS `json:"tls,omitempty" yaml:"tls,omitempty"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// GatewayPort represents a port exposed by a gateway.
type GatewayPort struct {
        // Port number
        Port int `json:"port" yaml:"port"`

        // Protocol for this port (HTTP, HTTPS, TCP, etc.)
        Protocol string `json:"protocol" yaml:"protocol"`

        // Name for this port (optional)
        Name string `json:"name,omitempty" yaml:"name,omitempty"`
}

// GatewayTLS represents TLS configuration for a gateway.
type GatewayTLS struct {
        // Mode of TLS operation (PASSTHROUGH, SIMPLE, MUTUAL)
        Mode string `json:"mode" yaml:"mode"`

        // Secret name containing TLS credentials
        SecretName string `json:"secretName,omitempty" yaml:"secretName,omitempty"`

        // Minimum TLS version
        MinVersion string `json:"minVersion,omitempty" yaml:"minVersion,omitempty"`

        // Maximum TLS version
        MaxVersion string `json:"maxVersion,omitempty" yaml:"maxVersion,omitempty"`

        // Allow client certificate validation
        ClientCertificate bool `json:"clientCertificate,omitempty" yaml:"clientCertificate,omitempty"`
}

// Route represents a rule for routing traffic from a gateway to services.
type Route struct {
        // Unique identifier for the route
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the route
        Name string `json:"name" yaml:"name"`

        // Namespace the route belongs to
        Namespace string `json:"namespace" yaml:"namespace"`

        // Gateway this route is attached to
        Gateway string `json:"gateway" yaml:"gateway"`

        // Host or hosts this route matches (e.g., "api.example.com")
        Hosts []string `json:"hosts,omitempty" yaml:"hosts,omitempty"`

        // HTTP path-based routing rules
        HTTP []HTTPRoute `json:"http,omitempty" yaml:"http,omitempty"`

        // TCP routing rules (port-based)
        TCP []TCPRoute `json:"tcp,omitempty" yaml:"tcp,omitempty"`

        // Priority of this route (higher numbers take precedence)
        Priority int `json:"priority,omitempty" yaml:"priority,omitempty"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// HTTPRoute represents an HTTP routing rule.
type HTTPRoute struct {
        // Path match for this route (e.g., "/api/v1")
        Path string `json:"path,omitempty" yaml:"path,omitempty"`

        // Path prefix match (e.g., "/api")
        PathPrefix string `json:"pathPrefix,omitempty" yaml:"pathPrefix,omitempty"`

        // HTTP methods this route applies to (GET, POST, etc.)
        Methods []string `json:"methods,omitempty" yaml:"methods,omitempty"`

        // Header matches required
        Headers map[string]string `json:"headers,omitempty" yaml:"headers,omitempty"`

        // Query parameter matches required
        QueryParams map[string]string `json:"queryParams,omitempty" yaml:"queryParams,omitempty"`

        // Destination service and options
        Destination RouteDestination `json:"destination" yaml:"destination"`

        // Rewrite options
        Rewrite *HTTPRewrite `json:"rewrite,omitempty" yaml:"rewrite,omitempty"`

        // Response headers to be added
        AddResponseHeaders map[string]string `json:"addResponseHeaders,omitempty" yaml:"addResponseHeaders,omitempty"`

        // Request headers to be added
        AddRequestHeaders map[string]string `json:"addRequestHeaders,omitempty" yaml:"addRequestHeaders,omitempty"`

        // Timeout for this route in milliseconds
        Timeout int `json:"timeout,omitempty" yaml:"timeout,omitempty"`

        // Retry policy
        Retries *HTTPRetryPolicy `json:"retries,omitempty" yaml:"retries,omitempty"`

        // CORS policy
        CORS *CORSPolicy `json:"cors,omitempty" yaml:"cors,omitempty"`
}

// TCPRoute represents a TCP routing rule.
type TCPRoute struct {
        // Port number for this TCP route
        Port int `json:"port" yaml:"port"`

        // Destination service and options
        Destination RouteDestination `json:"destination" yaml:"destination"`
}

// RouteDestination represents the target of a route.
type RouteDestination struct {
        // Service name to route to
        Service string `json:"service" yaml:"service"`

        // Namespace of the service (optional, defaults to route's namespace)
        Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

        // Port on the service to route to
        Port int `json:"port" yaml:"port"`

        // Weight for traffic splitting (0-100)
        Weight int `json:"weight,omitempty" yaml:"weight,omitempty"`

        // Subset of the service to route to (requires service to have defined subsets)
        Subset string `json:"subset,omitempty" yaml:"subset,omitempty"`
}

// HTTPRewrite defines how the path and/or host should be rewritten.
type HTTPRewrite struct {
        // URI to replace the matched path with
        URI string `json:"uri,omitempty" yaml:"uri,omitempty"`

        // Host to replace the request host with
        Host string `json:"host,omitempty" yaml:"host,omitempty"`
}

// HTTPRetryPolicy defines how request retries should be performed.
type HTTPRetryPolicy struct {
        // Number of retry attempts
        Attempts int `json:"attempts" yaml:"attempts"`

        // Timeout per retry attempt in milliseconds
        PerTryTimeout int `json:"perTryTimeout,omitempty" yaml:"perTryTimeout,omitempty"`

        // HTTP status codes that trigger a retry
        RetryOn []int `json:"retryOn,omitempty" yaml:"retryOn,omitempty"`
}

// CORSPolicy defines Cross-Origin Resource Sharing settings.
type CORSPolicy struct {
        // Allowed origins (e.g., "https://example.com")
        AllowOrigins []string `json:"allowOrigins" yaml:"allowOrigins"`

        // Allowed methods (e.g., "GET", "POST")
        AllowMethods []string `json:"allowMethods,omitempty" yaml:"allowMethods,omitempty"`

        // Allowed headers
        AllowHeaders []string `json:"allowHeaders,omitempty" yaml:"allowHeaders,omitempty"`

        // Exposed headers
        ExposeHeaders []string `json:"exposeHeaders,omitempty" yaml:"exposeHeaders,omitempty"`

        // Max age for CORS preflight requests in seconds
        MaxAge int `json:"maxAge,omitempty" yaml:"maxAge,omitempty"`

        // Allow credentials
        AllowCredentials bool `json:"allowCredentials,omitempty" yaml:"allowCredentials,omitempty"`
}

// ServiceRegistry represents the discovery registry for services.
type ServiceRegistry struct {
        // Map of service namespaced names to endpoint information
        Services map[string]*ServiceEndpoints `json:"services" yaml:"services"`

        // Last update timestamp
        LastUpdated time.Time `json:"lastUpdated" yaml:"lastUpdated"`
}

// ServiceEndpoints represents the discovered endpoints for a service.
type ServiceEndpoints struct {
        // Service full name (namespace.name)
        ServiceID string `json:"serviceId" yaml:"serviceId"`

        // Individual endpoints (instances) for this service
        Endpoints []Endpoint `json:"endpoints" yaml:"endpoints"`

        // Service-level metadata
        Metadata map[string]string `json:"metadata,omitempty" yaml:"metadata,omitempty"`
}

// Endpoint represents a specific instance endpoint.
type Endpoint struct {
        // Instance ID this endpoint belongs to
        InstanceID string `json:"instanceId" yaml:"instanceId"`

        // IP address for this endpoint
        IP string `json:"ip" yaml:"ip"`

        // Port for this endpoint
        Port int `json:"port" yaml:"port"`

        // Protocol for this endpoint
        Protocol string `json:"protocol,omitempty" yaml:"protocol,omitempty"`

        // Endpoint-specific metadata
        Metadata map[string]string `json:"metadata,omitempty" yaml:"metadata,omitempty"`

        // Health status for this endpoint
        Healthy bool `json:"healthy" yaml:"healthy"`

        // Last health check timestamp
        LastCheck time.Time `json:"lastCheck,omitempty" yaml:"lastCheck,omitempty"`
}

// GatewaySpec represents the YAML specification for a gateway.
type GatewaySpec struct {
        // Gateway metadata and configuration
        Gateway struct {
                // Human-readable name for the gateway (required)
                Name string `json:"name" yaml:"name"`

                // Namespace the gateway belongs to (optional, defaults to "default")
                Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

                // Hostname for the gateway (for virtual hosting)
                Hostname string `json:"hostname,omitempty" yaml:"hostname,omitempty"`

                // Whether this is an internal gateway (not exposed outside the mesh)
                Internal bool `json:"internal" yaml:"internal"`

                // Port configurations for the gateway
                Ports []GatewayPort `json:"ports" yaml:"ports"`

                // TLS configuration options
                TLS *GatewayTLS `json:"tls,omitempty" yaml:"tls,omitempty"`
        } `json:"gateway" yaml:"gateway"`
}

// RouteSpec represents the YAML specification for a route.
type RouteSpec struct {
        // Route metadata and rules
        Route struct {
                // Human-readable name for the route (required)
                Name string `json:"name" yaml:"name"`

                // Namespace the route belongs to (optional, defaults to "default")
                Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

                // Gateway this route is attached to
                Gateway string `json:"gateway" yaml:"gateway"`

                // Host or hosts this route matches
                Hosts []string `json:"hosts,omitempty" yaml:"hosts,omitempty"`

                // HTTP path-based routing rules
                HTTP []HTTPRoute `json:"http,omitempty" yaml:"http,omitempty"`

                // TCP routing rules (port-based)
                TCP []TCPRoute `json:"tcp,omitempty" yaml:"tcp,omitempty"`

                // Priority of this route (higher numbers take precedence)
                Priority int `json:"priority,omitempty" yaml:"priority,omitempty"`
        } `json:"route" yaml:"route"`
}

// Validate checks if a gateway specification is valid.
func (g *GatewaySpec) Validate() error <span class="cov0" title="0">{
        if g.Gateway.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("gateway name is required")
        }</span>

        <span class="cov0" title="0">if len(g.Gateway.Ports) == 0 </span><span class="cov0" title="0">{
                return NewValidationError("gateway must specify at least one port")
        }</span>

        // Validate TLS configuration if provided
        <span class="cov0" title="0">if g.Gateway.TLS != nil </span><span class="cov0" title="0">{
                if g.Gateway.TLS.Mode != "PASSTHROUGH" &amp;&amp; g.Gateway.TLS.Mode != "SIMPLE" &amp;&amp; g.Gateway.TLS.Mode != "MUTUAL" </span><span class="cov0" title="0">{
                        return NewValidationError("tls mode must be PASSTHROUGH, SIMPLE, or MUTUAL")
                }</span>

                <span class="cov0" title="0">if (g.Gateway.TLS.Mode == "SIMPLE" || g.Gateway.TLS.Mode == "MUTUAL") &amp;&amp; g.Gateway.TLS.SecretName == "" </span><span class="cov0" title="0">{
                        return NewValidationError("tls secretName is required for SIMPLE and MUTUAL modes")
                }</span>
        }

        // Validate each port
        <span class="cov0" title="0">portSet := make(map[int]bool)
        for i, port := range g.Gateway.Ports </span><span class="cov0" title="0">{
                if port.Port &lt;= 0 || port.Port &gt; 65535 </span><span class="cov0" title="0">{
                        return NewValidationError("port at index " + strconv.Itoa(i) + " must be between 1 and 65535")
                }</span>

                <span class="cov0" title="0">if portSet[port.Port] </span><span class="cov0" title="0">{
                        return NewValidationError("duplicate port: " + strconv.Itoa(port.Port))
                }</span>
                <span class="cov0" title="0">portSet[port.Port] = true

                if port.Protocol == "" </span><span class="cov0" title="0">{
                        return NewValidationError("port at index " + strconv.Itoa(i) + " must specify protocol")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Validate checks if a route specification is valid.
func (r *RouteSpec) Validate() error <span class="cov0" title="0">{
        if r.Route.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("route name is required")
        }</span>

        <span class="cov0" title="0">if r.Route.Gateway == "" </span><span class="cov0" title="0">{
                return NewValidationError("route must specify a gateway")
        }</span>

        <span class="cov0" title="0">if len(r.Route.HTTP) == 0 &amp;&amp; len(r.Route.TCP) == 0 </span><span class="cov0" title="0">{
                return NewValidationError("route must specify at least one HTTP or TCP route")
        }</span>

        // Validate HTTP routes
        <span class="cov0" title="0">for i, route := range r.Route.HTTP </span><span class="cov0" title="0">{
                if err := validateHTTPRoute(route, i); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Validate TCP routes
        <span class="cov0" title="0">portSet := make(map[int]bool)
        for i, route := range r.Route.TCP </span><span class="cov0" title="0">{
                if route.Port &lt;= 0 || route.Port &gt; 65535 </span><span class="cov0" title="0">{
                        return NewValidationError("tcp route at index " + strconv.Itoa(i) + " must have port between 1 and 65535")
                }</span>

                <span class="cov0" title="0">if portSet[route.Port] </span><span class="cov0" title="0">{
                        return NewValidationError("duplicate tcp port: " + strconv.Itoa(route.Port))
                }</span>
                <span class="cov0" title="0">portSet[route.Port] = true

                if err := validateRouteDestination(route.Destination); err != nil </span><span class="cov0" title="0">{
                        return NewValidationError("tcp route at index " + strconv.Itoa(i) + ": " + err.Error())
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper function to validate HTTP routes
func validateHTTPRoute(route HTTPRoute, index int) error <span class="cov0" title="0">{
        // Validate path configuration
        if route.Path != "" &amp;&amp; route.PathPrefix != "" </span><span class="cov0" title="0">{
                return NewValidationError("http route at index " + strconv.Itoa(index) + " cannot specify both path and pathPrefix")
        }</span>

        // Validate destination
        <span class="cov0" title="0">if err := validateRouteDestination(route.Destination); err != nil </span><span class="cov0" title="0">{
                return NewValidationError("http route at index " + strconv.Itoa(index) + ": " + err.Error())
        }</span>

        // Validate retry policy if specified
        <span class="cov0" title="0">if route.Retries != nil &amp;&amp; route.Retries.Attempts &lt;= 0 </span><span class="cov0" title="0">{
                return NewValidationError("http route at index " + strconv.Itoa(index) + " retry attempts must be greater than 0")
        }</span>

        // Validate CORS policy if specified
        <span class="cov0" title="0">if route.CORS != nil &amp;&amp; len(route.CORS.AllowOrigins) == 0 </span><span class="cov0" title="0">{
                return NewValidationError("http route at index " + strconv.Itoa(index) + " cors policy must specify at least one allowed origin")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper function to validate route destinations
func validateRouteDestination(dest RouteDestination) error <span class="cov0" title="0">{
        if dest.Service == "" </span><span class="cov0" title="0">{
                return NewValidationError("destination must specify a service")
        }</span>

        <span class="cov0" title="0">if dest.Port &lt;= 0 || dest.Port &gt; 65535 </span><span class="cov0" title="0">{
                return NewValidationError("destination port must be between 1 and 65535")
        }</span>

        <span class="cov0" title="0">if dest.Weight &lt; 0 || dest.Weight &gt; 100 </span><span class="cov0" title="0">{
                return NewValidationError("destination weight must be between 0 and 100")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ToGateway converts a GatewaySpec to a Gateway.
func (g *GatewaySpec) ToGateway() (*Gateway, error) <span class="cov0" title="0">{
        // Validate
        if err := g.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set default namespace if not specified
        <span class="cov0" title="0">namespace := g.Gateway.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default"
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return &amp;Gateway{
                ID:        uuid.New().String(),
                Name:      g.Gateway.Name,
                Namespace: namespace,
                Hostname:  g.Gateway.Hostname,
                Internal:  g.Gateway.Internal,
                Ports:     g.Gateway.Ports,
                TLS:       g.Gateway.TLS,
                CreatedAt: now,
                UpdatedAt: now,
        }, nil</span>
}

// ToRoute converts a RouteSpec to a Route.
func (r *RouteSpec) ToRoute() (*Route, error) <span class="cov0" title="0">{
        // Validate
        if err := r.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set default namespace if not specified
        <span class="cov0" title="0">namespace := r.Route.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default"
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return &amp;Route{
                ID:        uuid.New().String(),
                Name:      r.Route.Name,
                Namespace: namespace,
                Gateway:   r.Route.Gateway,
                Hosts:     r.Route.Hosts,
                HTTP:      r.Route.HTTP,
                TCP:       r.Route.TCP,
                Priority:  r.Route.Priority,
                CreatedAt: now,
                UpdatedAt: now,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package types

import (
        "fmt"
)

// ValidationError represents an error that occurs during validation.
type ValidationError struct {
        Message string
}

// Error returns the error message.
func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewValidationError creates a new ValidationError with the given message.
func NewValidationError(message string) *ValidationError <span class="cov8" title="1">{
        return &amp;ValidationError{
                Message: message,
        }
}</span>

// IsValidationError checks if an error is a ValidationError.
func IsValidationError(err error) bool <span class="cov0" title="0">{
        _, ok := err.(*ValidationError)
        return ok
}</span>

// WrapValidationError wraps an error with additional context.
func WrapValidationError(err error, format string, args ...interface{}) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">message := fmt.Sprintf(format, args...)
        if ve, ok := err.(*ValidationError); ok </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Message: fmt.Sprintf("%s: %s", message, ve.Message),
                }
        }</span>

        <span class="cov0" title="0">return &amp;ValidationError{
                Message: fmt.Sprintf("%s: %v", message, err),
        }</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package types

import (
        "time"

        "github.com/google/uuid"
)

// Function represents a managed piece of user code and its execution environment.
type Function struct {
        // Unique identifier for the function
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the function
        Name string `json:"name" yaml:"name"`

        // Namespace the function belongs to
        Namespace string `json:"namespace" yaml:"namespace"`

        // Specification of the function
        Spec FunctionSpec `json:"spec" yaml:"spec"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// FunctionSpec defines the execution environment and code for a Function.
type FunctionSpec struct {
        // Runtime environment (e.g., python3.9, nodejs16, go1.18)
        Runtime string `json:"runtime" yaml:"runtime"`

        // Entrypoint handler (format depends on runtime, e.g., "main.handler")
        Handler string `json:"handler" yaml:"handler"`

        // Maximum execution time (e.g., "30s", "2m")
        Timeout string `json:"timeout" yaml:"timeout"`

        // Memory limit (e.g., "128Mi", "1Gi")
        MemoryLimit string `json:"memoryLimit" yaml:"memoryLimit"`

        // CPU limit (e.g., "100m", "0.5")
        CPULimit string `json:"cpuLimit,omitempty" yaml:"cpuLimit,omitempty"`

        // Function code
        Code FunctionCode `json:"code" yaml:"code"`

        // Static environment variables
        Env map[string]string `json:"env,omitempty" yaml:"env,omitempty"`

        // Network policy for the function
        NetworkPolicy *FunctionNetworkPolicy `json:"networkPolicy,omitempty" yaml:"networkPolicy,omitempty"`
}

// FunctionCode contains the function's source code, which can be specified inline or as a reference.
type FunctionCode struct {
        // Inline source code
        Inline string `json:"inline,omitempty" yaml:"inline,omitempty"`

        // Reference to code stored elsewhere (future use)
        // Reference string `json:"reference,omitempty" yaml:"reference,omitempty"`
}

// FunctionNetworkPolicy defines what network connections a function is allowed to make.
type FunctionNetworkPolicy struct {
        // Allowed outbound connections
        Allow []FunctionNetworkRule `json:"allow" yaml:"allow"`
}

// FunctionNetworkRule defines a single allow rule for network connectivity.
type FunctionNetworkRule struct {
        // Target host or IP
        Host string `json:"host" yaml:"host"`

        // Allowed ports and protocols (e.g., ["80/tcp", "443/tcp"])
        Ports []string `json:"ports" yaml:"ports"`
}

// FunctionRunStatus represents the execution status of a function run.
type FunctionRunStatus string

const (
        // FunctionRunStatusPending indicates the function execution is queued
        FunctionRunStatusPending FunctionRunStatus = "Pending"

        // FunctionRunStatusRunning indicates the function is currently executing
        FunctionRunStatusRunning FunctionRunStatus = "Running"

        // FunctionRunStatusSucceeded indicates the function completed successfully
        FunctionRunStatusSucceeded FunctionRunStatus = "Succeeded"

        // FunctionRunStatusFailed indicates the function execution failed
        FunctionRunStatusFailed FunctionRunStatus = "Failed"

        // FunctionRunStatusTimedOut indicates the function execution timed out
        FunctionRunStatusTimedOut FunctionRunStatus = "TimedOut"
)

// FunctionRun represents a single execution of a Function.
type FunctionRun struct {
        // Unique identifier for the function run
        ID string `json:"id" yaml:"id"`

        // ID of the function that was executed
        FunctionID string `json:"functionId" yaml:"functionId"`

        // Namespace the function belongs to
        Namespace string `json:"namespace" yaml:"namespace"`

        // Input payload (JSON-serialized)
        Input string `json:"input,omitempty" yaml:"input,omitempty"`

        // Output result (JSON-serialized)
        Output string `json:"output,omitempty" yaml:"output,omitempty"`

        // Execution logs (stdout/stderr)
        Logs string `json:"logs,omitempty" yaml:"logs,omitempty"`

        // Execution status
        Status FunctionRunStatus `json:"status" yaml:"status"`

        // Error message (if status is Failed or TimedOut)
        Error string `json:"error,omitempty" yaml:"error,omitempty"`

        // Start time
        StartTime *time.Time `json:"startTime,omitempty" yaml:"startTime,omitempty"`

        // End time
        EndTime *time.Time `json:"endTime,omitempty" yaml:"endTime,omitempty"`

        // Duration in milliseconds
        DurationMs int64 `json:"durationMs,omitempty" yaml:"durationMs,omitempty"`

        // Invoker information (component/user that triggered the execution)
        InvokedBy string `json:"invokedBy,omitempty" yaml:"invokedBy,omitempty"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`
}

// FunctionInvocationRequest represents a request to invoke a function.
type FunctionInvocationRequest struct {
        // Payload for the function (JSON-serializable object)
        Payload map[string]interface{} `json:"payload" yaml:"payload"`

        // Timeout override (optional)
        Timeout string `json:"timeout,omitempty" yaml:"timeout,omitempty"`

        // Asynchronous execution flag
        Async bool `json:"async,omitempty" yaml:"async,omitempty"`
}

// FunctionSpec represents the YAML specification for a function.
type FunctionDefinition struct {
        // Function metadata and spec
        Function struct {
                // Human-readable name for the function (required)
                Name string `json:"name" yaml:"name"`

                // Namespace the function belongs to (optional, defaults to "default")
                Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

                // Function specification
                Spec FunctionSpec `json:"spec" yaml:"spec"`
        } `json:"function" yaml:"function"`
}

// Validate checks if a function definition is valid.
func (f *FunctionDefinition) Validate() error <span class="cov0" title="0">{
        if f.Function.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("function name is required")
        }</span>

        <span class="cov0" title="0">if f.Function.Spec.Runtime == "" </span><span class="cov0" title="0">{
                return NewValidationError("function runtime is required")
        }</span>

        <span class="cov0" title="0">if f.Function.Spec.Handler == "" </span><span class="cov0" title="0">{
                return NewValidationError("function handler is required")
        }</span>

        <span class="cov0" title="0">if f.Function.Spec.Code.Inline == "" </span><span class="cov0" title="0">{
                return NewValidationError("function code is required")
        }</span>

        // Validate that network policy allows only specific outbound connections
        <span class="cov0" title="0">if f.Function.Spec.NetworkPolicy != nil </span><span class="cov0" title="0">{
                for _, rule := range f.Function.Spec.NetworkPolicy.Allow </span><span class="cov0" title="0">{
                        if rule.Host == "" </span><span class="cov0" title="0">{
                                return NewValidationError("network policy host is required")
                        }</span>
                        <span class="cov0" title="0">if len(rule.Ports) == 0 </span><span class="cov0" title="0">{
                                return NewValidationError("network policy ports are required")
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// ToFunction converts a FunctionDefinition to a Function.
func (f *FunctionDefinition) ToFunction() (*Function, error) <span class="cov0" title="0">{
        // Validate
        if err := f.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set default namespace if not specified
        <span class="cov0" title="0">namespace := f.Function.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default"
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return &amp;Function{
                ID:        uuid.New().String(),
                Name:      f.Function.Name,
                Namespace: namespace,
                Spec:      f.Function.Spec,
                CreatedAt: now,
                UpdatedAt: now,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package types

import (
        "time"
)

// Instance represents a running copy of a service.
type Instance struct {
        // Runner type for the instance
        Runner RunnerType `json:"runner" yaml:"runner"`

        // Unique identifier for the instance
        ID string `json:"id" yaml:"id"`

        // Namespace of the instance
        Namespace string `json:"namespace" yaml:"namespace"`

        // Human-readable name for the instance
        Name string `json:"name" yaml:"name"`

        // ID of the service this instance belongs to
        ServiceID string `json:"serviceId" yaml:"serviceId"`

        // Name of the service this instance belongs to
        ServiceName string `json:"serviceName" yaml:"serviceName"`

        // ID of the node running this instance
        NodeID string `json:"nodeId" yaml:"nodeId"`

        // IP address assigned to this instance
        IP string `json:"ip" yaml:"ip"`

        // Status of the instance
        Status InstanceStatus `json:"status" yaml:"status"`

        // Detailed status information
        StatusMessage string `json:"statusMessage,omitempty" yaml:"statusMessage,omitempty"`

        // Container ID or process ID
        ContainerID string `json:"containerId,omitempty" yaml:"containerId,omitempty"`

        // Process ID for process runner
        PID int `json:"pid,omitempty" yaml:"pid,omitempty"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`

        // Process-specific configuration for process runner
        Process *ProcessSpec `json:"process,omitempty" yaml:"process,omitempty"`

        // Execution configuration for commands and environment
        Exec *Exec `json:"exec,omitempty" yaml:"exec,omitempty"`

        // Resources requirements for the instance
        Resources *Resources `json:"resources,omitempty" yaml:"resources,omitempty"`

        // Environment variables for the instance
        Environment map[string]string `json:"environment,omitempty" yaml:"environment,omitempty"`
}

// Exec represents execution configuration for a command
type Exec struct {
        // Command to execute
        Command []string `json:"command" yaml:"command"`

        // Environment variables
        Env map[string]string `json:"env,omitempty" yaml:"env,omitempty"`
}

// InstanceStatus represents the current status of an instance.
type InstanceStatus string

const (
        // InstanceStatusPending indicates the instance is being created.
        InstanceStatusPending InstanceStatus = "Pending"

        // InstanceStatusRunning indicates the instance is running.
        InstanceStatusRunning InstanceStatus = "Running"

        // InstanceStatusStopped indicates the instance has stopped.
        InstanceStatusStopped InstanceStatus = "Stopped"

        // InstanceStatusFailed indicates the instance failed to start or crashed.
        InstanceStatusFailed InstanceStatus = "Failed"

        // Process runner specific statuses
        InstanceStatusCreated  InstanceStatus = "Created"
        InstanceStatusStarting InstanceStatus = "Starting"
        InstanceStatusExited   InstanceStatus = "Exited"
        InstanceStatusUnknown  InstanceStatus = "Unknown"
)

// Validate validates the instance configuration.
func (i *Instance) Validate() error <span class="cov0" title="0">{
        if i.ID == "" </span><span class="cov0" title="0">{
                return NewValidationError("instance ID is required")
        }</span>

        <span class="cov0" title="0">if i.Namespace == "" </span><span class="cov0" title="0">{
                return NewValidationError("instance namespace is required")
        }</span>

        <span class="cov0" title="0">if i.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("instance name is required")
        }</span>

        <span class="cov0" title="0">if i.ServiceID == "" </span><span class="cov0" title="0">{
                return NewValidationError("instance serviceId is required")
        }</span>

        <span class="cov0" title="0">if i.NodeID == "" </span><span class="cov0" title="0">{
                return NewValidationError("instance nodeId is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package types

import (
        "fmt"
        "time"

        "github.com/google/uuid"
)

// Job represents a short-lived workload that runs to completion.
type Job struct {
        // Unique identifier for the job
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the job
        Name string `json:"name" yaml:"name"`

        // Namespace the job belongs to
        Namespace string `json:"namespace" yaml:"namespace"`

        // Schedule in cron format (if this is a scheduled job)
        Schedule string `json:"schedule,omitempty" yaml:"schedule,omitempty"`

        // Template defining the job execution environment
        Template JobTemplate `json:"template" yaml:"template"`

        // Optional array job configuration
        Array *JobArray `json:"array,omitempty" yaml:"array,omitempty"`

        // Retry policy for failed job runs
        RetryPolicy *RetryPolicy `json:"retryPolicy,omitempty" yaml:"retryPolicy,omitempty"`

        // How to handle concurrent runs (for scheduled jobs)
        ConcurrencyPolicy string `json:"concurrencyPolicy,omitempty" yaml:"concurrencyPolicy,omitempty"`

        // Number of successful run records to keep
        SuccessfulRunsHistoryLimit int `json:"successfulRunsHistoryLimit,omitempty" yaml:"successfulRunsHistoryLimit,omitempty"`

        // Number of failed run records to keep
        FailedRunsHistoryLimit int `json:"failedRunsHistoryLimit,omitempty" yaml:"failedRunsHistoryLimit,omitempty"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// JobTemplate defines the execution environment for a job.
type JobTemplate struct {
        // Container image for the job
        Image string `json:"image" yaml:"image"`

        // Command to run in the container (overrides image CMD)
        Command string `json:"command,omitempty" yaml:"command,omitempty"`

        // Arguments to the command
        Args []string `json:"args,omitempty" yaml:"args,omitempty"`

        // Environment variables for the job
        Env map[string]string `json:"env,omitempty" yaml:"env,omitempty"`

        // Resource requirements for the job
        Resources Resources `json:"resources,omitempty" yaml:"resources,omitempty"`

        // Volumes to mount in the job container
        Volumes []VolumeMount `json:"volumes,omitempty" yaml:"volumes,omitempty"`

        // Secret mounts
        SecretMounts []SecretMount `json:"secretMounts,omitempty" yaml:"secretMounts,omitempty"`

        // Config mounts
        ConfigMounts []ConfigMount `json:"configMounts,omitempty" yaml:"configMounts,omitempty"`
}

// JobArray defines parameters for array jobs (multiple parallel runs).
type JobArray struct {
        // Number of runs to create in the array
        Count int `json:"count" yaml:"count"`

        // Optional parallelism limit (max concurrent runs)
        Parallelism int `json:"parallelism,omitempty" yaml:"parallelism,omitempty"`
}

// RetryPolicy defines when and how to retry failed jobs.
type RetryPolicy struct {
        // Number of retry attempts
        Count int `json:"count" yaml:"count"`

        // Backoff type (fixed or exponential)
        Backoff string `json:"backoff" yaml:"backoff"`

        // Initial backoff duration in seconds (for fixed or exponential)
        BackoffSeconds int `json:"backoffSeconds,omitempty" yaml:"backoffSeconds,omitempty"`
}

// VolumeMount defines a volume to be mounted in a job or service container.
type VolumeMount struct {
        // Name of the volume mount (for identification)
        Name string `json:"name" yaml:"name"`

        // Path where the volume should be mounted
        MountPath string `json:"mountPath" yaml:"mountPath"`

        // Volume details
        Volume Volume `json:"volume,omitempty" yaml:"volume,omitempty"`
}

// Volume defines a persistent volume that can be mounted.
type Volume struct {
        // Name of the persistent volume
        Name string `json:"name,omitempty" yaml:"name,omitempty"`

        // Storage details
        Storage VolumeStorage `json:"storage,omitempty" yaml:"storage,omitempty"`
}

// VolumeStorage defines storage requirements for a volume.
type VolumeStorage struct {
        // Size of the volume (e.g., "10Gi")
        Size string `json:"size" yaml:"size"`

        // Storage class to use for provisioning
        StorageClassName string `json:"storageClassName" yaml:"storageClassName"`

        // Access mode (ReadWriteOnce, ReadOnlyMany, ReadWriteMany)
        AccessMode string `json:"accessMode" yaml:"accessMode"`
}

// SecretMount defines a secret to be mounted in a container.
type SecretMount struct {
        // Name of the mount (for identification)
        Name string `json:"name" yaml:"name"`

        // Path where the secret should be mounted
        MountPath string `json:"mountPath" yaml:"mountPath"`

        // Name of the secret to mount
        SecretName string `json:"secretName" yaml:"secretName"`

        // Optional: specific keys to project from the secret
        Items []KeyToPath `json:"items,omitempty" yaml:"items,omitempty"`
}

// ConfigMount defines a config to be mounted in a container.
type ConfigMount struct {
        // Name of the mount (for identification)
        Name string `json:"name" yaml:"name"`

        // Path where the config should be mounted
        MountPath string `json:"mountPath" yaml:"mountPath"`

        // Name of the config to mount
        ConfigName string `json:"configName" yaml:"configName"`

        // Optional: specific keys to project from the config
        Items []KeyToPath `json:"items,omitempty" yaml:"items,omitempty"`
}

// KeyToPath defines mapping from a key in a Secret/Config to a path in the mount.
type KeyToPath struct {
        // Key in the Secret or Config
        Key string `json:"key" yaml:"key"`

        // Path where the key should be mounted (relative to mount point)
        Path string `json:"path" yaml:"path"`
}

// JobRun represents a single execution of a Job.
type JobRun struct {
        // Unique identifier for the job run
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the job run
        Name string `json:"name" yaml:"name"`

        // ID of the job this run belongs to
        JobID string `json:"jobId" yaml:"jobId"`

        // Namespace the job run belongs to
        Namespace string `json:"namespace" yaml:"namespace"`

        // Node this job run is/was scheduled on
        NodeID string `json:"nodeId,omitempty" yaml:"nodeId,omitempty"`

        // For array jobs, the index of this run in the array
        ArrayIndex int `json:"arrayIndex,omitempty" yaml:"arrayIndex,omitempty"`

        // Status of the job run
        Status JobRunStatus `json:"status" yaml:"status"`

        // Detailed status message
        StatusMessage string `json:"statusMessage,omitempty" yaml:"statusMessage,omitempty"`

        // Exit code if the job has completed
        ExitCode int `json:"exitCode,omitempty" yaml:"exitCode,omitempty"`

        // Number of restart attempts so far
        RestartCount int `json:"restartCount,omitempty" yaml:"restartCount,omitempty"`

        // Start time
        StartTime *time.Time `json:"startTime,omitempty" yaml:"startTime,omitempty"`

        // Completion time
        CompletionTime *time.Time `json:"completionTime,omitempty" yaml:"completionTime,omitempty"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// JobRunStatus represents the current status of a job run.
type JobRunStatus string

const (
        // JobRunStatusPending indicates the job run is waiting to be scheduled
        JobRunStatusPending JobRunStatus = "Pending"

        // JobRunStatusRunning indicates the job run is currently executing
        JobRunStatusRunning JobRunStatus = "Running"

        // JobRunStatusSucceeded indicates the job run completed successfully
        JobRunStatusSucceeded JobRunStatus = "Succeeded"

        // JobRunStatusFailed indicates the job run failed
        JobRunStatusFailed JobRunStatus = "Failed"
)

// JobSpec represents the YAML specification for a job.
type JobSpec struct {
        // Human-readable name for the job (required)
        Name string `json:"name" yaml:"name"`

        // Namespace the job belongs to (optional, defaults to "default")
        Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

        // Schedule in cron format (if this is a scheduled job)
        Schedule string `json:"schedule,omitempty" yaml:"schedule,omitempty"`

        // Template defining the job execution environment
        Template JobTemplate `json:"template" yaml:"template"`

        // Optional array job configuration
        Array *JobArray `json:"array,omitempty" yaml:"array,omitempty"`

        // Retry policy for failed job runs
        RetryPolicy *RetryPolicy `json:"retryPolicy,omitempty" yaml:"retryPolicy,omitempty"`

        // How to handle concurrent runs (for scheduled jobs)
        ConcurrencyPolicy string `json:"concurrencyPolicy,omitempty" yaml:"concurrencyPolicy,omitempty"`

        // Number of successful run records to keep
        SuccessfulRunsHistoryLimit int `json:"successfulRunsHistoryLimit,omitempty" yaml:"successfulRunsHistoryLimit,omitempty"`

        // Number of failed run records to keep
        FailedRunsHistoryLimit int `json:"failedRunsHistoryLimit,omitempty" yaml:"failedRunsHistoryLimit,omitempty"`
}

// JobFile represents a file containing job definitions.
type JobFile struct {
        // Job definition
        Job *JobSpec `json:"job,omitempty" yaml:"job,omitempty"`

        // Multiple job definitions
        Jobs []JobSpec `json:"jobs,omitempty" yaml:"jobs,omitempty"`
}

// Validate checks if a job specification is valid.
func (j *JobSpec) Validate() error <span class="cov0" title="0">{
        if j.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("job name is required")
        }</span>

        <span class="cov0" title="0">if j.Template.Image == "" </span><span class="cov0" title="0">{
                return NewValidationError("job template image is required")
        }</span>

        <span class="cov0" title="0">if j.Array != nil &amp;&amp; j.Array.Count &lt;= 0 </span><span class="cov0" title="0">{
                return NewValidationError("array job count must be positive")
        }</span>

        <span class="cov0" title="0">if j.Schedule != "" </span>{<span class="cov0" title="0">
                // In a real implementation, validate the cron expression
                // This is a placeholder
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ToJob converts a JobSpec to a Job.
func (j *JobSpec) ToJob() (*Job, error) <span class="cov0" title="0">{
        // Validate
        if err := j.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set default namespace if not specified
        <span class="cov0" title="0">namespace := j.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default"
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return &amp;Job{
                ID:                         uuid.New().String(),
                Name:                       j.Name,
                Namespace:                  namespace,
                Schedule:                   j.Schedule,
                Template:                   j.Template,
                Array:                      j.Array,
                RetryPolicy:                j.RetryPolicy,
                ConcurrencyPolicy:          j.ConcurrencyPolicy,
                SuccessfulRunsHistoryLimit: j.SuccessfulRunsHistoryLimit,
                FailedRunsHistoryLimit:     j.FailedRunsHistoryLimit,
                CreatedAt:                  now,
                UpdatedAt:                  now,
        }, nil</span>
}

// CreateJobRun creates a new JobRun for a Job.
func (j *Job) CreateJobRun(arrayIndex int) *JobRun <span class="cov0" title="0">{
        now := time.Now()

        name := j.Name
        if j.Array != nil &amp;&amp; j.Array.Count &gt; 1 </span><span class="cov0" title="0">{
                name = fmt.Sprintf("%s-%d", j.Name, arrayIndex)
        }</span>

        <span class="cov0" title="0">return &amp;JobRun{
                ID:         uuid.New().String(),
                Name:       name,
                JobID:      j.ID,
                Namespace:  j.Namespace,
                ArrayIndex: arrayIndex,
                Status:     JobRunStatusPending,
                CreatedAt:  now,
                UpdatedAt:  now,
        }</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package types

import (
        "time"

        "github.com/google/uuid"
)

// Namespace represents a logical boundary for isolation and scoping of resources.
type Namespace struct {
        // Unique identifier for the namespace
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the namespace
        Name string `json:"name" yaml:"name"`

        // Optional description for the namespace
        Description string `json:"description,omitempty" yaml:"description,omitempty"`

        // Optional resource quotas for this namespace
        Quota *NamespaceQuota `json:"quota,omitempty" yaml:"quota,omitempty"`

        // Labels attached to the namespace for organization
        Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// NamespaceQuota represents resource quotas for a namespace.
type NamespaceQuota struct {
        // Maximum CPU allocation for all resources in the namespace (millicores)
        CPU int64 `json:"cpu,omitempty" yaml:"cpu,omitempty"`

        // Maximum memory allocation for all resources in the namespace (bytes)
        Memory int64 `json:"memory,omitempty" yaml:"memory,omitempty"`

        // Maximum storage allocation for all resources in the namespace (bytes)
        Storage int64 `json:"storage,omitempty" yaml:"storage,omitempty"`

        // Maximum number of services allowed in the namespace
        Services int `json:"services,omitempty" yaml:"services,omitempty"`

        // Maximum number of jobs allowed in the namespace
        Jobs int `json:"jobs,omitempty" yaml:"jobs,omitempty"`

        // Maximum number of instances (all services combined) allowed in the namespace
        Instances int `json:"instances,omitempty" yaml:"instances,omitempty"`
}

// NamespaceSpec represents the YAML specification for a namespace.
type NamespaceSpec struct {
        // Human-readable name for the namespace (required)
        Name string `json:"name" yaml:"name"`

        // Optional description for the namespace
        Description string `json:"description,omitempty" yaml:"description,omitempty"`

        // Optional resource quotas for this namespace
        Quota *NamespaceQuota `json:"quota,omitempty" yaml:"quota,omitempty"`

        // Labels attached to the namespace for organization
        Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty"`
}

// Validate checks if a namespace specification is valid.
func (n *NamespaceSpec) Validate() error <span class="cov0" title="0">{
        if n.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("namespace name is required")
        }</span>

        // Validate that the name follows DNS label conventions (for DNS compatibility)
        // This is a simplistic validation - should be enhanced with proper regex
        <span class="cov0" title="0">for _, c := range n.Name </span><span class="cov0" title="0">{
                if !((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') || c == '-') </span><span class="cov0" title="0">{
                        return NewValidationError("namespace name must consist of lowercase alphanumeric characters or '-'")
                }</span>
        }

        // Check that it doesn't start or end with a hyphen
        <span class="cov0" title="0">if len(n.Name) &gt; 0 &amp;&amp; (n.Name[0] == '-' || n.Name[len(n.Name)-1] == '-') </span><span class="cov0" title="0">{
                return NewValidationError("namespace name must not start or end with '-'")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ToNamespace converts a NamespaceSpec to a Namespace.
func (n *NamespaceSpec) ToNamespace() (*Namespace, error) <span class="cov0" title="0">{
        // Validate
        if err := n.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return &amp;Namespace{
                ID:          uuid.New().String(),
                Name:        n.Name,
                Description: n.Description,
                Quota:       n.Quota,
                Labels:      n.Labels,
                CreatedAt:   now,
                UpdatedAt:   now,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package types

import (
        "time"
)

// Node represents a machine that can run service instances.
type Node struct {
        // Unique identifier for the node
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the node
        Name string `json:"name" yaml:"name"`

        // IP address or hostname of the node
        Address string `json:"address" yaml:"address"`

        // Labels attached to the node for scheduling decisions
        Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty"`

        // Available resources on this node
        Resources NodeResources `json:"resources" yaml:"resources"`

        // Status of the node
        Status NodeStatus `json:"status" yaml:"status"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last heartbeat timestamp
        LastHeartbeat time.Time `json:"lastHeartbeat" yaml:"lastHeartbeat"`
}

// NodeStatus represents the current status of a node.
type NodeStatus string

const (
        // NodeStatusReady indicates the node is ready to accept instances.
        NodeStatusReady NodeStatus = "Ready"

        // NodeStatusNotReady indicates the node is not ready.
        NodeStatusNotReady NodeStatus = "NotReady"

        // NodeStatusDraining indicates the node is being drained of instances.
        NodeStatusDraining NodeStatus = "Draining"
)

// NodeResources represents the resources available on a node.
type NodeResources struct {
        // Available CPU in millicores (1000m = 1 CPU)
        CPU int64 `json:"cpu" yaml:"cpu"`

        // Available memory in bytes
        Memory int64 `json:"memory" yaml:"memory"`
}

// Validate validates the node configuration.
func (n *Node) Validate() error <span class="cov0" title="0">{
        if n.ID == "" </span><span class="cov0" title="0">{
                return NewValidationError("node ID is required")
        }</span>

        <span class="cov0" title="0">if n.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("node name is required")
        }</span>

        <span class="cov0" title="0">if n.Address == "" </span><span class="cov0" title="0">{
                return NewValidationError("node address is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package types

import (
        "strconv"
        "time"

        "github.com/google/uuid"
)

// Policy represents an RBAC policy that defines permissions.
type Policy struct {
        // Unique identifier for the policy
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the policy
        Name string `json:"name" yaml:"name"`

        // Namespace the policy belongs to
        Namespace string `json:"namespace" yaml:"namespace"`

        // Subject selectors (who this policy applies to)
        Subjects []Subject `json:"subjects" yaml:"subjects"`

        // Permissions granted by this policy
        Permissions []Permission `json:"permissions" yaml:"permissions"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// Subject represents a subject that a policy applies to.
type Subject struct {
        // User identifier (e.g., "alice@example.com")
        User string `json:"user,omitempty" yaml:"user,omitempty"`

        // Group identifier (e.g., "developers")
        Group string `json:"group,omitempty" yaml:"group,omitempty"`

        // Service identifier (e.g., "api")
        Service string `json:"service,omitempty" yaml:"service,omitempty"`

        // Namespace scope for service identity
        Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`
}

// Permission represents a set of actions allowed on resources.
type Permission struct {
        // Resource types this permission applies to (e.g., "service", "secret")
        Resources []string `json:"resources" yaml:"resources"`

        // Specific resource names this permission applies to (optional)
        ResourceNames []string `json:"resourceNames,omitempty" yaml:"resourceNames,omitempty"`

        // Actions allowed on these resources (e.g., "create", "read", "update")
        Actions []string `json:"actions" yaml:"actions"`

        // Namespaces this permission applies to (optional)
        Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty"`
}

// NetworkPolicy represents a set of rules controlling network traffic.
type NetworkPolicy struct {
        // Unique identifier for the network policy
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the network policy
        Name string `json:"name" yaml:"name"`

        // Namespace the network policy belongs to
        Namespace string `json:"namespace" yaml:"namespace"`

        // Selector for the workloads this policy applies to (standalone policy only)
        Selector map[string]string `json:"selector,omitempty" yaml:"selector,omitempty"`

        // Ingress rules (traffic coming into the selected workloads)
        Ingress []IngressRule `json:"ingress,omitempty" yaml:"ingress,omitempty"`

        // Egress rules (traffic going out from the selected workloads)
        Egress []EgressRule `json:"egress,omitempty" yaml:"egress,omitempty"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// IngressRule defines allowed incoming traffic.
type IngressRule struct {
        // Sources allowed to connect to the selected workloads
        From []NetworkPolicyPeer `json:"from" yaml:"from"`

        // Ports that the traffic is allowed on
        Ports []string `json:"ports,omitempty" yaml:"ports,omitempty"`
}

// EgressRule defines allowed outgoing traffic.
type EgressRule struct {
        // Destinations that the selected workloads are allowed to connect to
        To []NetworkPolicyPeer `json:"to" yaml:"to"`

        // Ports that the traffic is allowed on
        Ports []string `json:"ports,omitempty" yaml:"ports,omitempty"`
}

// NetworkPolicyPeer defines a peer in network policy rules.
type NetworkPolicyPeer struct {
        // Service name to allow traffic from/to
        Service string `json:"service,omitempty" yaml:"service,omitempty"`

        // Namespace to allow all traffic from/to
        Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

        // Service selector to match services by label
        ServiceSelector map[string]string `json:"serviceSelector,omitempty" yaml:"serviceSelector,omitempty"`

        // CIDR to allow traffic from/to
        CIDR string `json:"cidr,omitempty" yaml:"cidr,omitempty"`
}

// PolicySpec represents the YAML specification for an RBAC policy.
type PolicySpec struct {
        // Policy metadata and rules
        Policy struct {
                // Human-readable name for the policy (required)
                Name string `json:"name" yaml:"name"`

                // Namespace the policy belongs to (optional, defaults to "default")
                Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

                // Subject selectors (who this policy applies to)
                Subjects []Subject `json:"subjects" yaml:"subjects"`

                // Permissions granted by this policy
                Permissions []Permission `json:"permissions" yaml:"permissions"`
        } `json:"policy" yaml:"policy"`
}

// NetworkPolicySpec represents the YAML specification for a network policy.
type NetworkPolicySpec struct {
        // NetworkPolicy metadata and rules
        NetworkPolicy struct {
                // Human-readable name for the network policy (required)
                Name string `json:"name" yaml:"name"`

                // Namespace the network policy belongs to (optional, defaults to "default")
                Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

                // Selector for the workloads this policy applies to (standalone policy only)
                Selector map[string]string `json:"selector,omitempty" yaml:"selector,omitempty"`

                // Ingress rules (traffic coming into the selected workloads)
                Ingress []IngressRule `json:"ingress,omitempty" yaml:"ingress,omitempty"`

                // Egress rules (traffic going out from the selected workloads)
                Egress []EgressRule `json:"egress,omitempty" yaml:"egress,omitempty"`
        } `json:"networkPolicy" yaml:"networkPolicy"`
}

// ServiceNetworkPolicy represents a network policy embedded in a service spec.
type ServiceNetworkPolicy struct {
        // Ingress rules (traffic coming into the service)
        Ingress []IngressRule `json:"ingress,omitempty" yaml:"ingress,omitempty"`

        // Egress rules (traffic going out from the service)
        Egress []EgressRule `json:"egress,omitempty" yaml:"egress,omitempty"`
}

// Validate checks if a policy specification is valid.
func (p *PolicySpec) Validate() error <span class="cov0" title="0">{
        if p.Policy.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("policy name is required")
        }</span>

        <span class="cov0" title="0">if len(p.Policy.Subjects) == 0 </span><span class="cov0" title="0">{
                return NewValidationError("policy must have at least one subject")
        }</span>

        <span class="cov0" title="0">if len(p.Policy.Permissions) == 0 </span><span class="cov0" title="0">{
                return NewValidationError("policy must have at least one permission")
        }</span>

        // Validate each subject has at least one identifier
        <span class="cov0" title="0">for i, subject := range p.Policy.Subjects </span><span class="cov0" title="0">{
                if subject.User == "" &amp;&amp; subject.Group == "" &amp;&amp; subject.Service == "" </span><span class="cov0" title="0">{
                        return NewValidationError("subject at index " + strconv.Itoa(i) + " must specify user, group, or service")
                }</span>

                <span class="cov0" title="0">if subject.Service != "" &amp;&amp; subject.Namespace == "" </span><span class="cov0" title="0">{
                        return NewValidationError("service subject must specify a namespace")
                }</span>
        }

        // Validate each permission has resources and actions
        <span class="cov0" title="0">for i, permission := range p.Policy.Permissions </span><span class="cov0" title="0">{
                if len(permission.Resources) == 0 </span><span class="cov0" title="0">{
                        return NewValidationError("permission at index " + strconv.Itoa(i) + " must specify resources")
                }</span>

                <span class="cov0" title="0">if len(permission.Actions) == 0 </span><span class="cov0" title="0">{
                        return NewValidationError("permission at index " + strconv.Itoa(i) + " must specify actions")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Validate checks if a network policy specification is valid.
func (n *NetworkPolicySpec) Validate() error <span class="cov0" title="0">{
        if n.NetworkPolicy.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("network policy name is required")
        }</span>

        // Validate each ingress rule
        <span class="cov0" title="0">for i, rule := range n.NetworkPolicy.Ingress </span><span class="cov0" title="0">{
                if len(rule.From) == 0 </span><span class="cov0" title="0">{
                        return NewValidationError("ingress rule at index " + strconv.Itoa(i) + " must specify 'from' peers")
                }</span>

                // Validate each peer has at least one identifier
                <span class="cov0" title="0">for j, peer := range rule.From </span><span class="cov0" title="0">{
                        if peer.Service == "" &amp;&amp; peer.Namespace == "" &amp;&amp; len(peer.ServiceSelector) == 0 &amp;&amp; peer.CIDR == "" </span><span class="cov0" title="0">{
                                return NewValidationError("ingress peer at index " + strconv.Itoa(j) + " in rule " + strconv.Itoa(i) + " must specify service, namespace, serviceSelector, or cidr")
                        }</span>
                }
        }

        // Validate each egress rule
        <span class="cov0" title="0">for i, rule := range n.NetworkPolicy.Egress </span><span class="cov0" title="0">{
                if len(rule.To) == 0 </span><span class="cov0" title="0">{
                        return NewValidationError("egress rule at index " + strconv.Itoa(i) + " must specify 'to' peers")
                }</span>

                // Validate each peer has at least one identifier
                <span class="cov0" title="0">for j, peer := range rule.To </span><span class="cov0" title="0">{
                        if peer.Service == "" &amp;&amp; peer.Namespace == "" &amp;&amp; len(peer.ServiceSelector) == 0 &amp;&amp; peer.CIDR == "" </span><span class="cov0" title="0">{
                                return NewValidationError("egress peer at index " + strconv.Itoa(j) + " in rule " + strconv.Itoa(i) + " must specify service, namespace, serviceSelector, or cidr")
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Validate checks if a service network policy is valid.
func (s *ServiceNetworkPolicy) Validate() error <span class="cov8" title="1">{
        // Validate each ingress rule
        for i, rule := range s.Ingress </span><span class="cov8" title="1">{
                if len(rule.From) == 0 </span><span class="cov0" title="0">{
                        return NewValidationError("ingress rule at index " + strconv.Itoa(i) + " must specify 'from' peers")
                }</span>

                // Validate each peer has at least one identifier
                <span class="cov8" title="1">for j, peer := range rule.From </span><span class="cov8" title="1">{
                        if peer.Service == "" &amp;&amp; peer.Namespace == "" &amp;&amp; len(peer.ServiceSelector) == 0 &amp;&amp; peer.CIDR == "" </span><span class="cov0" title="0">{
                                return NewValidationError("ingress peer at index " + strconv.Itoa(j) + " in rule " + strconv.Itoa(i) + " must specify service, namespace, serviceSelector, or cidr")
                        }</span>
                }
        }

        // Validate each egress rule
        <span class="cov8" title="1">for i, rule := range s.Egress </span><span class="cov0" title="0">{
                if len(rule.To) == 0 </span><span class="cov0" title="0">{
                        return NewValidationError("egress rule at index " + strconv.Itoa(i) + " must specify 'to' peers")
                }</span>

                // Validate each peer has at least one identifier
                <span class="cov0" title="0">for j, peer := range rule.To </span><span class="cov0" title="0">{
                        if peer.Service == "" &amp;&amp; peer.Namespace == "" &amp;&amp; len(peer.ServiceSelector) == 0 &amp;&amp; peer.CIDR == "" </span><span class="cov0" title="0">{
                                return NewValidationError("egress peer at index " + strconv.Itoa(j) + " in rule " + strconv.Itoa(i) + " must specify service, namespace, serviceSelector, or cidr")
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// ToPolicy converts a PolicySpec to a Policy.
func (p *PolicySpec) ToPolicy() (*Policy, error) <span class="cov0" title="0">{
        // Validate
        if err := p.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set default namespace if not specified
        <span class="cov0" title="0">namespace := p.Policy.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default"
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return &amp;Policy{
                ID:          uuid.New().String(),
                Name:        p.Policy.Name,
                Namespace:   namespace,
                Subjects:    p.Policy.Subjects,
                Permissions: p.Policy.Permissions,
                CreatedAt:   now,
                UpdatedAt:   now,
        }, nil</span>
}

// ToNetworkPolicy converts a NetworkPolicySpec to a NetworkPolicy.
func (n *NetworkPolicySpec) ToNetworkPolicy() (*NetworkPolicy, error) <span class="cov0" title="0">{
        // Validate
        if err := n.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set default namespace if not specified
        <span class="cov0" title="0">namespace := n.NetworkPolicy.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default"
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return &amp;NetworkPolicy{
                ID:        uuid.New().String(),
                Name:      n.NetworkPolicy.Name,
                Namespace: namespace,
                Selector:  n.NetworkPolicy.Selector,
                Ingress:   n.NetworkPolicy.Ingress,
                Egress:    n.NetworkPolicy.Egress,
                CreatedAt: now,
                UpdatedAt: now,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package types

// ProcessSpec defines how to run a service as a process
type ProcessSpec struct {
        // Command to run
        Command string `json:"command" yaml:"command"`

        // Command arguments
        Args []string `json:"args,omitempty" yaml:"args,omitempty"`

        // Working directory for the process
        WorkingDir string `json:"workingDir,omitempty" yaml:"workingDir,omitempty"`

        // Security settings
        SecurityContext *ProcessSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty"`
}

// ProcessSecurityContext defines security settings for a process
type ProcessSecurityContext struct {
        // User to run as
        User string `json:"user,omitempty" yaml:"user,omitempty"`

        // Group to run as
        Group string `json:"group,omitempty" yaml:"group,omitempty"`

        // Run with read-only filesystem
        ReadOnlyFS bool `json:"readOnlyFS,omitempty" yaml:"readOnlyFS,omitempty"`

        // Linux capabilities to add
        Capabilities []string `json:"capabilities,omitempty" yaml:"capabilities,omitempty"`

        // Allowed syscalls (seccomp)
        AllowedSyscalls []string `json:"allowedSyscalls,omitempty" yaml:"allowedSyscalls,omitempty"`

        // Denied syscalls (seccomp)
        DeniedSyscalls []string `json:"deniedSyscalls,omitempty" yaml:"deniedSyscalls,omitempty"`
}

// Validate validates the process specification
func (p *ProcessSpec) Validate() error <span class="cov0" title="0">{
        if p.Command == "" </span><span class="cov0" title="0">{
                return NewValidationError("process command is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package types

import (
        "strconv"
        "strings"
)

// ResourceHelpers contains utility functions for working with Resources

// ParseCPU parses a CPU request/limit string into a float64 (cores)
// Examples: "100m" -&gt; 0.1, "0.5" -&gt; 0.5, "2" -&gt; 2.0
func ParseCPU(cpu string) (float64, error) <span class="cov0" title="0">{
        if cpu == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Check for millicores (e.g. "100m")
        <span class="cov0" title="0">if strings.HasSuffix(cpu, "m") </span><span class="cov0" title="0">{
                millicores, err := strconv.Atoi(cpu[:len(cpu)-1])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">return float64(millicores) / 1000.0, nil</span>
        }

        // Regular floating point value
        <span class="cov0" title="0">return strconv.ParseFloat(cpu, 64)</span>
}

// ParseMemory parses a memory request/limit string into bytes
// Examples: "100Mi" -&gt; 104857600, "1Gi" -&gt; 1073741824, "2G" -&gt; 2000000000
func ParseMemory(memory string) (int64, error) <span class="cov0" title="0">{
        if memory == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Units and their byte equivalents
        <span class="cov0" title="0">units := map[string]int64{
                "":   1,
                "k":  1000,
                "m":  1000000,
                "g":  1000000000,
                "t":  1000000000000,
                "p":  1000000000000000,
                "e":  1000000000000000000,
                "ki": 1024,
                "mi": 1048576,
                "gi": 1073741824,
                "ti": 1099511627776,
                "pi": 1125899906842624,
                "ei": 1152921504606846976,
        }

        memory = strings.ToLower(memory)
        var unit string
        var value string

        // Find the unit suffix
        for i := len(memory) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if strings.ContainsAny(string(memory[i]), "0123456789.") </span><span class="cov0" title="0">{
                        value = memory[:i+1]
                        unit = strings.ToLower(memory[i+1:])
                        break</span>
                }
        }

        // If no unit found, the entire string is the value
        <span class="cov0" title="0">if value == "" </span><span class="cov0" title="0">{
                value = memory
                unit = ""
        }</span>

        // Parse the numeric part
        <span class="cov0" title="0">num, err := strconv.ParseFloat(value, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Find the multiplier for the unit
        <span class="cov0" title="0">multiplier, ok := units[unit]
        if !ok </span><span class="cov0" title="0">{
                return 0, NewValidationError("unknown memory unit: " + unit)
        }</span>

        <span class="cov0" title="0">return int64(num * float64(multiplier)), nil</span>
}

// FormatCPU formats a CPU value as a string
// Examples: 0.1 -&gt; "100m", 0.5 -&gt; "500m", 2.0 -&gt; "2"
func FormatCPU(cpu float64) string <span class="cov0" title="0">{
        if cpu == 0 </span><span class="cov0" title="0">{
                return "0"
        }</span>

        // If it's a whole number or close to it, format as an integer
        <span class="cov0" title="0">if cpu &gt;= 1.0 &amp;&amp; cpu == float64(int64(cpu)) </span><span class="cov0" title="0">{
                return strconv.FormatInt(int64(cpu), 10)
        }</span>

        // Otherwise, format as millicores
        <span class="cov0" title="0">return strconv.FormatInt(int64(cpu*1000), 10) + "m"</span>
}

// FormatMemory formats memory bytes as a human-readable string
// Uses binary units (Ki, Mi, Gi, etc.)
func FormatMemory(bytes int64) string <span class="cov0" title="0">{
        if bytes == 0 </span><span class="cov0" title="0">{
                return "0"
        }</span>

        <span class="cov0" title="0">const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return strconv.FormatInt(bytes, 10) + "B"
        }</span>

        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>

        <span class="cov0" title="0">units := []string{"Ki", "Mi", "Gi", "Ti", "Pi", "Ei"}
        return strconv.FormatFloat(float64(bytes)/float64(div), 'f', 1, 64) + units[exp]</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package types

import (
        "time"

        "github.com/google/uuid"
)

// Secret represents a securely stored piece of sensitive data.
type Secret struct {
        // Unique identifier for the secret
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the secret
        Name string `json:"name" yaml:"name"`

        // Namespace the secret belongs to
        Namespace string `json:"namespace" yaml:"namespace"`

        // Type of secret (static or dynamic)
        Type string `json:"type" yaml:"type"`

        // Static data (encrypted at rest, only for static secrets)
        Data map[string]string `json:"-" yaml:"-"` // Not serialized, stored encrypted separately

        // Engine configuration for dynamic secrets
        Engine *SecretEngine `json:"engine,omitempty" yaml:"engine,omitempty"`

        // Rotation configuration
        Rotation *RotationPolicy `json:"rotation,omitempty" yaml:"rotation,omitempty"`

        // Current version number
        Version int `json:"version" yaml:"version"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`

        // Last rotation timestamp
        LastRotated *time.Time `json:"lastRotated,omitempty" yaml:"lastRotated,omitempty"`
}

// SecretEngine defines a dynamic secret engine configuration.
type SecretEngine struct {
        // Name of the engine to use (references a SecretsEngine resource)
        Name string `json:"name" yaml:"name"`

        // Role or profile to use with the engine (engine-specific)
        Role string `json:"role,omitempty" yaml:"role,omitempty"`

        // Engine-specific configuration for this secret
        Config map[string]interface{} `json:"config,omitempty" yaml:"config,omitempty"`
}

// RotationPolicy defines when and how to rotate a secret.
type RotationPolicy struct {
        // Interval between rotations (e.g., "30d", "90d")
        Interval string `json:"interval" yaml:"interval"`

        // Actions to take after rotation
        OnRotate []RotationAction `json:"onRotate,omitempty" yaml:"onRotate,omitempty"`
}

// RotationAction defines an action to take after secret rotation.
type RotationAction struct {
        // Services to reload (send SIGHUP)
        ReloadServices []string `json:"reloadServices,omitempty" yaml:"reloadServices,omitempty"`

        // Services to restart (rolling restart)
        RestartServices []string `json:"restartServices,omitempty" yaml:"restartServices,omitempty"`

        // Job to run
        RunJob string `json:"runJob,omitempty" yaml:"runJob,omitempty"`
}

// Config represents a piece of non-sensitive configuration data.
type Config struct {
        // Unique identifier for the config
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the config
        Name string `json:"name" yaml:"name"`

        // Namespace the config belongs to
        Namespace string `json:"namespace" yaml:"namespace"`

        // Configuration data (not encrypted)
        Data map[string]string `json:"data" yaml:"data"`

        // Current version number
        Version int `json:"version" yaml:"version"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// SecretsEngine represents a configured secrets engine.
type SecretsEngine struct {
        // Unique identifier for the engine
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the engine
        Name string `json:"name" yaml:"name"`

        // Namespace the engine belongs to
        Namespace string `json:"namespace" yaml:"namespace"`

        // Type of engine (builtin, function, plugin)
        Type string `json:"type" yaml:"type"`

        // For function-based engines, the reference to the function
        Function string `json:"function,omitempty" yaml:"function,omitempty"`

        // For plugin-based engines, the path to the plugin executable
        Path string `json:"path,omitempty" yaml:"path,omitempty"`

        // Engine-wide configuration
        Config map[string]interface{} `json:"config,omitempty" yaml:"config,omitempty"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`
}

// SecretSpec represents the YAML specification for a secret.
type SecretSpec struct {
        // Secret metadata and data
        Secret struct {
                // Human-readable name for the secret (required)
                Name string `json:"name" yaml:"name"`

                // Namespace the secret belongs to (optional, defaults to "default")
                Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

                // Type of secret (static or dynamic)
                Type string `json:"type" yaml:"type"`

                // Secret data for static secrets (only for creation, not returned in GET)
                Data map[string]string `json:"data,omitempty" yaml:"data,omitempty"`

                // Single value convenience field (alternative to data.value for simple secrets)
                Value string `json:"value,omitempty" yaml:"value,omitempty"`

                // Base64-encoded value (for binary data)
                ValueBase64 string `json:"valueBase64,omitempty" yaml:"valueBase64,omitempty"`

                // Engine configuration for dynamic secrets
                Engine *SecretEngine `json:"engine,omitempty" yaml:"engine,omitempty"`

                // Rotation configuration
                Rotation *RotationPolicy `json:"rotation,omitempty" yaml:"rotation,omitempty"`
        } `json:"secret" yaml:"secret"`
}

// ConfigSpec represents the YAML specification for a config.
type ConfigSpec struct {
        // Config metadata and data
        Config struct {
                // Human-readable name for the config (required)
                Name string `json:"name" yaml:"name"`

                // Namespace the config belongs to (optional, defaults to "default")
                Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

                // Config data
                Data map[string]string `json:"data" yaml:"data"`
        } `json:"config" yaml:"config"`
}

// SecretsEngineSpec represents the YAML specification for a secrets engine.
type SecretsEngineSpec struct {
        // Engine metadata and configuration
        SecretsEngine struct {
                // Human-readable name for the engine (required)
                Name string `json:"name" yaml:"name"`

                // Namespace the engine belongs to (optional, defaults to "default")
                Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

                // Type of engine (required: builtin, function, plugin)
                Type string `json:"type" yaml:"type"`

                // For function-based engines, the reference to the function
                Function string `json:"function,omitempty" yaml:"function,omitempty"`

                // For plugin-based engines, the path to the plugin executable
                Path string `json:"path,omitempty" yaml:"path,omitempty"`

                // Engine-wide configuration
                Config map[string]interface{} `json:"config,omitempty" yaml:"config,omitempty"`
        } `json:"secretsEngine" yaml:"secretsEngine"`
}

// Validate checks if a secret specification is valid.
func (s *SecretSpec) Validate() error <span class="cov0" title="0">{
        if s.Secret.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("secret name is required")
        }</span>

        <span class="cov0" title="0">if s.Secret.Type != "static" &amp;&amp; s.Secret.Type != "dynamic" </span><span class="cov0" title="0">{
                return NewValidationError("secret type must be 'static' or 'dynamic'")
        }</span>

        <span class="cov0" title="0">if s.Secret.Type == "static" </span><span class="cov0" title="0">{
                // For static secrets, either data, value, or valueBase64 must be provided
                if len(s.Secret.Data) == 0 &amp;&amp; s.Secret.Value == "" &amp;&amp; s.Secret.ValueBase64 == "" </span><span class="cov0" title="0">{
                        return NewValidationError("static secret must have data, value, or valueBase64")
                }</span>
        } else<span class="cov0" title="0"> if s.Secret.Type == "dynamic" </span><span class="cov0" title="0">{
                // For dynamic secrets, engine must be specified
                if s.Secret.Engine == nil </span><span class="cov0" title="0">{
                        return NewValidationError("dynamic secret must have an engine configuration")
                }</span>

                <span class="cov0" title="0">if s.Secret.Engine.Name == "" </span><span class="cov0" title="0">{
                        return NewValidationError("dynamic secret engine name is required")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Validate checks if a config specification is valid.
func (c *ConfigSpec) Validate() error <span class="cov0" title="0">{
        if c.Config.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("config name is required")
        }</span>

        <span class="cov0" title="0">if len(c.Config.Data) == 0 </span><span class="cov0" title="0">{
                return NewValidationError("config must have data")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Validate checks if a secrets engine specification is valid.
func (s *SecretsEngineSpec) Validate() error <span class="cov0" title="0">{
        if s.SecretsEngine.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("secrets engine name is required")
        }</span>

        <span class="cov0" title="0">if s.SecretsEngine.Type == "" </span><span class="cov0" title="0">{
                return NewValidationError("secrets engine type is required")
        }</span>

        // Type-specific validation
        <span class="cov0" title="0">switch s.SecretsEngine.Type </span>{
        case "function":<span class="cov0" title="0">
                if s.SecretsEngine.Function == "" </span><span class="cov0" title="0">{
                        return NewValidationError("function-based secrets engine must specify a function")
                }</span>
        case "plugin":<span class="cov0" title="0">
                if s.SecretsEngine.Path == "" </span><span class="cov0" title="0">{
                        return NewValidationError("plugin-based secrets engine must specify a path")
                }</span>
        case "builtin":<span class="cov0" title="0"></span>
                // No additional validation for builtin engines
        default:<span class="cov0" title="0">
                return NewValidationError("unknown secrets engine type: " + s.SecretsEngine.Type)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ToSecret converts a SecretSpec to a Secret.
func (s *SecretSpec) ToSecret() (*Secret, error) <span class="cov0" title="0">{
        // Validate
        if err := s.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set default namespace if not specified
        <span class="cov0" title="0">namespace := s.Secret.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default"
        }</span>

        <span class="cov0" title="0">now := time.Now()

        // Create the secret
        secret := &amp;Secret{
                ID:        uuid.New().String(),
                Name:      s.Secret.Name,
                Namespace: namespace,
                Type:      s.Secret.Type,
                Engine:    s.Secret.Engine,
                Rotation:  s.Secret.Rotation,
                Version:   1,
                CreatedAt: now,
                UpdatedAt: now,
        }

        // For static secrets, set the data map
        if s.Secret.Type == "static" </span><span class="cov0" title="0">{
                data := make(map[string]string)

                // Start with any values in the data map
                for k, v := range s.Secret.Data </span><span class="cov0" title="0">{
                        data[k] = v
                }</span>

                // If value field is set, add it
                <span class="cov0" title="0">if s.Secret.Value != "" </span><span class="cov0" title="0">{
                        data["value"] = s.Secret.Value
                }</span>

                // If valueBase64 field is set, add it
                // In a real implementation, we'd decode this and store the raw value
                <span class="cov0" title="0">if s.Secret.ValueBase64 != "" </span><span class="cov0" title="0">{
                        data["valueBase64"] = s.Secret.ValueBase64
                }</span>

                <span class="cov0" title="0">secret.Data = data</span>
        }

        <span class="cov0" title="0">return secret, nil</span>
}

// ToConfig converts a ConfigSpec to a Config.
func (c *ConfigSpec) ToConfig() (*Config, error) <span class="cov0" title="0">{
        // Validate
        if err := c.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set default namespace if not specified
        <span class="cov0" title="0">namespace := c.Config.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default"
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return &amp;Config{
                ID:        uuid.New().String(),
                Name:      c.Config.Name,
                Namespace: namespace,
                Data:      c.Config.Data,
                Version:   1,
                CreatedAt: now,
                UpdatedAt: now,
        }, nil</span>
}

// ToSecretsEngine converts a SecretsEngineSpec to a SecretsEngine.
func (s *SecretsEngineSpec) ToSecretsEngine() (*SecretsEngine, error) <span class="cov0" title="0">{
        // Validate
        if err := s.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set default namespace if not specified
        <span class="cov0" title="0">namespace := s.SecretsEngine.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = "default"
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return &amp;SecretsEngine{
                ID:        uuid.New().String(),
                Name:      s.SecretsEngine.Name,
                Namespace: namespace,
                Type:      s.SecretsEngine.Type,
                Function:  s.SecretsEngine.Function,
                Path:      s.SecretsEngine.Path,
                Config:    s.SecretsEngine.Config,
                CreatedAt: now,
                UpdatedAt: now,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package types

import (
        "strconv"
        "time"
)

// Service represents a deployable application or workload.
type Service struct {
        // Unique identifier for the service
        ID string `json:"id" yaml:"id"`

        // Human-readable name for the service
        Name string `json:"name" yaml:"name"`

        // Namespace the service belongs to
        Namespace string `json:"namespace" yaml:"namespace"`

        // Labels are key/value pairs that can be used to organize and categorize services
        Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty"`

        // Container image for the service
        Image string `json:"image,omitempty" yaml:"image,omitempty"`

        // Command to run in the container (overrides image CMD)
        Command string `json:"command,omitempty" yaml:"command,omitempty"`

        // Arguments to the command
        Args []string `json:"args,omitempty" yaml:"args,omitempty"`

        // Environment variables for the service
        Env map[string]string `json:"env,omitempty" yaml:"env,omitempty"`

        // Number of instances to run
        Scale int `json:"scale" yaml:"scale"`

        // Ports exposed by the service
        Ports []ServicePort `json:"ports,omitempty" yaml:"ports,omitempty"`

        // Resource requirements for each instance
        Resources Resources `json:"resources,omitempty" yaml:"resources,omitempty"`

        // Health checks for the service
        Health *HealthCheck `json:"health,omitempty" yaml:"health,omitempty"`

        // Network policy for controlling traffic
        NetworkPolicy *ServiceNetworkPolicy `json:"networkPolicy,omitempty" yaml:"networkPolicy,omitempty"`

        // External exposure configuration
        Expose *ServiceExpose `json:"expose,omitempty" yaml:"expose,omitempty"`

        // Placement preferences and requirements
        Affinity *ServiceAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty"`

        // Autoscaling configuration
        Autoscale *ServiceAutoscale `json:"autoscale,omitempty" yaml:"autoscale,omitempty"`

        // Secret mounts
        SecretMounts []SecretMount `json:"secretMounts,omitempty" yaml:"secretMounts,omitempty"`

        // Config mounts
        ConfigMounts []ConfigMount `json:"configMounts,omitempty" yaml:"configMounts,omitempty"`

        // Service discovery configuration
        Discovery *ServiceDiscovery `json:"discovery,omitempty" yaml:"discovery,omitempty"`

        // Status of the service
        Status ServiceStatus `json:"status" yaml:"status"`

        // Instances of this service currently running
        Instances []Instance `json:"instances,omitempty" yaml:"instances,omitempty"`

        // Creation timestamp
        CreatedAt time.Time `json:"createdAt" yaml:"createdAt"`

        // Last update timestamp
        UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt"`

        // Runtime for the service ("container" or "process")
        Runtime RuntimeType `json:"runtime,omitempty" yaml:"runtime,omitempty"`

        // Process-specific configuration (when Runtime="process")
        Process *ProcessSpec `json:"process,omitempty" yaml:"process,omitempty"`

        // Restart policy for the service
        RestartPolicy RestartPolicy `json:"restart_policy,omitempty" yaml:"restart_policy,omitempty"`
}

// ServicePort represents a port exposed by a service.
type ServicePort struct {
        // Name for this port (used in references)
        Name string `json:"name" yaml:"name"`

        // Port number
        Port int `json:"port" yaml:"port"`

        // Target port (if different from port)
        TargetPort int `json:"targetPort,omitempty" yaml:"targetPort,omitempty"`

        // Protocol (default: TCP)
        Protocol string `json:"protocol,omitempty" yaml:"protocol,omitempty"`
}

// ServiceExpose defines how a service is exposed externally.
type ServiceExpose struct {
        // Port or port name to expose
        Port string `json:"port" yaml:"port"`

        // Host for the exposed service
        Host string `json:"host,omitempty" yaml:"host,omitempty"`

        // Path prefix for the exposed service
        Path string `json:"path,omitempty" yaml:"path,omitempty"`

        // TLS configuration for the exposed service
        TLS *ExposeServiceTLS `json:"tls,omitempty" yaml:"tls,omitempty"`
}

// ExposeServiceTLS defines TLS configuration for exposed services.
type ExposeServiceTLS struct {
        // Secret name containing TLS certificate and key
        SecretName string `json:"secretName,omitempty" yaml:"secretName,omitempty"`

        // Whether to automatically generate a TLS certificate
        Auto bool `json:"auto,omitempty" yaml:"auto,omitempty"`
}

// ServiceDiscovery defines how a service is discovered by other services.
type ServiceDiscovery struct {
        // Discovery mode (load-balanced or headless)
        Mode string `json:"mode,omitempty" yaml:"mode,omitempty"`
}

// ServiceAffinity defines placement rules for a service.
type ServiceAffinity struct {
        // Hard constraints (service can only run on nodes matching these)
        Required []string `json:"required,omitempty" yaml:"required,omitempty"`

        // Soft preferences (scheduler will try to place on nodes matching these)
        Preferred []string `json:"preferred,omitempty" yaml:"preferred,omitempty"`

        // Run instances near services matching these labels
        With []string `json:"with,omitempty" yaml:"with,omitempty"`

        // Avoid running instances on nodes with services matching these labels
        Avoid []string `json:"avoid,omitempty" yaml:"avoid,omitempty"`

        // Try to distribute instances across this topology key (e.g., "zone")
        Spread string `json:"spread,omitempty" yaml:"spread,omitempty"`
}

// ServiceAutoscale defines autoscaling behavior for a service.
type ServiceAutoscale struct {
        // Whether autoscaling is enabled
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Minimum number of instances
        Min int `json:"min" yaml:"min"`

        // Maximum number of instances
        Max int `json:"max" yaml:"max"`

        // Metric to scale on (e.g., cpu, memory)
        Metric string `json:"metric" yaml:"metric"`

        // Target value for the metric (e.g., 70%)
        Target string `json:"target" yaml:"target"`

        // Cooldown period between scaling events
        Cooldown string `json:"cooldown,omitempty" yaml:"cooldown,omitempty"`

        // Maximum number of instances to add/remove in a single scaling event
        Step int `json:"step,omitempty" yaml:"step,omitempty"`
}

// ServiceStatus represents the current status of a service.
type ServiceStatus string

const (
        // ServiceStatusPending indicates the service is being created.
        ServiceStatusPending ServiceStatus = "Pending"

        // ServiceStatusRunning indicates the service is running.
        ServiceStatusRunning ServiceStatus = "Running"

        // ServiceStatusDeploying indicates the service is being updated.
        ServiceStatusDeploying ServiceStatus = "Deploying"

        // ServiceStatusFailed indicates the service failed to deploy or run.
        ServiceStatusFailed ServiceStatus = "Failed"

        // ServiceStatusDeleted indicates the service has been deleted.
        ServiceStatusDeleted ServiceStatus = "Deleted"
)

// Resources represents resource requirements for a service instance.
type Resources struct {
        // CPU request in millicores (1000m = 1 CPU)
        CPU ResourceLimit `json:"cpu,omitempty" yaml:"cpu,omitempty"`

        // Memory request in bytes
        Memory ResourceLimit `json:"memory,omitempty" yaml:"memory,omitempty"`
}

// ResourceLimit defines request and limit for a resource.
type ResourceLimit struct {
        // Requested resources (guaranteed)
        Request string `json:"request,omitempty" yaml:"request,omitempty"`

        // Maximum resources (limit)
        Limit string `json:"limit,omitempty" yaml:"limit,omitempty"`
}

// HealthCheck represents health check configuration for a service.
type HealthCheck struct {
        // Liveness probe checks if the instance is running
        Liveness *Probe `json:"liveness,omitempty" yaml:"liveness,omitempty"`

        // Readiness probe checks if the instance is ready to receive traffic
        Readiness *Probe `json:"readiness,omitempty" yaml:"readiness,omitempty"`
}

// Probe represents a health check probe configuration.
type Probe struct {
        // Type of probe (http, tcp, exec)
        Type string `json:"type" yaml:"type"`

        // HTTP path for http probe
        Path string `json:"path,omitempty" yaml:"path,omitempty"`

        // Port to connect to
        Port int `json:"port" yaml:"port"`

        // Command to execute for exec probe
        Command []string `json:"command,omitempty" yaml:"command,omitempty"`

        // Initial delay seconds before starting checks
        InitialDelaySeconds int `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty"`

        // Interval between checks in seconds
        IntervalSeconds int `json:"intervalSeconds,omitempty" yaml:"intervalSeconds,omitempty"`

        // Timeout for the probe in seconds
        TimeoutSeconds int `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty"`

        // Failure threshold for the probe
        FailureThreshold int `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty"`

        // Success threshold for the probe
        SuccessThreshold int `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty"`
}

// RestartPolicy defines how instances should be restarted
type RestartPolicy string

const (
        // RestartPolicyAlways means always restart when not explicitly stopped
        RestartPolicyAlways RestartPolicy = "Always"

        // RestartPolicyOnFailure means only restart on failure
        RestartPolicyOnFailure RestartPolicy = "OnFailure"

        // RestartPolicyNever means never restart automatically, only manual restarts are allowed
        RestartPolicyNever RestartPolicy = "Never"
)

// Validate validates the service configuration.
func (s *Service) Validate() error <span class="cov0" title="0">{
        if s.ID == "" </span><span class="cov0" title="0">{
                return NewValidationError("service ID is required")
        }</span>

        <span class="cov0" title="0">if s.Name == "" </span><span class="cov0" title="0">{
                return NewValidationError("service name is required")
        }</span>

        // Check runtime specific requirements
        <span class="cov0" title="0">if s.Runtime == "container" || s.Runtime == "" </span><span class="cov0" title="0">{
                // Default is container runtime
                if s.Image == "" </span><span class="cov0" title="0">{
                        return NewValidationError("service image is required for container runtime")
                }</span>
        } else<span class="cov0" title="0"> if s.Runtime == "process" </span><span class="cov0" title="0">{
                // For process runtime, we need a process spec
                if s.Process == nil </span><span class="cov0" title="0">{
                        return NewValidationError("process configuration is required for process runtime")
                }</span>
                <span class="cov0" title="0">if err := s.Process.Validate(); err != nil </span><span class="cov0" title="0">{
                        return WrapValidationError(err, "invalid process configuration")
                }</span>
        } else<span class="cov0" title="0"> {
                return NewValidationError("unknown runtime: " + string(s.Runtime))
        }</span>

        <span class="cov0" title="0">if s.Scale &lt; 0 </span><span class="cov0" title="0">{
                return NewValidationError("service scale cannot be negative")
        }</span>

        // Validate ports if present
        <span class="cov0" title="0">for i, port := range s.Ports </span><span class="cov0" title="0">{
                if port.Name == "" </span><span class="cov0" title="0">{
                        return NewValidationError("port name is required for port at index " + strconv.Itoa(i))
                }</span>
                <span class="cov0" title="0">if port.Port &lt;= 0 || port.Port &gt; 65535 </span><span class="cov0" title="0">{
                        return NewValidationError("port must be between 1 and 65535 for port " + port.Name)
                }</span>
        }

        // Validate health checks if present
        <span class="cov0" title="0">if s.Health != nil </span><span class="cov0" title="0">{
                if err := s.Health.Validate(); err != nil </span><span class="cov0" title="0">{
                        return WrapValidationError(err, "invalid health check")
                }</span>
        }

        // Validate network policy if present
        <span class="cov0" title="0">if s.NetworkPolicy != nil </span><span class="cov0" title="0">{
                if err := s.NetworkPolicy.Validate(); err != nil </span><span class="cov0" title="0">{
                        return WrapValidationError(err, "invalid network policy")
                }</span>
        }

        // Validate autoscale if present
        <span class="cov0" title="0">if s.Autoscale != nil &amp;&amp; s.Autoscale.Enabled </span><span class="cov0" title="0">{
                if s.Autoscale.Min &lt; 0 </span><span class="cov0" title="0">{
                        return NewValidationError("autoscale min cannot be negative")
                }</span>
                <span class="cov0" title="0">if s.Autoscale.Max &lt; s.Autoscale.Min </span><span class="cov0" title="0">{
                        return NewValidationError("autoscale max cannot be less than min")
                }</span>
                <span class="cov0" title="0">if s.Autoscale.Metric == "" </span><span class="cov0" title="0">{
                        return NewValidationError("autoscale metric is required")
                }</span>
                <span class="cov0" title="0">if s.Autoscale.Target == "" </span><span class="cov0" title="0">{
                        return NewValidationError("autoscale target is required")
                }</span>
        }

        // Validate expose if present
        <span class="cov0" title="0">if s.Expose != nil </span><span class="cov0" title="0">{
                if s.Expose.Port == "" </span><span class="cov0" title="0">{
                        return NewValidationError("expose port is required")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Validate validates the health check configuration.
func (h *HealthCheck) Validate() error <span class="cov8" title="1">{
        if h.Liveness != nil </span><span class="cov8" title="1">{
                if err := h.Liveness.Validate(); err != nil </span><span class="cov8" title="1">{
                        return WrapValidationError(err, "invalid liveness probe")
                }</span>
        }

        <span class="cov8" title="1">if h.Readiness != nil </span><span class="cov0" title="0">{
                if err := h.Readiness.Validate(); err != nil </span><span class="cov0" title="0">{
                        return WrapValidationError(err, "invalid readiness probe")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Validate validates the probe configuration.
func (p *Probe) Validate() error <span class="cov8" title="1">{
        switch p.Type </span>{
        case "http":<span class="cov8" title="1">
                if p.Path == "" </span><span class="cov8" title="1">{
                        return NewValidationError("http probe must have a path")
                }</span>
                <span class="cov8" title="1">if p.Port &lt;= 0 </span><span class="cov8" title="1">{
                        return NewValidationError("http probe must have a valid port")
                }</span>
        case "tcp":<span class="cov0" title="0">
                if p.Port &lt;= 0 </span><span class="cov0" title="0">{
                        return NewValidationError("tcp probe must have a valid port")
                }</span>
        case "exec":<span class="cov0" title="0">
                if len(p.Command) == 0 </span><span class="cov0" title="0">{
                        return NewValidationError("exec probe must have a command")
                }</span>
        default:<span class="cov8" title="1">
                return NewValidationError("unknown probe type: " + p.Type)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package types

import (
        "fmt"
        "io/ioutil"
        "strconv"
        "time"

        "github.com/google/uuid"
        "gopkg.in/yaml.v3"
)

// ServiceSpec is the YAML/JSON specification for a service.
type ServiceSpec struct {
        // Human-readable name for the service (required)
        Name string `json:"name" yaml:"name"`

        // Namespace the service belongs to (optional, defaults to "default")
        Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`

        // Labels for the service
        Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty"`

        // Container image for the service (required)
        Image string `json:"image" yaml:"image"`

        // Command to run in the container (overrides image CMD)
        Command string `json:"command,omitempty" yaml:"command,omitempty"`

        // Arguments to the command
        Args []string `json:"args,omitempty" yaml:"args,omitempty"`

        // Environment variables for the service
        Env map[string]string `json:"env,omitempty" yaml:"env,omitempty"`

        // Number of instances to run (default: 1)
        Scale int `json:"scale" yaml:"scale"`

        // Ports exposed by the service
        Ports []ServicePort `json:"ports,omitempty" yaml:"ports,omitempty"`

        // Resource requirements for each instance
        Resources *Resources `json:"resources,omitempty" yaml:"resources,omitempty"`

        // Health checks for the service
        Health *HealthCheck `json:"health,omitempty" yaml:"health,omitempty"`

        // Network policy for controlling traffic
        NetworkPolicy *ServiceNetworkPolicy `json:"networkPolicy,omitempty" yaml:"networkPolicy,omitempty"`

        // External exposure configuration
        Expose *ServiceExpose `json:"expose,omitempty" yaml:"expose,omitempty"`

        // Placement preferences and requirements
        Affinity *ServiceAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty"`

        // Autoscaling configuration
        Autoscale *ServiceAutoscale `json:"autoscale,omitempty" yaml:"autoscale,omitempty"`

        // Secret mounts
        SecretMounts []SecretMount `json:"secretMounts,omitempty" yaml:"secretMounts,omitempty"`

        // Config mounts
        ConfigMounts []ConfigMount `json:"configMounts,omitempty" yaml:"configMounts,omitempty"`

        // Service discovery configuration
        Discovery *ServiceDiscovery `json:"discovery,omitempty" yaml:"discovery,omitempty"`
}

// ServiceFile represents a file containing service definitions.
type ServiceFile struct {
        // Service definition (only one of Service or Services should be set)
        Service *ServiceSpec `json:"service,omitempty" yaml:"service,omitempty"`

        // Multiple service definitions
        Services []ServiceSpec `json:"services,omitempty" yaml:"services,omitempty"`

        // Internal tracking for line numbers (not serialized)
        lineInfo map[string]int `json:"-" yaml:"-"`
}

// ParseServiceFile parses a YAML file containing service definitions.
func ParseServiceFile(filename string) (*ServiceFile, error) <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov8" title="1">return ParseServiceData(data)</span>
}

// ParseServiceData parses YAML data containing service definitions.
func ParseServiceData(data []byte) (*ServiceFile, error) <span class="cov8" title="1">{
        var serviceFile ServiceFile
        serviceFile.lineInfo = make(map[string]int)

        // First unmarshal normally to do basic parsing
        if err := yaml.Unmarshal(data, &amp;serviceFile); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        // Now decode again to track line numbers
        <span class="cov8" title="1">var node yaml.Node
        if err := yaml.Unmarshal(data, &amp;node); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse YAML structure: %w", err)
        }</span>

        // Extract line numbers
        <span class="cov8" title="1">if err := extractLineInfo(&amp;node, &amp;serviceFile); err != nil </span><span class="cov0" title="0">{
                // Don't fail if we can't extract line info, just continue
                fmt.Printf("Warning: couldn't extract line information: %v\n", err)
        }</span>

        // Validate that at least one service is defined
        <span class="cov8" title="1">if serviceFile.Service == nil &amp;&amp; len(serviceFile.Services) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no services defined in the file")
        }</span>

        <span class="cov8" title="1">return &amp;serviceFile, nil</span>
}

// extractLineInfo traverses the YAML node structure to find line numbers for services
func extractLineInfo(node *yaml.Node, serviceFile *ServiceFile) error <span class="cov8" title="1">{
        // Handle different document structures - single service or list of services
        if node.Kind == yaml.DocumentNode &amp;&amp; len(node.Content) &gt; 0 </span><span class="cov8" title="1">{
                return extractLineInfo(node.Content[0], serviceFile)
        }</span>

        <span class="cov8" title="1">if node.Kind == yaml.MappingNode &amp;&amp; len(node.Content) &gt;= 2 </span><span class="cov8" title="1">{
                for i := 0; i &lt; len(node.Content); i += 2 </span><span class="cov8" title="1">{
                        key := node.Content[i]
                        value := node.Content[i+1]

                        if key.Value == "service" &amp;&amp; value.Kind == yaml.MappingNode </span><span class="cov8" title="1">{
                                // Handle single service
                                for j := 0; j &lt; len(value.Content); j += 2 </span><span class="cov8" title="1">{
                                        if value.Content[j].Value == "name" </span><span class="cov8" title="1">{
                                                name := value.Content[j+1].Value
                                                serviceFile.lineInfo[name] = value.Line
                                                break</span>
                                        }
                                }
                        } else<span class="cov8" title="1"> if key.Value == "services" &amp;&amp; value.Kind == yaml.SequenceNode </span><span class="cov8" title="1">{
                                // Handle multiple services
                                for _, serviceNode := range value.Content </span><span class="cov8" title="1">{
                                        if serviceNode.Kind == yaml.MappingNode </span><span class="cov8" title="1">{
                                                for j := 0; j &lt; len(serviceNode.Content); j += 2 </span><span class="cov8" title="1">{
                                                        if serviceNode.Content[j].Value == "name" </span><span class="cov8" title="1">{
                                                                name := serviceNode.Content[j+1].Value
                                                                serviceFile.lineInfo[name] = serviceNode.Line
                                                                break</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Validate validates the service specification.
func (s *ServiceSpec) Validate() error <span class="cov8" title="1">{
        if s.Name == "" </span><span class="cov8" title="1">{
                return NewValidationError("service name is required")
        }</span>

        <span class="cov8" title="1">if s.Image == "" </span><span class="cov8" title="1">{
                return NewValidationError("service image is required")
        }</span>

        <span class="cov8" title="1">if s.Scale &lt; 0 </span><span class="cov8" title="1">{
                return NewValidationError("service scale cannot be negative")
        }</span>

        // Validate ports if present
        <span class="cov8" title="1">for i, port := range s.Ports </span><span class="cov8" title="1">{
                if port.Name == "" </span><span class="cov8" title="1">{
                        return NewValidationError("port name is required for port at index " + strconv.Itoa(i))
                }</span>
                <span class="cov8" title="1">if port.Port &lt;= 0 || port.Port &gt; 65535 </span><span class="cov8" title="1">{
                        return NewValidationError("port must be between 1 and 65535 for port " + port.Name)
                }</span>
        }

        // Validate health checks if present
        <span class="cov8" title="1">if s.Health != nil </span><span class="cov8" title="1">{
                if err := s.Health.Validate(); err != nil </span><span class="cov8" title="1">{
                        return WrapValidationError(err, "invalid health check")
                }</span>
        }

        // Validate network policy if present
        <span class="cov8" title="1">if s.NetworkPolicy != nil </span><span class="cov8" title="1">{
                if err := s.NetworkPolicy.Validate(); err != nil </span><span class="cov0" title="0">{
                        return WrapValidationError(err, "invalid network policy")
                }</span>
        }

        // Validate autoscale if present
        <span class="cov8" title="1">if s.Autoscale != nil &amp;&amp; s.Autoscale.Enabled </span><span class="cov8" title="1">{
                if s.Autoscale.Min &lt; 0 </span><span class="cov8" title="1">{
                        return NewValidationError("autoscale min cannot be negative")
                }</span>
                <span class="cov8" title="1">if s.Autoscale.Max &lt; s.Autoscale.Min </span><span class="cov8" title="1">{
                        return NewValidationError("autoscale max cannot be less than min")
                }</span>
                <span class="cov8" title="1">if s.Autoscale.Metric == "" </span><span class="cov8" title="1">{
                        return NewValidationError("autoscale metric is required")
                }</span>
                <span class="cov8" title="1">if s.Autoscale.Target == "" </span><span class="cov8" title="1">{
                        return NewValidationError("autoscale target is required")
                }</span>
        }

        // Validate expose if present
        <span class="cov8" title="1">if s.Expose != nil </span><span class="cov8" title="1">{
                if s.Expose.Port == "" </span><span class="cov8" title="1">{
                        return NewValidationError("expose port is required")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ToService converts a ServiceSpec to a Service.
func (s *ServiceSpec) ToService() (*Service, error) <span class="cov8" title="1">{
        // Validate
        if err := s.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Set default namespace if not specified
        <span class="cov8" title="1">namespace := s.Namespace
        if namespace == "" </span><span class="cov8" title="1">{
                namespace = "default"
        }</span>

        <span class="cov8" title="1">now := time.Now()

        var resources Resources
        if s.Resources != nil </span><span class="cov0" title="0">{
                resources = *s.Resources
        }</span>

        <span class="cov8" title="1">return &amp;Service{
                ID:            uuid.New().String(),
                Name:          s.Name,
                Namespace:     namespace,
                Labels:        s.Labels,
                Image:         s.Image,
                Command:       s.Command,
                Args:          s.Args,
                Env:           s.Env,
                Scale:         s.Scale,
                Ports:         s.Ports,
                Resources:     resources,
                Health:        s.Health,
                NetworkPolicy: s.NetworkPolicy,
                Expose:        s.Expose,
                Affinity:      s.Affinity,
                Autoscale:     s.Autoscale,
                SecretMounts:  s.SecretMounts,
                ConfigMounts:  s.ConfigMounts,
                Discovery:     s.Discovery,
                Status:        ServiceStatusPending,
                CreatedAt:     now,
                UpdatedAt:     now,
        }, nil</span>
}

// GetServices returns all services defined in the file.
func (f *ServiceFile) GetServices() []*ServiceSpec <span class="cov8" title="1">{
        var services []*ServiceSpec

        if f.Service != nil </span><span class="cov8" title="1">{
                services = append(services, f.Service)
        }</span>

        <span class="cov8" title="1">if len(f.Services) &gt; 0 </span><span class="cov8" title="1">{
                for i := range f.Services </span><span class="cov8" title="1">{
                        services = append(services, &amp;f.Services[i])
                }</span>
        }

        <span class="cov8" title="1">return services</span>
}

// GetLineInfo returns the approximate line number for a service by name
func (f *ServiceFile) GetLineInfo(name string) (int, bool) <span class="cov0" title="0">{
        if f.lineInfo == nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">line, ok := f.lineInfo[name]
        return line, ok</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">// Package version provides version information for the Rune platform.
package version

import (
        "fmt"
        "runtime"
)

var (
        // Version is the current version of Rune.
        // This is set during build time via ldflags.
        Version = "dev"

        // BuildTime is the time when the binary was built.
        // This is set during build time via ldflags.
        BuildTime = "unknown"

        // Commit is the git commit SHA that the binary was built from.
        // This is set during build time via ldflags.
        Commit = "unknown"
)

// Info returns version information as a formatted string.
func Info() string <span class="cov8" title="1">{
        commitID := Commit
        if len(commitID) &gt; 8 </span><span class="cov8" title="1">{
                commitID = commitID[:8]
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("Rune %s (%s) - %s %s/%s",
                Version,
                commitID,
                BuildTime,
                runtime.GOOS,
                runtime.GOARCH,
        )</span>
}

// Map returns version information as a map.
func Map() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "version":   Version,
                "commit":    Commit,
                "buildTime": BuildTime,
                "goVersion": runtime.Version(),
                "os":        runtime.GOOS,
                "arch":      runtime.GOARCH,
        }
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package helpers

import (
        "context"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/docker/docker/api/types/container"
        dockerContainer "github.com/docker/docker/api/types/container"
        imageTypes "github.com/docker/docker/api/types/image"
        "github.com/docker/docker/client"
        "github.com/docker/docker/pkg/stdcopy"
)

// DockerHelper provides utilities for working with Docker containers in tests
type DockerHelper struct {
        client *client.Client
}

// NewDockerHelper creates a new Docker helper instance
func NewDockerHelper() (*DockerHelper, error) <span class="cov0" title="0">{
        cli, err := client.NewClientWithOpts(
                client.FromEnv,
                client.WithVersion("1.43"), // Force compatibility with older Docker daemons
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Docker client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;DockerHelper{
                client: cli,
        }, nil</span>
}

// Close closes the Docker client
func (h *DockerHelper) Close() error <span class="cov0" title="0">{
        return h.client.Close()
}</span>

// EnsureImage ensures the specified image is available, pulling it if necessary
func (h *DockerHelper) EnsureImage(ctx context.Context, image string) error <span class="cov0" title="0">{
        _, _, err := h.client.ImageInspectWithRaw(ctx, image)
        if err == nil </span><span class="cov0" title="0">{
                // Image already exists
                return nil
        }</span>

        <span class="cov0" title="0">if !client.IsErrNotFound(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("error checking for image %s: %w", image, err)
        }</span>

        // Pull the image
        <span class="cov0" title="0">out, err := h.client.ImagePull(ctx, image, imageTypes.PullOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to pull image %s: %w", image, err)
        }</span>
        <span class="cov0" title="0">defer out.Close()

        // Wait for the pull to complete
        _, err = io.Copy(io.Discard, out)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading image pull output: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateContainer creates a new container
func (h *DockerHelper) CreateContainer(ctx context.Context, config *container.Config, hostConfig *container.HostConfig, name string) (string, error) <span class="cov0" title="0">{
        resp, err := h.client.ContainerCreate(ctx, config, hostConfig, nil, nil, name)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create container: %w", err)
        }</span>

        <span class="cov0" title="0">return resp.ID, nil</span>
}

// StartContainer starts a container
func (h *DockerHelper) StartContainer(ctx context.Context, containerID string) error <span class="cov0" title="0">{
        return h.client.ContainerStart(ctx, containerID, container.StartOptions{})
}</span>

// StopContainer stops a container
func (h *DockerHelper) StopContainer(ctx context.Context, containerID string, timeout time.Duration) error <span class="cov0" title="0">{
        timeoutSec := int(timeout.Seconds())
        return h.client.ContainerStop(ctx, containerID, container.StopOptions{Timeout: &amp;timeoutSec})
}</span>

// RemoveContainer removes a container
func (h *DockerHelper) RemoveContainer(ctx context.Context, containerID string, force bool) error <span class="cov0" title="0">{
        return h.client.ContainerRemove(ctx, containerID, container.RemoveOptions{
                Force: force,
        })
}</span>

// CleanupContainer stops and removes a container
func (h *DockerHelper) CleanupContainer(ctx context.Context, containerID string) <span class="cov0" title="0">{
        // Stop container with 5 second timeout
        timeout := 5 * time.Second
        timeoutSec := int(timeout.Seconds())

        err := h.client.ContainerStop(ctx, containerID, container.StopOptions{Timeout: &amp;timeoutSec})
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to stop container %s: %v\n", containerID, err)
        }</span>

        // Remove container
        <span class="cov0" title="0">err = h.client.ContainerRemove(ctx, containerID, container.RemoveOptions{
                Force: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to remove container %s: %v\n", containerID, err)
        }</span>
}

// GetContainerLogs retrieves logs from a container
func (h *DockerHelper) GetContainerLogs(ctx context.Context, containerID string) (string, error) <span class="cov0" title="0">{
        reader, err := h.client.ContainerLogs(ctx, containerID, container.LogsOptions{
                ShowStdout: true,
                ShowStderr: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get container logs: %w", err)
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        var stdout, stderr strings.Builder
        _, err = stdcopy.StdCopy(&amp;stdout, &amp;stderr, reader)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read container logs: %w", err)
        }</span>

        // Combine stdout and stderr
        <span class="cov0" title="0">return fmt.Sprintf("STDOUT:\n%s\nSTDERR:\n%s", stdout.String(), stderr.String()), nil</span>
}

// ExecCommand executes a command in a running container
func (h *DockerHelper) ExecCommand(ctx context.Context, containerID string, cmd []string) (string, error) <span class="cov0" title="0">{
        execConfig := dockerContainer.ExecOptions{
                Cmd:          cmd,
                AttachStdout: true,
                AttachStderr: true,
        }

        // Create exec instance
        execResp, err := h.client.ContainerExecCreate(ctx, containerID, execConfig)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create exec: %w", err)
        }</span>

        // Attach to exec instance
        <span class="cov0" title="0">resp, err := h.client.ContainerExecAttach(ctx, execResp.ID, container.ExecStartOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to attach to exec: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Close()

        // Read output
        var stdout, stderr strings.Builder
        _, err = stdcopy.StdCopy(&amp;stdout, &amp;stderr, resp.Reader)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read exec output: %w", err)
        }</span>

        // Get exec result
        <span class="cov0" title="0">inspectResp, err := h.client.ContainerExecInspect(ctx, execResp.ID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to inspect exec: %w", err)
        }</span>

        <span class="cov0" title="0">output := fmt.Sprintf("STDOUT:\n%s\nSTDERR:\n%s", stdout.String(), stderr.String())

        // Check exit code
        if inspectResp.ExitCode != 0 </span><span class="cov0" title="0">{
                return output, fmt.Errorf("command failed with exit code %d", inspectResp.ExitCode)
        }</span>

        <span class="cov0" title="0">return output, nil</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package helpers

import (
        "context"
        "os"
        "testing"
        "time"
)

var (
        AlpineImage = "alpine:latest"
)

// IntegrationTest provides a structured way to set up and tear down integration tests
func IntegrationTest(t *testing.T, testFunc func(ctx context.Context, h *DockerHelper)) <span class="cov0" title="0">{
        // Skip test if the SKIP_INTEGRATION_TESTS environment variable is set
        if os.Getenv("SKIP_INTEGRATION_TESTS") == "true" </span><span class="cov0" title="0">{
                t.Skip("Skipping integration test because SKIP_INTEGRATION_TESTS=true")
        }</span>

        // Skip if integration tests are only allowed in CI and we're not in CI
        <span class="cov0" title="0">if os.Getenv("INTEGRATION_TESTS_CI_ONLY") == "true" &amp;&amp; os.Getenv("CI") != "true" </span><span class="cov0" title="0">{
                t.Skip("Skipping integration test because INTEGRATION_TESTS_CI_ONLY=true and not running in CI")
        }</span>

        // Create a docker helper
        <span class="cov0" title="0">h, err := NewDockerHelper()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create Docker helper: %v", err)
        }</span>
        <span class="cov0" title="0">if h == nil </span><span class="cov0" title="0">{
                // Test has already been skipped in NewDockerHelper if Docker is not available
                return
        }</span>

        // Create a context with timeout for the entire test
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
        defer cancel()

        // Run the test function
        testFunc(ctx, h)</span>
}

// RequireEnvVar ensures that an environment variable is set, skipping the test if not present
func RequireEnvVar(t *testing.T, name string) string <span class="cov0" title="0">{
        value := os.Getenv(name)
        if value == "" </span><span class="cov0" title="0">{
                t.Skipf("Required environment variable %s is not set", name)
        }</span>
        <span class="cov0" title="0">return value</span>
}

// GetEnvOrDefault gets an environment variable or returns the default value if not set
func GetEnvOrDefault(name, defaultValue string) string <span class="cov0" title="0">{
        value := os.Getenv(name)
        if value == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return value</span>
}

// IsCI returns true if running in a CI environment
func IsCI() bool <span class="cov0" title="0">{
        return os.Getenv("CI") == "true"
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">package helpers

import (
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "testing"

        "github.com/rzbill/rune/pkg/api/server"
        "github.com/rzbill/rune/pkg/log"
        "github.com/rzbill/rune/pkg/store"
        "github.com/rzbill/rune/pkg/types"
        "github.com/stretchr/testify/require"
)

// TestHelper provides utilities for integration testing
type TestHelper struct {
        t          *testing.T
        tempDir    string
        apiServer  *server.APIServer
        runeBinary string
        store      *store.MemoryStore
        fixtureDir string
}

// NewTestHelper creates a new test helper
func NewTestHelper(t *testing.T) *TestHelper <span class="cov8" title="1">{
        tempDir, err := os.MkdirTemp("", "rune-test-*")
        require.NoError(t, err)

        // Create fixture directory
        fixtureDir := filepath.Join(tempDir, "fixtures")
        err = os.MkdirAll(fixtureDir, 0755)
        require.NoError(t, err)

        // Find rune binary
        runeBinary := os.Getenv("RUNE_BINARY")
        if runeBinary == "" </span><span class="cov8" title="1">{
                // Look for test binary
                runeBinary, err = exec.LookPath("rune-test")
                if err != nil </span><span class="cov8" title="1">{
                        // Build the test binary
                        cmd := exec.Command("go", "build", "-o", filepath.Join(tempDir, "rune-test"), "github.com/rzbill/rune/cmd/rune-test")
                        output, err := cmd.CombinedOutput()
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("Failed to build test binary: %s\nOutput: %s", err, output)
                        }</span>
                        <span class="cov8" title="1">runeBinary = filepath.Join(tempDir, "rune-test")</span>
                }
        }

        <span class="cov8" title="1">return &amp;TestHelper{
                t:          t,
                tempDir:    tempDir,
                runeBinary: runeBinary,
                fixtureDir: fixtureDir,
        }</span>
}

// Cleanup removes temporary test resources
func (h *TestHelper) Cleanup() <span class="cov8" title="1">{
        if h.apiServer != nil </span><span class="cov8" title="1">{
                // Protect against double-closing the server
                server := h.apiServer
                h.apiServer = nil
                server.Stop()
        }</span>
        <span class="cov8" title="1">os.RemoveAll(h.tempDir)</span>
}

// StartAPIServer starts a test API server
func (h *TestHelper) StartAPIServer() *server.APIServer <span class="cov8" title="1">{
        logger := log.GetDefaultLogger().WithComponent("test-api-server")

        // Create a memory store for testing
        memStore := store.NewMemoryStore()
        h.store = memStore

        // Create API server options
        opts := []server.Option{
                server.WithStore(memStore),
                server.WithLogger(logger),
                server.WithGRPCAddr(":0"), // Random port
                server.WithHTTPAddr(":0"), // Random port
        }

        apiServer, err := server.New(opts...)
        require.NoError(h.t, err)

        err = apiServer.Start()
        require.NoError(h.t, err)

        h.apiServer = apiServer
        return apiServer
}</span>

// RunCommand executes a rune CLI command
func (h *TestHelper) RunCommand(args ...string) (string, error) <span class="cov8" title="1">{
        // Set environment for the test binary
        env := append(os.Environ(),
                fmt.Sprintf("RUNE_FIXTURE_DIR=%s", h.fixtureDir),
        )

        // Run the command
        cmd := exec.Command(h.runeBinary, args...)
        cmd.Env = env

        // Get output
        out, err := cmd.CombinedOutput()

        // After running a cast command, load any fixtures that were created
        if len(args) &gt; 0 &amp;&amp; args[0] == "cast" &amp;&amp; err == nil </span><span class="cov8" title="1">{
                h.loadFixtures(context.Background())
        }</span>

        <span class="cov8" title="1">return string(out), err</span>
}

// loadFixtures loads any fixture files in the fixture directory into the memory store
func (h *TestHelper) loadFixtures(ctx context.Context) error <span class="cov8" title="1">{
        if h.store == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("store not initialized")
        }</span>

        // Read fixture directory
        <span class="cov8" title="1">files, err := ioutil.ReadDir(h.fixtureDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Make sure services resource type exists in the store
        <span class="cov8" title="1">h.store.EnsureResourceType("services")

        for _, file := range files </span><span class="cov8" title="1">{
                if file.IsDir() || filepath.Ext(file.Name()) != ".json" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Read fixture file
                <span class="cov8" title="1">data, err := ioutil.ReadFile(filepath.Join(h.fixtureDir, file.Name()))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Parse service
                <span class="cov8" title="1">var serviceMap map[string]interface{}
                if err := json.Unmarshal(data, &amp;serviceMap); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Convert to service type
                <span class="cov8" title="1">svc := &amp;types.Service{}

                // Set basic fields
                if name, ok := serviceMap["name"].(string); ok </span><span class="cov8" title="1">{
                        svc.Name = name
                }</span>

                <span class="cov8" title="1">if namespace, ok := serviceMap["namespace"].(string); ok </span><span class="cov8" title="1">{
                        svc.Namespace = namespace
                }</span> else<span class="cov0" title="0"> {
                        svc.Namespace = "default"
                }</span>

                // Make sure the namespace exists in the store
                <span class="cov8" title="1">h.store.EnsureNamespace("services", svc.Namespace)

                if runtime, ok := serviceMap["runtime"].(string); ok </span><span class="cov8" title="1">{
                        svc.Runtime = types.RuntimeType(runtime)
                }</span>

                <span class="cov8" title="1">if image, ok := serviceMap["image"].(string); ok </span><span class="cov8" title="1">{
                        svc.Image = image
                }</span>

                <span class="cov8" title="1">if command, ok := serviceMap["command"].([]interface{}); ok </span><span class="cov8" title="1">{
                        svc.Command = command[0].(string)
                        if len(command) &gt; 1 </span><span class="cov8" title="1">{
                                args := make([]string, len(command)-1)
                                for i, arg := range command[1:] </span><span class="cov8" title="1">{
                                        args[i] = arg.(string)
                                }</span>
                                <span class="cov8" title="1">svc.Args = args</span>
                        }
                }

                <span class="cov8" title="1">if scale, ok := serviceMap["scale"].(float64); ok </span><span class="cov0" title="0">{
                        svc.Scale = int(scale)
                }</span> else<span class="cov8" title="1"> if scale, ok := serviceMap["scale"].(string); ok </span><span class="cov8" title="1">{
                        // Try to parse the string
                        var s int
                        fmt.Sscanf(scale, "%d", &amp;s)
                        svc.Scale = s
                }</span>

                // Set status to running by default
                <span class="cov8" title="1">svc.Status = types.ServiceStatusRunning

                // Store the service
                err = h.store.Create(ctx, "services", svc.Namespace, svc.Name, svc)
                if err != nil </span><span class="cov8" title="1">{
                        // If it already exists, that's not a fatal error
                        if !strings.Contains(err.Error(), "already exists") </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// GetService directly accesses the memory store to verify a service was created
func (h *TestHelper) GetService(ctx context.Context, namespace, name string) (*types.Service, error) <span class="cov8" title="1">{
        if h.store == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("store not initialized")
        }</span>

        // First ensure the namespace exists
        <span class="cov8" title="1">h.store.EnsureResourceType("services")
        h.store.EnsureNamespace("services", namespace)

        var svc types.Service
        err := h.store.Get(ctx, types.ResourceTypeService, namespace, name, &amp;svc)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;svc, nil</span>
}

// CreateTestService creates a service directly in the store for testing
func (h *TestHelper) CreateTestService(ctx context.Context, svc *types.Service) error <span class="cov8" title="1">{
        if h.store == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("store not initialized")
        }</span>

        <span class="cov8" title="1">if svc.Namespace == "" </span><span class="cov0" title="0">{
                svc.Namespace = "default"
        }</span>

        <span class="cov8" title="1">return h.store.Create(ctx, "services", svc.Namespace, svc.Name, svc)</span>
}

// TempDir returns the temporary directory for this test
func (h *TestHelper) TempDir() string <span class="cov0" title="0">{
        return h.tempDir
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
